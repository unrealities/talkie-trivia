This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-12-07T14:43:35.953Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
__mocks__/
  fileMock.js
  react-native-animated.js
  vectorIconsMock.js
__tests__/
  __snapshots__/
    skeletonRow.test.tsx.snap
  contexts/
    authContext.test.tsx
  converters/
    gameHistoryEntry.test.ts
    player.test.ts
    playerGame.test.ts
    playerStats.test.ts
  hooks/
    useHintLogic.test.ts
  services/
    gameService.test.ts
    gameServiceFactory.test.ts
    movieDataService.test.ts
    videoGameService.test.ts
  state/
    gameStore.test.ts
  utils/
    analyticsService.test.ts
    hapticsService.test.ts
    shareUtils.test.ts
  actors.test.tsx
  app_layout.test.tsx
  button.test.tsx
  card.test.tsx
  clues.test.tsx
  confettiCelebration.test.tsx
  confirmationModal.test.tsx
  countdownTimer.test.tsx
  customLoadingIndicator.test.tsx
  detailModal.test.tsx
  difficultySelector.test.tsx
  emptyGuessTile.test.tsx
  errorBoundary.test.tsx
  errorMessage.test.tsx
  facts.test.tsx
  flashMessages.test.tsx
  fullPlotSection.test.tsx
  game_screen.test.tsx
  gameDifficultyToggle.test.tsx
  gameHistory.test.tsx
  gameOverView.test.tsx
  gameplayContainer.test.tsx
  gameplayView.test.tsx
  gameStore.test.tsx
  genres.test.tsx
  googleLogin.test.tsx
  guesses.test.tsx
  guessFeedbackUtils.test.tsx
  guessRow.test.tsx
  hint.test.tsx
  hintButton.test.tsx
  hintUI.test.tsx
  historyDetailModal.test.tsx
  loadingIndicator.test.tsx
  network.test.tsx
  networkContest.test.tsx
  personalizedStatsMessage.test.tsx
  picker.test.tsx
  pickerItem.test.tsx
  pickerSkeleton.test.tsx
  pickerUI.test.tsx
  playerStats.test.tsx
  profile_screen.test.tsx
  profileSection.test.tsx
  revealSequence.test.tsx
  scoreUtils.test.tsx
  shareResultButton.test.tsx
  skeletonRow.test.tsx
  statItem.test.tsx
  stringUtils.test.tsx
  tabs_layout.test.tsx
  themeSelector.test.tsx
  titleHeader.test.tsx
  tutorialTip.test.tsx
  typography.test.tsx
  useExternalLink.test.tsx
  useGoogleAuth.test.tsx
  useGuessAnimation.test.tsx
  useHintLogic.test.tsx
  useStyles.test.tsx
  utils.test.ts
  whereToWatch.test.tsx
  winChart.test.tsx
.expo-shared/
  assets.json
.github/
  workflows/
    unit-tests.yml
.idx/
  dev.nix
.maestro/
  flows/
    give-up.yaml
    happy-path-win.yaml
    history-check.yaml
    losing-game.yaml
src/
  app/
    (tabs)/
      _layout.tsx
      game.tsx
      index.tsx
      profile.tsx
    _layout.tsx
  components/
    gameOver/
      fullPlotSection.tsx
      shareResultButton.tsx
    guess/
      emptyGuessTile.tsx
      guessRow.tsx
      skeletonRow.tsx
    ui/
      button.tsx
      card.tsx
      typography.tsx
    actors.tsx
    clues.tsx
    confettiCelebration.tsx
    confirmationModal.tsx
    countdownTimer.tsx
    customLoadingIndicator.tsx
    detailModal.tsx
    difficultySelector.tsx
    errorBoundary.tsx
    errorMessage.tsx
    facts.tsx
    flashMessages.tsx
    gameDifficultyToggle.tsx
    gameHistory.tsx
    gameOverView.tsx
    gameplayContainer.tsx
    gameplayView.tsx
    genres.tsx
    googleLogin.tsx
    guesses.tsx
    hint.tsx
    hintButton.tsx
    hintUI.tsx
    historyDetailModal.tsx
    loadingIndicator.tsx
    network.tsx
    personalizedStatsMessage.tsx
    picker.tsx
    pickerItem.tsx
    pickerSkeleton.tsx
    pickerUI.tsx
    playerStats.tsx
    profileSection.tsx
    revealSequence.tsx
    statItem.tsx
    themeSelector.tsx
    titleHeader.tsx
    tutorialTooltip.tsx
    utils.ts
    victory-charts.ts
    victory-charts.web.ts
    whereToWatch.tsx
    winChart.tsx
  config/
    constants.ts
    difficulty.ts
    firebase.ts
  contexts/
    authContext.tsx
    networkContext.tsx
    themeContext.tsx
  models/
    default.ts
    game.ts
    gameHistory.ts
    player.ts
    playerStats.ts
    trie.ts
    trivia.ts
  services/
    firebaseClient.ts
    gameService.ts
    gameServiceFactory.ts
    iGameDataService.ts
    movieDataService.ts
    videoGameService.ts
  state/
    gameStore.ts
  styles/
    global.ts
    themes.ts
    utils.ts
  utils/
    firestore/
      converters/
        gameHistoryEntry.ts
        player.ts
        playerGame.ts
        playerStats.ts
    hooks/
      useExternalLink.ts
      useGoogleAuth.ts
      useGuessAnimation.ts
      useHintLogic.ts
      useSkeletonAnimation.ts
      useStyles.ts
    analyticsService.ts
    guessFeedbackUtils.ts
    hapticsService.ts
    scoreUtils.ts
    shareUtils.ts
    stringUtils.ts
utils/
  basicMovies/
    basicMovies.go
    go.mod
  credits/
    credits.go
    go.mod
  data-pipeline/
    go.mod
    main.go
  fetchMovies/
    fetchMovies.go
    go.mod
  fetchMoviesCredits/
    fetchMoviesCredits.go
    go.mod
  fetchPopularMovies/
    fetchPopularMovies.go
    go.mod
  firebase-functions/
    DailyMovie.js
  movies/
    go.mod
    movies.go
  populate-firestore/
    go.mod
    go.sum
    main.go
  schedule-games/
    go.mod
    go.sum
    main.go
  secrets.example.json
.gitignore
app.config.js
babel.config.js
firestore.rules
index.tsx
jest.config.js
jestSetup.js
LICENSE
package.json
README.md
repomix.config.json
tsconfig.json

================================================================
Files
================================================================

================
File: __mocks__/fileMock.js
================
module.exports = 1;

================
File: __mocks__/react-native-animated.js
================
require('react-native-reanimated/lib/reanimated2/jestUtils').setUpTests();
const Reanimated = require('react-native-reanimated/mock');

// Silent success for worklet calls
Reanimated.default.call = () => { };

module.exports = {
  ...Reanimated,
  useSharedValue: jest.fn((initialValue) => ({ value: initialValue })),
  useAnimatedStyle: jest.fn((styleFactory) => styleFactory()),
  useAnimatedReaction: jest.fn(),
  withTiming: jest.fn((toValue, _, cb) => {
    if (cb) cb(true);
    return toValue;
  }),
  withSpring: jest.fn((toValue) => toValue),
  withSequence: jest.fn((...args) => args[args.length - 1]),
  withDelay: jest.fn((_, animation) => animation),
  withRepeat: jest.fn((animation) => animation),
  runOnJS: (fn) => fn,
  Easing: {
    linear: (t) => t,
    inOut: (fn) => fn,
    ease: (t) => t,
    out: (fn) => fn,
    exp: (t) => t,
    poly: (n) => (t) => t,
  },
};

================
File: __mocks__/vectorIconsMock.js
================
import React from 'react';

const MockIcon = ({ name, size, color, ...props }) => {
    return <span data-testid={`mock-icon-${name}`} {...props}>Icon: {name}</span>;
};

export default MockIcon;

================
File: __tests__/__snapshots__/skeletonRow.test.tsx.snap
================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Guess Component: SkeletonRow should render the skeleton text container 1`] = `
<View
  style={
    [
      {
        "alignItems": "center",
        "backgroundColor": "#E0E0E0",
        "borderRadius": 8,
        "flexDirection": "row",
        "marginBottom": 8,
        "minHeight": 44,
        "paddingHorizontal": 16,
        "paddingVertical": 8,
      },
      {
        "opacity": 0.5,
      },
    ]
  }
>
  <Text
    style={
      {
        "color": "#757575",
        "fontFamily": "Arvo-Bold",
        "fontSize": 14,
        "marginRight": 8,
      }
    }
  >
    1
  </Text>
  <View
    style={
      {
        "backgroundColor": "#BDBDBD",
        "borderRadius": 4,
        "flex": 1,
        "overflow": "hidden",
      }
    }
  >
    <View
      style={
        {
          "height": 16,
          "width": "100%",
        }
      }
    />
  </View>
</View>
`;

================
File: __tests__/contexts/authContext.test.tsx
================
import React from "react"
import { View, Text } from "react-native"
import { render, screen, waitFor, act } from "@testing-library/react-native"
import { AuthProvider, useAuth } from "../../src/contexts/authContext"
import { getAuth, onAuthStateChanged, signInAnonymously } from "firebase/auth"
import { gameService } from "../../src/services/gameService"

// Mocks
jest.mock("firebase/auth")
jest.mock("../../src/services/gameService")
jest.mock("../../src/utils/analyticsService")
jest.mock("../../src/utils/hooks/useGoogleAuth", () => ({
  useGoogleAuth: () => ({
    isLoading: false,
    authError: null,
    handleSignIn: jest.fn(),
    handleSignOut: jest.fn(),
  }),
}))

// Component to consume context
const TestConsumer = () => {
  const { user, player, loading, error } = useAuth()
  return (
    <View>
      <Text testID="status">{loading ? "Loading" : "Ready"}</Text>
      <Text testID="error">{error ? error : "No Error"}</Text>
      <Text testID="user">{user ? "User Logged In" : "No User"}</Text>
      <Text testID="player">
        {player ? `Player: ${player.name}` : "No Player"}
      </Text>
    </View>
  )
}

describe("AuthContext", () => {
  let authStateCallback: (user: any) => void

  beforeEach(() => {
    jest.clearAllMocks()

    // Capture the auth listener callback
    ;(onAuthStateChanged as jest.Mock).mockImplementation((auth, callback) => {
      authStateCallback = callback
      return jest.fn() // Unsubscribe mock
    })

    ;(getAuth as jest.Mock).mockReturnValue({})
  })

  it("initializes in loading state", () => {
    render(
      <AuthProvider>
        <TestConsumer />
      </AuthProvider>
    )
    expect(screen.getByTestId("status")).toHaveTextContent("Loading")
  })

  it("handles successful login and fetches player data", async () => {
    const mockFirebaseUser = { uid: "123", isAnonymous: true }
    const mockPlayer = { id: "123", name: "Guest Player" }

    ;(gameService.ensurePlayerExists as jest.Mock).mockResolvedValue(mockPlayer)

    render(
      <AuthProvider>
        <TestConsumer />
      </AuthProvider>
    )

    // Simulate Firebase emitting a user
    await act(async () => {
      authStateCallback(mockFirebaseUser)
    })

    await waitFor(() => {
      expect(screen.getByTestId("status")).toHaveTextContent("Ready")
      expect(screen.getByTestId("user")).toHaveTextContent("User Logged In")
      expect(screen.getByTestId("player")).toHaveTextContent(
        "Player: Guest Player"
      )
    })
  })

  it("handles login failure gracefully", async () => {
    render(
      <AuthProvider>
        <TestConsumer />
      </AuthProvider>
    )

    // Simulate Firebase auth failing immediately inside the listener logic (e.g. ensurePlayerExists fails)
    const errorMsg = "Network Error"
    ;(gameService.ensurePlayerExists as jest.Mock).mockRejectedValue(
      new Error(errorMsg)
    )

    await act(async () => {
      authStateCallback({ uid: "123" })
    })

    await waitFor(() => {
      expect(screen.getByTestId("status")).toHaveTextContent("Ready")
      // FIX: Match the full error string provided by the context ("Authentication failed: ...")
      expect(screen.getByTestId("error")).toHaveTextContent(
        `Authentication failed: ${errorMsg}`
      )
      expect(screen.getByTestId("player")).toHaveTextContent("No Player")
    })
  })

  it("signs in anonymously if no user exists", async () => {
    render(
      <AuthProvider>
        <TestConsumer />
      </AuthProvider>
    )

    // Simulate Firebase returning null (no user logged in)
    await act(async () => {
      authStateCallback(null)
    })

    expect(signInAnonymously).toHaveBeenCalled()
  })
})

================
File: __tests__/converters/gameHistoryEntry.test.ts
================
import { gameHistoryEntryConverter } from "../../src/utils/firestore/converters/gameHistoryEntry"
import { GameHistoryEntry } from "../../src/models/gameHistory"

describe("Firestore Converter: GameHistoryEntry", () => {
  const mockEntry: GameHistoryEntry = {
    dateId: "2023-01-01",
    itemId: 123,
    itemTitle: "Test Movie",
    posterPath: "/path.jpg",
    wasCorrect: true,
    gaveUp: false,
    guessCount: 3,
    guessesMax: 5,
    difficulty: "LEVEL_3",
    score: 500,
    gameMode: "movies",
  }

  describe("toFirestore", () => {
    it("should correctly map model to firestore object", () => {
      const result = gameHistoryEntryConverter.toFirestore(mockEntry)

      expect(result).toEqual(
        expect.objectContaining({
          dateId: "2023-01-01",
          itemId: 123,
          score: 500,
          gameMode: "movies",
        })
      )
      // Check that Timestamp.now() was called (we can check property existence in our mock)
      expect(result.createdAt).toBeDefined()
    })

    it("should default gameMode to movies if missing", () => {
      const entry = { ...mockEntry, gameMode: undefined }
      // @ts-ignore
      const result = gameHistoryEntryConverter.toFirestore(entry)
      expect(result.gameMode).toBe("movies")
    })
  })

  describe("fromFirestore", () => {
    it("should correctly map firestore data to model", () => {
      const snapshot = {
        data: () => ({
          dateId: "2023-01-01",
          itemId: 123,
          itemTitle: "Test Movie",
          posterPath: "/path.jpg",
          wasCorrect: true,
          gaveUp: false,
          guessCount: 3,
          guessesMax: 5,
          difficulty: "LEVEL_3",
          score: 500,
          gameMode: "movies",
        }),
      }

      // @ts-ignore
      const result = gameHistoryEntryConverter.fromFirestore(snapshot, {})
      expect(result).toEqual(mockEntry)
    })

    it("should handle legacy field names (movieId vs itemId)", () => {
      const snapshot = {
        data: () => ({
          dateId: "2023-01-01",
          movieId: 999, // Legacy field
          movieTitle: "Legacy Title", // Legacy field
          posterPath: "/path.jpg",
          wasCorrect: true,
          gaveUp: false,
          guessCount: 1,
          guessesMax: 5,
        }),
      }

      // @ts-ignore
      const result = gameHistoryEntryConverter.fromFirestore(snapshot, {})
      expect(result.itemId).toBe(999)
      expect(result.itemTitle).toBe("Legacy Title")
    })

    it("should provide default values for missing fields", () => {
      const snapshot = {
        data: () => ({
          dateId: "2023-01-01",
        }),
      }

      // @ts-ignore
      const result = gameHistoryEntryConverter.fromFirestore(snapshot, {})
      expect(result.score).toBe(0)
      expect(result.difficulty).toBe("LEVEL_3") // Default
      expect(result.gameMode).toBe("movies")
    })
  })
})

================
File: __tests__/converters/player.test.ts
================
import { playerConverter } from "../../src/utils/firestore/converters/player"
import Player from "../../src/models/player"

describe("Firestore Converter: Player", () => {
  const mockPlayer = new Player("user-123", "Test User")

  describe("toFirestore", () => {
    it("should correctly convert Player model to Firestore object", () => {
      const result = playerConverter.toFirestore(mockPlayer)
      expect(result).toEqual({
        id: "user-123",
        name: "Test User",
      })
    })
  })

  describe("fromFirestore", () => {
    it("should correctly convert Firestore data to Player model", () => {
      const snapshot = {
        data: () => ({
          id: "user-123",
          name: "Test User",
        }),
      }

      // @ts-ignore
      const result = playerConverter.fromFirestore(snapshot, {})
      // The converter returns a plain object that conforms to the Player interface
      expect(result).toEqual(
        expect.objectContaining({
          id: "user-123",
          name: "Test User",
        })
      )
    })
  })
})

================
File: __tests__/converters/playerGame.test.ts
================
import { playerGameConverter } from "../../src/utils/firestore/converters/playerGame"
import { Timestamp } from "firebase/firestore"
import { defaultPlayerGame } from "../../src/models/default"

describe("Firestore Converter: PlayerGame", () => {
  // Mock data helpers
  const mockDate = new Date("2023-01-01T12:00:00.000Z")
  // Use the mocked Timestamp class
  const mockTimestamp = Timestamp.fromDate(mockDate)

  const mockPlayerGame = {
    ...defaultPlayerGame,
    id: "test-game-1",
    playerID: "player-1",
    guesses: [{ itemId: 101 }],
    correctAnswer: true,
    difficulty: "LEVEL_3",
    startDate: mockDate,
    endDate: mockDate,
  }

  describe("toFirestore", () => {
    it("should flatten the object and handle optional fields correctly", () => {
      // @ts-ignore
      const result = playerGameConverter.toFirestore(mockPlayerGame)

      expect(result).toEqual(
        expect.objectContaining({
          id: "test-game-1",
          playerID: "player-1",
          correctAnswer: true,
          difficulty: "LEVEL_3",
          statsProcessed: false, // Default check
        })
      )

      // Ensure complex objects are passed through
      expect(result.guesses).toHaveLength(1)
      expect(result.guesses[0].itemId).toBe(101)
    })

    it("should default difficulty if missing", () => {
      const gameMissingDiff = { ...mockPlayerGame, difficulty: undefined }
      // @ts-ignore
      const result = playerGameConverter.toFirestore(gameMissingDiff)
      expect(result.difficulty).toBe("LEVEL_3") // Default fallback
    })
  })

  describe("fromFirestore", () => {
    it("should correctly convert Firestore Timestamps to JS Dates", () => {
      const snapshot = {
        data: () => ({
          id: "test-game-1",
          playerID: "player-1",
          guesses: [],
          startDate: mockTimestamp, // Firestore format
          endDate: mockTimestamp, // Firestore format
          difficulty: "LEVEL_4",
        }),
      }

      // @ts-ignore
      const result = playerGameConverter.fromFirestore(snapshot, {})

      expect(result.startDate).toBeInstanceOf(Date)
      expect(result.startDate.toISOString()).toBe(mockDate.toISOString())
      expect(result.difficulty).toBe("LEVEL_4")
    })

    it("should handle legacy string dates if present", () => {
      const snapshot = {
        data: () => ({
          startDate: "2023-01-01T12:00:00.000Z", // String format
          endDate: "2023-01-01T12:00:00.000Z",
        }),
      }

      // @ts-ignore
      const result = playerGameConverter.fromFirestore(snapshot, {})
      expect(result.startDate).toBeInstanceOf(Date)
    })

    it("should merge with defaultPlayerGame structure to prevent undefined errors", () => {
      const snapshot = {
        data: () => ({
          id: "partial-data",
          // Missing guesses, statsProcessed, etc.
        }),
      }

      // @ts-ignore
      const result = playerGameConverter.fromFirestore(snapshot, {})

      // Should have defaults filled in
      expect(result.guesses).toEqual([])
      expect(result.statsProcessed).toBe(false)
    })
  })
})

================
File: __tests__/converters/playerStats.test.ts
================
import { playerStatsConverter } from "../../src/utils/firestore/converters/playerStats"
import PlayerStats from "../../src/models/playerStats"

describe("Firestore Converter: PlayerStats", () => {
  const mockStats: PlayerStats = {
    id: "player-1",
    currentStreak: 5,
    games: 10,
    maxStreak: 5,
    wins: [0, 1, 2, 3, 4],
    hintsAvailable: 10,
    hintsUsedCount: 2,
    lastStreakMessageDate: "2023-01-01",
    allTimeScore: 1000,
  }

  describe("toFirestore", () => {
    it("should pass through all fields correctly", () => {
      const result = playerStatsConverter.toFirestore(mockStats)
      expect(result).toEqual(mockStats)
    })

    it("should handle null/undefined lastStreakMessageDate", () => {
      const stats = { ...mockStats, lastStreakMessageDate: undefined }
      // @ts-ignore
      const result = playerStatsConverter.toFirestore(stats)
      expect(result.lastStreakMessageDate).toBeUndefined()
    })

    it("should default allTimeScore to 0 if missing", () => {
      const stats = { ...mockStats, allTimeScore: undefined }
      // @ts-ignore
      const result = playerStatsConverter.toFirestore(stats)
      expect(result.allTimeScore).toBe(0)
    })
  })

  describe("fromFirestore", () => {
    it("should map fields correctly", () => {
      const snapshot = {
        data: () => mockStats,
      }
      // @ts-ignore
      const result = playerStatsConverter.fromFirestore(snapshot, {})
      expect(result).toEqual(mockStats)
    })

    it("should apply default values for missing fields", () => {
      const snapshot = {
        data: () => ({
          id: "player-1",
          currentStreak: 0,
          games: 0,
          maxStreak: 0,
          wins: [0, 0, 0, 0, 0],
          // Missing hintsAvailable, hintsUsedCount, allTimeScore
        }),
      }

      // @ts-ignore
      const result = playerStatsConverter.fromFirestore(snapshot, {})
      expect(result.hintsAvailable).toBe(3) // Default
      expect(result.hintsUsedCount).toBe(0) // Default
      expect(result.allTimeScore).toBe(0) // Default
      expect(result.lastStreakMessageDate).toBeUndefined()
    })
  })
})

================
File: __tests__/hooks/useHintLogic.test.ts
================
import { renderHook, act } from "@testing-library/react-native"
import { useHintLogic } from "../../src/utils/hooks/useHintLogic"
import { useGameStore } from "../../src/state/gameStore"
import { defaultPlayerGame, defaultPlayerStats } from "../../src/models/default"

jest.mock("../../src/utils/analyticsService")
jest.mock("../../src/utils/hapticsService", () => ({
  hapticsService: { light: jest.fn(), medium: jest.fn() },
}))
jest.mock("react-native/Libraries/LayoutAnimation/LayoutAnimation", () => ({
  ...jest.requireActual(
    "react-native/Libraries/LayoutAnimation/LayoutAnimation"
  ),
  configureNext: jest.fn(),
}))

describe("Hook: useHintLogic (Comprehensive)", () => {
  const mockItem = {
    id: 1,
    title: "Test",
    description: "Desc",
    posterPath: "",
    releaseDate: "",
    metadata: {},
    hints: [
      { type: "director", label: "Director", value: "Nolan" },
      { type: "genre", label: "Genre", value: "Action" },
    ],
  }

  const resetStore = (
    difficulty: string = "LEVEL_2",
    hintsAvailable: number = 3
  ) => {
    useGameStore.setState(
      {
        playerGame: {
          ...defaultPlayerGame,
          triviaItem: mockItem,
          hintsUsed: {},
        },
        playerStats: { ...defaultPlayerStats, hintsAvailable },
        difficulty: difficulty as any,
        isInteractionsDisabled: false,
        loading: false,
      } as any,
      true
    )
  }

  describe("Strategy: HINTS_ONLY_REVEALED (Basic / LEVEL_1)", () => {
    beforeEach(() => resetStore("LEVEL_1"))

    it("should return empty label (handled by BasicHints component instead)", () => {
      const { result } = renderHook(() => useHintLogic())
      expect(result.current.hintLabelText).toBe("")

      // In the current implementation, HINTS_ONLY_REVEALED falls through to "available" status
      // This is acceptable because the UI for this mode doesn't use these statuses
      expect(result.current.hintStatuses["director"]).toBe("available")
    })
  })

  describe("Strategy: USER_SPEND (Easy / LEVEL_2)", () => {
    beforeEach(() => resetStore("LEVEL_2", 3))

    it("should allow toggling and show correct label", () => {
      const { result } = renderHook(() => useHintLogic())
      expect(result.current.hintLabelText).toContain("Need a Hint?")
      expect(result.current.isToggleDisabled).toBe(false)

      act(() => {
        result.current.handleToggleHintOptions()
      })
      expect(result.current.showHintOptions).toBe(true)
    })

    it("should disable hint toggle if no points and no used hints", () => {
      resetStore("LEVEL_2", 0)
      const { result } = renderHook(() => useHintLogic())
      expect(result.current.hintLabelText).toBe("")

      act(() => {
        result.current.handleToggleHintOptions()
      })
      expect(result.current.showHintOptions).toBe(false)
    })

    it("should mark purchased hints as 'used'", () => {
      useGameStore.setState((state) => ({
        playerGame: { ...state.playerGame, hintsUsed: { director: true } },
      }))
      const { result } = renderHook(() => useHintLogic())
      expect(result.current.hintStatuses["director"]).toBe("used")
      expect(result.current.hintStatuses["genre"]).toBe("available")
    })
  })

  describe("Strategy: IMPLICIT_FEEDBACK (Medium / LEVEL_3)", () => {
    beforeEach(() => resetStore("LEVEL_3"))

    it("should disable manual toggling but show info label", () => {
      const { result } = renderHook(() => useHintLogic())
      expect(result.current.isToggleDisabled).toBe(true)
      expect(result.current.hintLabelText).toBe(
        "Hints are revealed by successful guesses!"
      )
    })

    it("should show hints that are revealed by gameplay", () => {
      useGameStore.setState((state) => ({
        playerGame: { ...state.playerGame, hintsUsed: { genre: true } },
      }))
      const { result } = renderHook(() => useHintLogic())
      expect(result.current.hintStatuses["genre"]).toBe("used")
    })
  })

  describe("Strategy: NONE_DISABLED (Hard / LEVEL_4)", () => {
    beforeEach(() => resetStore("LEVEL_4"))

    it("should disable all hints", () => {
      const { result } = renderHook(() => useHintLogic())
      expect(result.current.hintStatuses["director"]).toBe("disabled")
      expect(result.current.hintLabelText).toBe("")
    })
  })

  describe("Game Over State", () => {
    it("should show 'Game Over' label", () => {
      resetStore("LEVEL_2")
      useGameStore.setState({ isInteractionsDisabled: true })
      const { result } = renderHook(() => useHintLogic())
      expect(result.current.hintLabelText).toBe("Game Over")
      expect(result.current.isToggleDisabled).toBe(true)
    })
  })
})

================
File: __tests__/services/gameService.test.ts
================
import { gameService } from "../../src/services/gameService"
import {
  doc,
  getDoc,
  setDoc,
  collection,
  getDocs,
  writeBatch,
} from "firebase/firestore"
import { defaultPlayerGame, defaultPlayerStats } from "../../src/models/default"
import Player from "../../src/models/player"

// Deep mock of Firestore
const mockBatch = {
  set: jest.fn(),
  commit: jest.fn(),
}

jest.mock("firebase/firestore", () => ({
  getFirestore: jest.fn(),
  doc: jest.fn(),
  collection: jest.fn(),
  getDoc: jest.fn(),
  setDoc: jest.fn(),
  getDocs: jest.fn(),
  query: jest.fn(),
  orderBy: jest.fn(),
  limit: jest.fn(),
  writeBatch: jest.fn(() => mockBatch),
}))

// Mock Converters
jest.mock("../../src/utils/firestore/converters/playerGame", () => ({
  playerGameConverter: {},
}))
jest.mock("../../src/utils/firestore/converters/player", () => ({
  playerConverter: {},
}))
jest.mock("../../src/utils/firestore/converters/playerStats", () => ({
  playerStatsConverter: {},
}))
jest.mock("../../src/utils/firestore/converters/gameHistoryEntry", () => ({
  gameHistoryEntryConverter: {},
}))

describe("Service: gameService", () => {
  const mockPlayerId = "player-123"
  const mockDateId = "2023-01-01"
  const mockDocRef = { withConverter: jest.fn().mockReturnValue("mock-ref") }

  beforeEach(() => {
    jest.clearAllMocks()
    ;(doc as jest.Mock).mockReturnValue(mockDocRef)
  })

  describe("ensurePlayerExists", () => {
    it("should return existing player if found", async () => {
      const existingPlayer = new Player(mockPlayerId, "Existing Name")
      ;(getDoc as jest.Mock).mockResolvedValue({
        exists: () => true,
        data: () => existingPlayer,
      })

      const result = await gameService.ensurePlayerExists(
        mockPlayerId,
        "New Name"
      )
      expect(result).toEqual(existingPlayer)
      expect(setDoc).not.toHaveBeenCalled()
    })

    it("should create new player if not found", async () => {
      ;(getDoc as jest.Mock).mockResolvedValue({ exists: () => false })

      const result = await gameService.ensurePlayerExists(
        mockPlayerId,
        "New Name"
      )

      expect(result.id).toBe(mockPlayerId)
      expect(result.name).toBe("New Name")
      expect(setDoc).toHaveBeenCalled()
    })
  })

  describe("fetchOrCreatePlayerGame", () => {
    it("should return an existing game if found", async () => {
      const mockExistingGame = {
        ...defaultPlayerGame,
        id: "existing-id",
        guessesMax: 3,
      }
      ;(getDoc as jest.Mock).mockResolvedValue({
        exists: () => true,
        data: () => mockExistingGame,
      })

      const result = await gameService.fetchOrCreatePlayerGame(
        mockPlayerId,
        mockDateId,
        {} as any,
        5
      )
      expect(result.id).toBe("existing-id")
      expect(result.guessesMax).toBe(5) // Should update guessesMax
    })

    it("should create a NEW game if document does not exist", async () => {
      ;(getDoc as jest.Mock).mockResolvedValue({ exists: () => false })

      await gameService.fetchOrCreatePlayerGame(
        mockPlayerId,
        mockDateId,
        { id: 99 } as any,
        5
      )

      expect(setDoc).toHaveBeenCalled()
      const savedData = (setDoc as jest.Mock).mock.calls[0][1]
      expect(savedData.playerID).toBe(mockPlayerId)
      expect(savedData.triviaItem.id).toBe(99)
    })
  })

  describe("fetchPlayerGameById", () => {
    it("should return null if game does not exist", async () => {
      ;(getDoc as jest.Mock).mockResolvedValue({ exists: () => false })
      const result = await gameService.fetchPlayerGameById("bad-id")
      expect(result).toBeNull()
    })

    it("should return data if game exists", async () => {
      ;(getDoc as jest.Mock).mockResolvedValue({
        exists: () => true,
        data: () => ({ id: "game-1" }),
      })
      const result = await gameService.fetchPlayerGameById("game-1")
      expect(result).toEqual({ id: "game-1" })
    })
  })

  describe("fetchOrCreatePlayerStats", () => {
    it("should return existing stats", async () => {
      ;(getDoc as jest.Mock).mockResolvedValue({
        exists: () => true,
        data: () => ({ ...defaultPlayerStats, games: 5 }),
      })
      const result = await gameService.fetchOrCreatePlayerStats(mockPlayerId)
      expect(result.games).toBe(5)
    })

    it("should create default stats if missing", async () => {
      ;(getDoc as jest.Mock).mockResolvedValue({ exists: () => false })
      const result = await gameService.fetchOrCreatePlayerStats(mockPlayerId)
      expect(result.hintsAvailable).toBe(3)
      expect(setDoc).toHaveBeenCalled()
    })
  })

  describe("savePlayerProgress", () => {
    it("should use batch to save game, stats, and history", async () => {
      const mockGame = { ...defaultPlayerGame, id: "g1", playerID: "p1" }
      const mockStats = { ...defaultPlayerStats }
      const mockHistory = { dateId: "2023-01-01" } as any

      await gameService.savePlayerProgress(mockGame, mockStats, mockHistory)

      expect(writeBatch).toHaveBeenCalled()
      // 3 sets: stats, game, history
      expect(mockBatch.set).toHaveBeenCalledTimes(3)
      expect(mockBatch.commit).toHaveBeenCalled()
    })

    it("should throw error if playerID is missing", async () => {
      const invalidGame = { ...defaultPlayerGame, playerID: "" }
      await expect(
        gameService.savePlayerProgress(invalidGame, defaultPlayerStats)
      ).rejects.toThrow("Player ID is missing")
    })
  })

  describe("fetchGameHistory", () => {
    it("should return mapped data", async () => {
      ;(collection as jest.Mock).mockReturnValue(mockDocRef)
      const mockData = [{ id: 1 }, { id: 2 }]
      ;(getDocs as jest.Mock).mockResolvedValue({
        docs: mockData.map((d) => ({ data: () => d })),
      })

      const result = await gameService.fetchGameHistory(mockPlayerId)
      expect(result).toHaveLength(2)
    })
  })
})

================
File: __tests__/services/gameServiceFactory.test.ts
================
import { getGameDataService } from "../../src/services/gameServiceFactory"
import { MovieDataService } from "../../src/services/movieDataService"
import { VideoGameService } from "../../src/services/videoGameService"

// Mocks
jest.mock("../../src/services/movieDataService")
jest.mock("../../src/services/videoGameService")

describe("Service: gameServiceFactory", () => {
  it("should return MovieDataService for 'movies' mode", () => {
    const service = getGameDataService("movies")
    expect(service).toBeInstanceOf(MovieDataService)
  })

  it("should return VideoGameService for 'videoGames' mode", () => {
    const service = getGameDataService("videoGames")
    expect(service).toBeInstanceOf(VideoGameService)
  })

  it("should throw an error for an unknown game mode", () => {
    // @ts-ignore - Testing invalid input
    expect(() => getGameDataService("invalid_mode")).toThrow(
      "No game data service found for mode: invalid_mode"
    )
  })
})

================
File: __tests__/services/movieDataService.test.ts
================
import { MovieDataService } from "../../src/services/movieDataService"

const mockMoviesData = [
  {
    id: 101,
    title: "Movie A",
    overview: "Plot A",
    poster_path: "/a.jpg",
    release_date: "2020-01-01",
    tagline: "Tag A",
    imdb_id: "tt101",
    popularity: 10,
    vote_average: 8.0,
    vote_count: 100,
    genres: [{ id: 1, name: "Action" }],
    director: { name: "Director A", imdb_id: "nm1" },
    actors: [
      { id: 1, name: "Actor 1", imdb_id: "nm10", order: 0 },
      { id: 2, name: "Actor 2", imdb_id: "nm20", order: 1 },
    ],
  },
  {
    // Sparse data movie to test fallbacks
    id: 102,
    title: "Movie B",
    release_date: "2021-01-01",
    overview: "Plot B",
    poster_path: "/b.jpg",
    genres: [],
    director: null,
    actors: [],
  },
]

jest.mock("../../data/popularMovies.json", () => mockMoviesData)

describe("Service: MovieDataService", () => {
  let service: MovieDataService

  beforeEach(() => {
    // Use isolateModules to ensure we get a fresh instance if needed,
    // though typically beforeEach new ServiceClass() is enough if the mock is stable.
    jest.isolateModules(() => {
      const {
        MovieDataService: ServiceClass,
      } = require("../../src/services/movieDataService")
      service = new ServiceClass()
    })
  })

  describe("getItemById", () => {
    it("should return a fully populated TriviaItem", async () => {
      const item = await service.getItemById(101)
      expect(item).toBeDefined()
      expect(item?.id).toBe(101)
      expect(item?.title).toBe("Movie A")

      const directorHint = item?.hints.find((h) => h.type === "director")
      expect(directorHint?.value).toBe("Director A")
    })

    it("should handle sparse data gracefully (missing director, actors, etc)", async () => {
      const item = await service.getItemById(102)

      expect(item).toBeDefined()
      expect(item?.title).toBe("Movie B")

      const directorHint = item?.hints.find((h) => h.type === "director")
      // Fallback for missing director name
      expect(directorHint?.value).toBe("N/A")

      const genreHint = item?.hints.find((h) => h.type === "genre")
      // Fallback for empty genres
      expect(genreHint?.value).toBe("N/A")
    })

    it("should return null if not found", async () => {
      const item = await service.getItemById(999)
      expect(item).toBeNull()
    })
  })

  describe("getDailyTriviaItemAndLists", () => {
    it("should return daily item based on day of year", async () => {
      jest.useFakeTimers()
      // Set a fixed date
      jest.setSystemTime(new Date("2023-01-01T12:00:00.000Z"))

      const result = await service.getDailyTriviaItemAndLists()

      // 2 movies in mock. Day 0 (Jan 1).
      // The logic is: dayOfYear % allMovies.length.
      // If Jan 1 is day 0 or day 1 depends on impl.
      // Usually day 1 - day 0 = 1. 1 % 2 = 1. Movie at index 1 is ID 102.

      // If implementation calculates index differently, we check result to see which ID.
      // Based on prior runs, it seemed to pick 102.
      expect(result.dailyItem).toBeDefined()

      expect(result.fullItems).toHaveLength(2)
      expect(result.basicItems).toHaveLength(2)

      jest.useRealTimers()
    })

    it("should throw error if data source is empty", async () => {
      jest.isolateModules(() => {
        jest.doMock("../../data/popularMovies.json", () => [])
        const {
          MovieDataService: EmptyService,
        } = require("../../src/services/movieDataService")
        const emptyService = new EmptyService()

        expect(emptyService.getDailyTriviaItemAndLists()).rejects.toThrow(
          "Local movie data is missing"
        )
      })
    })
  })
})

================
File: __tests__/services/videoGameService.test.ts
================
import { VideoGameService } from "../../src/services/videoGameService"

describe("Service: VideoGameService", () => {
  let service: VideoGameService

  beforeEach(() => {
    service = new VideoGameService()
  })

  it("should define the correct mode", () => {
    expect(service.mode).toBe("videoGames")
  })

  it("should throw error when calling getDailyTriviaItemAndLists", async () => {
    await expect(service.getDailyTriviaItemAndLists()).rejects.toThrow(
      "Video game mode is not available yet."
    )
  })

  it("should throw error when calling getItemById", async () => {
    await expect(service.getItemById(1)).rejects.toThrow(
      "VideoGameService.getItemById is not yet implemented."
    )
  })
})

================
File: __tests__/state/gameStore.test.ts
================
import { act, renderHook } from "@testing-library/react-native"
import { useGameStore } from "../../src/state/gameStore"
import { gameService } from "../../src/services/gameService"
import { getGameDataService } from "../../src/services/gameServiceFactory"
import AsyncStorage from "@react-native-async-storage/async-storage"
import { analyticsService } from "../../src/utils/analyticsService"
import { defaultPlayerGame, defaultPlayerStats } from "../../src/models/default"
import { ASYNC_STORAGE_KEYS } from "../../src/config/constants"

// --- MOCKS ---
jest.mock("../../src/services/gameService")
jest.mock("../../src/services/gameServiceFactory")
jest.mock("../../src/utils/analyticsService")
jest.mock("../../src/utils/scoreUtils", () => ({
  calculateScore: jest.fn().mockReturnValue(500),
}))

// Helper to reset store
const resetStore = () => {
  const initialState = useGameStore.getState()
  useGameStore.setState(initialState, true)
}

// Mock Data
const mockPlayer = { id: "player_1", name: "Test Player" }

// Correct Daily Item
const mockDailyItem = {
  id: 100,
  title: "Correct Movie",
  description: "A movie about testing.",
  posterPath: "/test.jpg",
  releaseDate: "2023-01-01",
  metadata: {},
  hints: [
    { type: "director", label: "Director", value: "Nolan" },
    { type: "genre", label: "Genre", value: "Sci-Fi" },
  ],
}

// Wrong Item (Totally different hints to avoid implicit matching)
const mockWrongItemFull = {
  id: 200,
  title: "Wrong Movie",
  description: "A different movie.",
  posterPath: "/wrong.jpg",
  releaseDate: "2020-01-01",
  metadata: {},
  hints: [
    { type: "director", label: "Director", value: "Spielberg" },
    { type: "genre", label: "Genre", value: "Adventure" },
  ],
}

const mockBasicItems = [
  {
    id: 100,
    title: "Correct Movie",
    releaseDate: "2023",
    posterPath: "/test.jpg",
  },
  {
    id: 200,
    title: "Wrong Movie",
    releaseDate: "2020",
    posterPath: "/wrong.jpg",
  },
]
const mockFullItems = [mockDailyItem, mockWrongItemFull]

const mockDataService = {
  getDailyTriviaItemAndLists: jest.fn().mockResolvedValue({
    dailyItem: mockDailyItem,
    fullItems: mockFullItems,
    basicItems: mockBasicItems,
  }),
  getItemById: jest.fn(),
  mode: "movies",
}

describe("GameStore: Comprehensive Logic", () => {
  beforeEach(() => {
    jest.clearAllMocks()
    resetStore()

    ;(getGameDataService as jest.Mock).mockReturnValue(mockDataService)

    ;(gameService.fetchOrCreatePlayerGame as jest.Mock).mockResolvedValue({
      ...defaultPlayerGame,
      id: "game_1",
      playerID: mockPlayer.id,
      triviaItem: mockDailyItem,
      guessesMax: 5,
    })

    ;(gameService.fetchOrCreatePlayerStats as jest.Mock).mockResolvedValue({
      ...defaultPlayerStats,
      id: mockPlayer.id,
      hintsAvailable: 5,
    })
  })

  describe("Initialization Flow", () => {
    it("should initialize correctly and set playing status", async () => {
      const { result } = renderHook(() => useGameStore())
      await act(async () => {
        await result.current.initializeGame(mockPlayer)
      })
      expect(result.current.loading).toBe(false)
      expect(result.current.gameStatus).toBe("playing")
      expect(result.current.playerGame.triviaItem.id).toBe(100)
    })

    it("should trigger onboarding tip if storage key is missing", async () => {
      ;(AsyncStorage.getItem as jest.Mock).mockImplementation((key) => {
        if (key === ASYNC_STORAGE_KEYS.TUTORIAL_GUESS_INPUT_SEEN)
          return Promise.resolve(null)
        return Promise.resolve("some-value")
      })

      const { result } = renderHook(() => useGameStore())
      await act(async () => {
        await result.current.initializeGame(mockPlayer)
      })
      expect(result.current.tutorialState.showGuessInputTip).toBe(true)
      expect(analyticsService.trackOnboardingStarted).toHaveBeenCalled()
    })
  })

  describe("Gameplay: Guesses & Scoring", () => {
    beforeEach(async () => {
      const { result } = renderHook(() => useGameStore())
      await act(async () => {
        await result.current.initializeGame(mockPlayer)
      })
    })

    it("should process a wrong guess correctly", async () => {
      const { result } = renderHook(() => useGameStore())
      const wrongItem = mockBasicItems[1] // ID 200

      await act(async () => {
        result.current.makeGuess(wrongItem)
      })

      expect(result.current.playerGame.guesses).toHaveLength(1)
      expect(result.current.playerGame.guesses[0].itemId).toBe(200)
      expect(result.current.playerGame.correctAnswer).toBe(false)
      expect(result.current.lastGuessResult?.feedback).toBe(
        "Not quite! Try again."
      )
      expect(analyticsService.trackGuessMade).toHaveBeenCalledWith(
        1,
        false,
        200,
        "Wrong Movie"
      )
    })

    it("should process a correct guess and trigger win flow", async () => {
      const { result } = renderHook(() => useGameStore())
      const correctItem = mockBasicItems[0] // ID 100

      await act(async () => {
        result.current.makeGuess(correctItem)
      })

      expect(result.current.playerGame.correctAnswer).toBe(true)
      expect(result.current.showConfetti).toBe(true)
      expect(gameService.savePlayerProgress).toHaveBeenCalled()
      expect(result.current.isInteractionsDisabled).toBe(true)
      expect(result.current.playerStats.allTimeScore).toBe(500)
      expect(result.current.playerStats.currentStreak).toBe(1)
    })
  })

  describe("Gameplay: Hints", () => {
    it("should decrement hintsAvailable when a hint is purchased (USER_SPEND mode)", async () => {
      const { result } = renderHook(() => useGameStore())
      await act(async () => {
        await result.current.initializeGame(mockPlayer)
      })
      act(() => {
        result.current.setDifficulty("LEVEL_2")
      })
      expect(result.current.playerStats.hintsAvailable).toBe(5)
      act(() => {
        result.current.useHint("director")
      })
      expect(result.current.playerGame.hintsUsed?.director).toBe(true)
      expect(result.current.playerStats.hintsAvailable).toBe(4)
    })

    it("should generate implicit hints in Medium mode", async () => {
      const { result } = renderHook(() => useGameStore())
      await act(async () => {
        await result.current.initializeGame(mockPlayer)
      })
      act(() => {
        result.current.setDifficulty("LEVEL_3")
      })

      // Setup a partial match scenario
      const wrongItemWithSharedDirector = {
        ...mockDailyItem,
        id: 300,
        title: "Shared Director Movie",
      }

      act(() => {
        useGameStore.setState((state) => ({
          fullItems: [...state.fullItems, wrongItemWithSharedDirector],
        }))
      })

      const guessItem = {
        id: 300,
        title: "Shared Director Movie",
        releaseDate: "2023",
        posterPath: "",
      }

      await act(async () => {
        result.current.makeGuess(guessItem)
      })
      expect(result.current.lastGuessResult?.feedback).toContain("right track")
      expect(result.current.playerGame.hintsUsed?.director).toBe(true)
    })
  })
})

================
File: __tests__/utils/analyticsService.test.ts
================
import { logEvent, setUserId, setUserProperties } from "firebase/analytics"

jest.mock("../../src/config/firebase", () => ({
  analytics: {},
}))

jest.mock("firebase/analytics", () => ({
  getAnalytics: jest.fn(),
  logEvent: jest.fn(),
  setUserId: jest.fn(),
  setUserProperties: jest.fn(),
}))

import { analyticsService } from "../../src/utils/analyticsService"

describe("Utils: analyticsService", () => {
  const mockConsoleLog = jest.spyOn(console, "log").mockImplementation(() => {})
  const mockConsoleError = jest
    .spyOn(console, "error")
    .mockImplementation(() => {})

  beforeEach(() => {
    jest.clearAllMocks()
  })

  afterAll(() => {
    jest.restoreAllMocks()
  })

  describe("Safety Checks", () => {
    it("should fail gracefully if analytics is not initialized", async () => {
      jest.isolateModules(() => {
        jest.doMock("../../src/config/firebase", () => ({
          __esModule: true,
          analytics: null,
        }))

        const mockLogEvent = jest.fn()
        jest.doMock("firebase/analytics", () => ({
          getAnalytics: jest.fn(),
          logEvent: mockLogEvent,
        }))

        const {
          analyticsService: freshService,
        } = require("../../src/utils/analyticsService")

        freshService.trackGameStart(1, "Test Movie")

        expect(mockLogEvent).not.toHaveBeenCalled()
      })
    })

    it("should catch and log errors from Firebase", async () => {
      jest.resetModules()

      jest.doMock("../../src/config/firebase", () => ({ analytics: {} }))

      const mockLogEvent = jest
        .fn()
        .mockRejectedValue(new Error("Firebase Error"))
      jest.doMock("firebase/analytics", () => ({
        logEvent: mockLogEvent,
        getAnalytics: jest.fn(),
        setUserId: jest.fn(),
        setUserProperties: jest.fn(),
      }))

      const {
        analyticsService: freshService,
      } = require("../../src/utils/analyticsService")

      await freshService.trackGameStart(1, "Test Movie")

      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringContaining("Error logging event"),
        expect.any(Error)
      )
    })
  })

  describe("User Identification", () => {
    it("should set user ID", () => {
      analyticsService.identifyUser("user-123")
      expect(setUserId).toHaveBeenCalledWith(expect.anything(), "user-123")
    })

    it("should set user properties if provided", () => {
      analyticsService.identifyUser("user-123", { method: "google" })
      expect(setUserProperties).toHaveBeenCalledWith(expect.anything(), {
        method: "google",
      })
    })
  })

  describe("Event Tracking", () => {
    it("trackOnboardingStarted", async () => {
      await analyticsService.trackOnboardingStarted()
      expect(logEvent).toHaveBeenCalledWith(
        expect.anything(),
        "onboarding_started",
        undefined
      )
    })

    it("trackGameStart", async () => {
      await analyticsService.trackGameStart(101, "Inception")
      expect(logEvent).toHaveBeenCalledWith(expect.anything(), "game_start", {
        movie_id: 101,
        movie_title: "Inception",
      })
    })

    it("trackGameWin", async () => {
      await analyticsService.trackGameWin(3, 1)
      expect(logEvent).toHaveBeenCalledWith(expect.anything(), "game_win", {
        guesses_taken: 3,
        hints_used_count: 1,
      })
    })

    it("trackGameLose", async () => {
      await analyticsService.trackGameLose(2)
      expect(logEvent).toHaveBeenCalledWith(expect.anything(), "game_lose", {
        hints_used_count: 2,
      })
    })

    it("trackGuessMade", async () => {
      await analyticsService.trackGuessMade(1, true, 500, "Movie A")
      expect(logEvent).toHaveBeenCalledWith(expect.anything(), "guess_made", {
        guess_number: 1,
        is_correct: true,
        guessed_movie_id: 500,
        guessed_movie_title: "Movie A",
      })
    })

    it("trackHintUsed", async () => {
      await analyticsService.trackHintUsed("director", 2, 1)
      expect(logEvent).toHaveBeenCalledWith(expect.anything(), "hint_used", {
        hint_type: "director",
        guess_number_before_hint: 2,
        hints_remaining: 1,
      })
    })

    it("trackShareResults", async () => {
      await analyticsService.trackShareResults("win")
      expect(logEvent).toHaveBeenCalledWith(
        expect.anything(),
        "share_results_tapped",
        {
          game_outcome: "win",
        }
      )
    })

    it("trackGoogleSignInFailure sanitizes error length", async () => {
      const longError = "a".repeat(200)
      await analyticsService.trackGoogleSignInFailure(longError)

      expect(logEvent).toHaveBeenCalledWith(
        expect.anything(),
        "google_signin_failure",
        {
          error_message: expect.stringMatching(/^a{100}$/), // Should be truncated to 100 chars
        }
      )
    })

    it("trackErrorBoundary sanitizes error length", async () => {
      const longError = "e".repeat(200)
      await analyticsService.trackErrorBoundary(longError)

      expect(logEvent).toHaveBeenCalledWith(
        expect.anything(),
        "error_boundary_triggered",
        {
          error_message: expect.stringMatching(/^e{100}$/),
        }
      )
    })
  })
})

================
File: __tests__/utils/hapticsService.test.ts
================
import { Platform } from "react-native"
import * as Haptics from "expo-haptics"
import { hapticsService } from "../../src/utils/hapticsService"

jest.mock("expo-haptics")

describe("Utils: hapticsService", () => {
  const originalPlatform = Platform.OS

  afterEach(() => {
    Object.defineProperty(Platform, "OS", { get: () => originalPlatform })
    jest.clearAllMocks()
  })

  describe("Native Platform (iOS/Android)", () => {
    beforeEach(() => {
      Object.defineProperty(Platform, "OS", { get: () => "ios" })
    })

    it("should call impactAsync for light/medium/heavy", () => {
      hapticsService.light()
      expect(Haptics.impactAsync).toHaveBeenCalledWith(
        Haptics.ImpactFeedbackStyle.Light
      )

      hapticsService.medium()
      expect(Haptics.impactAsync).toHaveBeenCalledWith(
        Haptics.ImpactFeedbackStyle.Medium
      )

      hapticsService.heavy()
      expect(Haptics.impactAsync).toHaveBeenCalledWith(
        Haptics.ImpactFeedbackStyle.Heavy
      )
    })

    it("should call notificationAsync for success/warning/error", () => {
      hapticsService.success()
      expect(Haptics.notificationAsync).toHaveBeenCalledWith(
        Haptics.NotificationFeedbackType.Success
      )

      hapticsService.warning()
      expect(Haptics.notificationAsync).toHaveBeenCalledWith(
        Haptics.NotificationFeedbackType.Warning
      )

      hapticsService.error()
      expect(Haptics.notificationAsync).toHaveBeenCalledWith(
        Haptics.NotificationFeedbackType.Error
      )
    })
  })

  describe("Web Platform", () => {
    beforeEach(() => {
      Object.defineProperty(Platform, "OS", { get: () => "web" })
    })

    it("should NOT call Haptics methods on web", () => {
      hapticsService.light()
      hapticsService.success()

      expect(Haptics.impactAsync).not.toHaveBeenCalled()
      expect(Haptics.notificationAsync).not.toHaveBeenCalled()
    })
  })
})

================
File: __tests__/utils/shareUtils.test.ts
================
import {
  generateShareMessage,
  shareGameResult,
} from "../../src/utils/shareUtils"
import { Share } from "react-native"
import { analyticsService } from "../../src/utils/analyticsService"
import { hapticsService } from "../../src/utils/hapticsService"
import { defaultPlayerGame } from "../../src/models/default"
import { useGameStore } from "../../src/state/gameStore"
import { calculateScore } from "../../src/utils/scoreUtils"
import { PlayerGame, Guess } from "../../src/models/game"

// Mocks
jest.mock("react-native/Libraries/Share/Share", () => ({
  share: jest.fn(),
}))
jest.mock("../../src/utils/analyticsService")
jest.mock("../../src/utils/hapticsService")
jest.mock("../../src/utils/scoreUtils")
jest.mock("../../src/state/gameStore", () => ({
  useGameStore: {
    getState: jest.fn(),
  },
}))

describe("Utils: shareUtils", () => {
  const mockDate = new Date("2023-01-01T12:00:00.000Z")

  // Correctly typed mock guesses
  const mockGuesses: Guess[] = [{ itemId: 1 }, { itemId: 2 }]

  const baseGame: PlayerGame = {
    ...defaultPlayerGame,
    startDate: mockDate,
    guessesMax: 5,
    guesses: mockGuesses,
  }

  beforeEach(() => {
    jest.clearAllMocks()
    ;(calculateScore as jest.Mock).mockReturnValue(1000)
    ;(useGameStore.getState as jest.Mock).mockReturnValue({
      gameMode: "movies",
    })
  })

  describe("generateShareMessage", () => {
    it("should generate a correct message for a Win", () => {
      const game = { ...baseGame, correctAnswer: true }
      const msg = generateShareMessage(game)

      expect(msg).toContain("Talkie Trivia ")
      expect(msg).toContain("2023")
      expect(msg).toContain(" Guessed in 2/5 tries!")
      // 2 guesses total. First one wrong (red), last one correct (green).
      expect(msg).toContain("")
      expect(msg).toContain("Score:  1000")
    })

    it("should generate a correct message for a Loss", () => {
      const lossGuesses: Guess[] = [
        { itemId: 1 },
        { itemId: 2 },
        { itemId: 3 },
        { itemId: 4 },
        { itemId: 5 },
      ]
      const game = {
        ...baseGame,
        correctAnswer: false,
        gaveUp: false,
        guessesMax: 5,
        guesses: lossGuesses,
      }
      const msg = generateShareMessage(game)

      expect(msg).toContain(" Didn't guess the item!")
      expect(msg).toContain("")
    })

    it("should generate a correct message for Giving Up", () => {
      const giveUpGuesses: Guess[] = [{ itemId: 1 }]
      const game = {
        ...baseGame,
        correctAnswer: false,
        gaveUp: true,
        guesses: giveUpGuesses,
      }
      const msg = generateShareMessage(game)

      expect(msg).toContain(" Gave up after 1 guess.")
      expect(msg).toContain("")
    })

    it("should adapt title based on Game Mode", () => {
      ;(useGameStore.getState as jest.Mock).mockReturnValue({
        gameMode: "videoGames",
      })
      const msg = generateShareMessage({ ...baseGame, correctAnswer: true })
      expect(msg).toContain("Talkie Trivia ")
    })
  })

  describe("shareGameResult", () => {
    it("should call Share.share with correct parameters", async () => {
      const game = { ...baseGame, correctAnswer: true }
      await shareGameResult(game)

      expect(hapticsService.medium).toHaveBeenCalled()
      expect(analyticsService.trackShareResults).toHaveBeenCalledWith("win")
      expect(Share.share).toHaveBeenCalledWith(
        expect.objectContaining({
          message: expect.stringContaining("Talkie Trivia"),
        }),
        expect.anything()
      )
    })

    it("should handle Share cancellation (AbortError) gracefully", async () => {
      const error = new Error("Share Canceled")
      error.name = "AbortError"
      ;(Share.share as jest.Mock).mockRejectedValue(error)

      await expect(shareGameResult(baseGame)).resolves.toBeUndefined()
    })

    it("should re-throw other errors", async () => {
      const error = new Error("Random Failure")
      ;(Share.share as jest.Mock).mockRejectedValue(error)

      await expect(shareGameResult(baseGame)).rejects.toThrow("Random Failure")
    })
  })
})

================
File: __tests__/actors.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  fireEvent,
  screen,
  RenderOptions,
  within,
} from "@testing-library/react-native"
import Actors from "../src/components/actors"
import { API_CONFIG } from "../src/config/constants"
import { ThemeProvider } from "../src/contexts/themeContext"

// Custom Render Helper with ThemeProvider
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

type Actor = {
  id: number | string
  name: string
  profile_path: string | null
  imdb_id?: string
}

// Mock Data
const mockActors: Actor[] = [
  { id: 1, name: "Tom Hanks", profile_path: "/tom_hanks.jpg" },
  { id: 2, name: "Meryl Streep", profile_path: "/meryl_streep.jpg" },
  { id: 3, name: "Denzel Washington", profile_path: "/denzel_washington.jpg" },
  { id: 4, name: "Cher", profile_path: "/cher.jpg" },
  { id: 5, name: "Actor Without Image", profile_path: null },
]

// Test Suite
describe("Actors Component", () => {
  const onActorPressMock = jest.fn()

  beforeEach(() => {
    onActorPressMock.mockClear()
  })

  describe("Rendering Logic", () => {
    it("should render nothing if the actors prop is null or empty", () => {
      const { rerender } = renderWithTheme(
        <Actors actors={[]} onActorPress={onActorPressMock} />
      )
      expect(screen.queryByTestId(/actor-pressable-/)).toBeNull()

      rerender(
        <ThemeProvider>
          <Actors actors={null as any} onActorPress={onActorPressMock} />
        </ThemeProvider>
      )
      expect(screen.queryByTestId(/actor-pressable-/)).toBeNull()
    })

    it("should render up to the default maximum of 3 actors", () => {
      renderWithTheme(
        <Actors actors={mockActors} onActorPress={onActorPressMock} />
      )
      const actorElements = screen.getAllByTestId(/actor-pressable-/)
      expect(actorElements).toHaveLength(3)
    })

    it("should respect the `maxDisplay` prop when provided", () => {
      renderWithTheme(
        <Actors
          actors={mockActors}
          maxDisplay={2}
          onActorPress={onActorPressMock}
        />
      )
      const actorElements = screen.getAllByTestId(/actor-pressable-/)
      expect(actorElements).toHaveLength(2)
    })

    it("should render fewer actors if the array length is less than `maxDisplay`", () => {
      const fewActors = mockActors.slice(0, 1)
      renderWithTheme(
        <Actors
          actors={fewActors}
          maxDisplay={3}
          onActorPress={onActorPressMock}
        />
      )
      const actorElements = screen.getAllByTestId(/actor-pressable-/)
      expect(actorElements).toHaveLength(1)
    })

    it("should use the correct image URI when profile_path is available", () => {
      renderWithTheme(
        <Actors actors={[mockActors[0]]} onActorPress={onActorPressMock} />
      )
      const image = screen.getByTestId("mock-expo-image")
      expect(image.props["data-source"]).toBe(
        `${API_CONFIG.TMDB_IMAGE_BASE_URL_W185}${mockActors[0].profile_path}`
      )
    })

    it("should use the default fallback image when profile_path is null", () => {
      renderWithTheme(
        <Actors actors={[mockActors[4]]} onActorPress={onActorPressMock} />
      )
      const image = screen.getByTestId("mock-expo-image")
      expect(image.props.source).toBe(1)
    })

    it("should correctly split and display actor names", () => {
      renderWithTheme(
        <Actors
          actors={mockActors}
          maxDisplay={4}
          onActorPress={onActorPressMock}
        />
      )

      const tomHanksCard = screen.getByTestId("actor-pressable-1")
      // The text is nested, so we check for the combined text content.
      expect(within(tomHanksCard).getByText(/Tom\s*Hanks/)).toBeTruthy()

      const cherCard = screen.getByTestId("actor-pressable-4")
      expect(within(cherCard).getByText("Cher")).toBeTruthy()
    })
  })

  describe("Interaction", () => {
    it("should call onActorPress with the correct actor object when pressed", () => {
      renderWithTheme(
        <Actors
          actors={mockActors}
          maxDisplay={3}
          onActorPress={onActorPressMock}
        />
      )
      const actorToPress = screen.getByTestId("actor-pressable-2") // Meryl Streep
      fireEvent.press(actorToPress)
      expect(onActorPressMock).toHaveBeenCalledWith(mockActors[1])
    })
  })

  describe("Accessibility", () => {
    it("should have the correct accessibility label and role", () => {
      renderWithTheme(
        <Actors actors={[mockActors[0]]} onActorPress={onActorPressMock} />
      )
      const pressable = screen.getByTestId("actor-pressable-1")
      expect(pressable.props.accessibilityLabel).toBe(
        "Actor: Tom Hanks. View details"
      )
      expect(pressable.props.role).toBe("button")
    })
  })
})

================
File: __tests__/app_layout.test.tsx
================
import React from "react"
import { render, screen, waitFor } from "@testing-library/react-native"
import { useFonts } from "expo-font"

// Fixed mock for expo-font
jest.mock("expo-font", () => ({
  useFonts: jest.fn(),
}))

jest.mock("expo-router", () => ({
  Tabs: Object.assign((props: any) => <>{props.children}</>, {
    Screen: ({ name }: { name: string }) => {
      const { View } = require("react-native")
      return <View testID={`tab-${name}`} />
    },
  }),
}))

jest.mock("../src/contexts/themeContext", () => ({
  useTheme: () => ({
    colors: {
      primary: "blue",
      textSecondary: "gray",
      surface: "white",
      background: "white",
      border: "black",
    },
  }),
}))

import TabLayout from "../src/app/(tabs)/_layout"

describe("App: TabsLayout", () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  it("should show loading indicator if fonts are not loaded", () => {
    ;(useFonts as jest.Mock).mockReturnValue([false, null])
    render(<TabLayout />)
    expect(screen.getByTestId("loading-indicator-container")).toBeTruthy()
  })

  it("should show error message if font loading fails", async () => {
    const errorMsg = "Font load failed"
    const error = new Error(errorMsg)
    // Ensure fontsLoaded is TRUE so it bypasses loading check
    ;(useFonts as jest.Mock).mockReturnValue([true, error])

    render(<TabLayout />)

    await waitFor(() => {
      expect(screen.getByText(errorMsg)).toBeTruthy()
    })
  })

  it("should render tabs when fonts are loaded", () => {
    ;(useFonts as jest.Mock).mockReturnValue([true, null])
    render(<TabLayout />)
    expect(screen.toJSON()).toBeDefined()
  })
})

================
File: __tests__/button.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  fireEvent,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import { Button } from "../src/components/ui/button"
import { lightColors } from "../src/styles/themes"

// Custom Render Helper
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("UI Component: Button", () => {
  const mockOnPress = jest.fn()

  beforeEach(() => {
    mockOnPress.mockClear()
  })

  describe("Rendering and Variants", () => {
    it("should render the title correctly", () => {
      renderWithTheme(<Button title="Click Me" onPress={mockOnPress} />)
      expect(screen.getByText("Click Me")).toBeTruthy()
    })

    it("should apply primary variant styles by default", () => {
      renderWithTheme(<Button title="Primary" onPress={mockOnPress} />)
      const button = screen.getByRole("button")

      // Check background color for primary
      expect(button.props.style).toEqual(
        expect.arrayContaining([
          expect.objectContaining({ backgroundColor: lightColors.primary }),
        ])
      )
    })

    it("should apply secondary variant styles", () => {
      renderWithTheme(
        <Button title="Secondary" variant="secondary" onPress={mockOnPress} />
      )
      const button = screen.getByRole("button")
      const text = screen.getByText("Secondary")

      // Secondary usually has transparent bg and primary border/text
      expect(button.props.style).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            backgroundColor: "transparent",
            borderColor: lightColors.primary,
          }),
        ])
      )
      expect(text.props.style).toEqual(
        expect.arrayContaining([
          expect.objectContaining({ color: lightColors.primary }),
        ])
      )
    })
  })

  describe("Interaction and State", () => {
    it("should call onPress when clicked", () => {
      renderWithTheme(<Button title="Press Me" onPress={mockOnPress} />)
      fireEvent.press(screen.getByRole("button"))
      expect(mockOnPress).toHaveBeenCalledTimes(1)
    })

    it("should not call onPress when disabled", () => {
      renderWithTheme(
        <Button title="Disabled" disabled={true} onPress={mockOnPress} />
      )
      fireEvent.press(screen.getByRole("button"))
      expect(mockOnPress).not.toHaveBeenCalled()
    })

    it("should show loading indicator and hide text when isLoading is true", () => {
      renderWithTheme(
        <Button title="Loading" isLoading={true} onPress={mockOnPress} />
      )

      // Spinner should be present
      expect(screen.getByTestId("activity-indicator")).toBeTruthy()

      // Text should NOT be present
      expect(screen.queryByText("Loading")).toBeNull()
    })

    it("should not trigger onPress when isLoading is true", () => {
      renderWithTheme(
        <Button title="Loading" isLoading={true} onPress={mockOnPress} />
      )
      fireEvent.press(screen.getByRole("button"))
      expect(mockOnPress).not.toHaveBeenCalled()
    })
  })
})

================
File: __tests__/card.test.tsx
================
import React, { ReactElement } from "react"
import { Text } from "react-native"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import { Card } from "../src/components/ui/card"
import { lightColors } from "../src/styles/themes"

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("UI Component: Card", () => {
  it("should render children content", () => {
    renderWithTheme(
      <Card>
        <Text>Card Content</Text>
      </Card>
    )
    expect(screen.getByText("Card Content")).toBeTruthy()
  })

  it("should apply basic card styles from theme", () => {
    renderWithTheme(
      <Card testID="card-container">
        <Text>Styled Card</Text>
      </Card>
    )

    const cardView = screen.getByTestId("card-container")

    // Card styles are an array [cardStyle, userStyle]
    // We check that the array contains the theme-based object
    expect(cardView.props.style).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          backgroundColor: lightColors.surface,
          // borderRadius is calculated using responsive.scale, so we just check it exists
          borderRadius: expect.any(Number),
        }),
      ])
    )
  })

  it("should accept custom styles", () => {
    renderWithTheme(
      <Card style={{ marginTop: 20 }} testID="card-container">
        <Text>Margin Card</Text>
      </Card>
    )
    const cardView = screen.getByTestId("card-container")

    expect(cardView.props.style).toEqual(
      expect.arrayContaining([expect.objectContaining({ marginTop: 20 })])
    )
  })
})

================
File: __tests__/clues.test.tsx
================
import React, { ReactElement } from "react";
import {
  render,
  screen,
  fireEvent,
  act,
  RenderOptions,
} from "@testing-library/react-native";
import { ThemeProvider } from "../src/contexts/themeContext";
import CluesContainer from "../src/components/clues";
import { GameState, useGameStore } from "../src/state/gameStore";
import { hapticsService } from "../src/utils/hapticsService";
import { ScrollView } from "react-native";
import { defaultPlayerGame, defaultTriviaItem } from "../src/models/default";
import { PlayerGame } from "../src/models/game";
import { DEFAULT_DIFFICULTY } from "../src/config/difficulty";

jest.mock("../src/state/gameStore");
jest.mock("../src/utils/hapticsService");

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options);
};

const mockSummary =
  "A young boy discovers a magical lamp. A powerful genie grants him three wishes, changing his life forever.";
const summaryChunks = [
  "A young boy discovers",
  "a magical lamp. A",
  "powerful genie grants him",
  "three wishes, changing his",
  "life forever.",
];
const fullSummaryText = summaryChunks.join(" ");

const defaultMockState: Partial<GameState> = {
  loading: false,
  isInteractionsDisabled: false,
  difficulty: DEFAULT_DIFFICULTY,
  playerGame: {
    ...defaultPlayerGame,
    triviaItem: {
      ...defaultTriviaItem,
      description: mockSummary,
    },
  },
};

type MockStateOverrides = Partial<Omit<GameState, "playerGame">> & {
  playerGame?: Partial<PlayerGame>;
};

describe("CluesContainer Component", () => {
  let scrollToEndSpy: jest.SpyInstance;

  beforeEach(() => {
    jest.useFakeTimers();
    (useGameStore as unknown as jest.Mock).mockClear();
    (hapticsService.light as jest.Mock).mockClear();

    scrollToEndSpy = jest
      .spyOn(ScrollView.prototype, "scrollToEnd")
      .mockImplementation(() => {});
  });

  afterEach(() => {
    jest.useRealTimers();
    scrollToEndSpy.mockRestore();
  });

  const setMockStoreState = (overrides: MockStateOverrides = {}) => {
    const newState = {
      ...defaultMockState,
      ...overrides,
      playerGame: {
        ...defaultMockState.playerGame!,
        ...(overrides.playerGame || {}),
      },
    };

    (useGameStore as unknown as jest.Mock).mockImplementation(
      (selector: (s: GameState) => any) => selector(newState as GameState)
    );
  };

  describe("Rendering States", () => {
    it("should render the skeleton component when loading", () => {
      setMockStoreState({ loading: true });
      renderWithTheme(<CluesContainer />);
      expect(screen.getByTestId("clues-skeleton")).toBeTruthy();
      expect(screen.queryByText(/words revealed/)).toBeNull();
    });

    it("should render the first clue chunk and correct word count on initial load", () => {
      setMockStoreState();
      renderWithTheme(<CluesContainer />);

      act(() => {
        jest.runAllTimers();
      });
      
      expect(screen.getByText(summaryChunks[0])).toBeTruthy();

      const revealedWords = summaryChunks[0].split(" ").length;
      const totalWords = mockSummary.trim().split(/\s+/).length;
      expect(
        screen.getByText(`${revealedWords}/${totalWords} words revealed`)
      ).toBeTruthy();
    });

    it("should render the full summary if the game is already over on load", () => {
      setMockStoreState({
        isInteractionsDisabled: true,
        playerGame: { guesses: [{ itemId: 123 }] },
      });
      renderWithTheme(<CluesContainer />);
      expect(screen.getByText(fullSummaryText)).toBeTruthy();
    });
  });

  describe("Game Progression", () => {
    it("should reveal the next clue chunk after a guess", () => {
      setMockStoreState({ playerGame: { guesses: [] } });
      const { rerender } = renderWithTheme(<CluesContainer />);

      act(() => jest.runAllTimers());
      expect(screen.getByText(summaryChunks[0])).toBeTruthy();

      (hapticsService.light as jest.Mock).mockClear();

      act(() => {
        setMockStoreState({ playerGame: { guesses: [{ itemId: 1 }] } });
        rerender(
          <ThemeProvider>
            <CluesContainer />
          </ThemeProvider>
        );
      });

      act(() => jest.runAllTimers());

      const expectedText = `${summaryChunks[0]} ${summaryChunks[1]}`;
      expect(screen.getByText(expectedText)).toBeTruthy();

      expect(hapticsService.light).toHaveBeenCalledTimes(1);
      expect(scrollToEndSpy).toHaveBeenCalledWith({ animated: true });
    });
  });

  describe("Interaction", () => {
    it("should call haptics on press", () => {
      setMockStoreState();
      renderWithTheme(<CluesContainer />);

      act(() => jest.runAllTimers());

      expect(screen.getByText(summaryChunks[0])).toBeTruthy();
      (hapticsService.light as jest.Mock).mockClear();

      const pressableArea = screen.getByLabelText(
        "Tap to reveal the full clue immediately"
      );
      fireEvent.press(pressableArea);

      expect(hapticsService.light).toHaveBeenCalledTimes(1);
    });

    it("should be non-interactive when the game is over", () => {
      setMockStoreState({ isInteractionsDisabled: true });
      renderWithTheme(<CluesContainer />);
      (hapticsService.light as jest.Mock).mockClear();

      expect(
        screen.queryByLabelText("Tap to reveal the full clue immediately")
      ).toBeNull();

      fireEvent.press(screen.getByText(fullSummaryText));
      expect(hapticsService.light).not.toHaveBeenCalled();
    });
  });
});

================
File: __tests__/confettiCelebration.test.tsx
================
import React from "react"
import { render, screen, act } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import ConfettiCelebration from "../src/components/confettiCelebration"

// --- Mocking the external library ---

// This mock function will allow us to check if the `start()` method was called.
const mockStart = jest.fn()

jest.mock("react-native-confetti-cannon", () => {
  const React = require("react")
  const { forwardRef, useImperativeHandle } = React
  const { View } = require("react-native")

  const MockConfettiCannon = forwardRef(
    (
      {
        onAnimationEnd,
        ...props
      }: { onAnimationEnd?: () => void; [key: string]: any },
      ref: any
    ) => {
      useImperativeHandle(ref, () => ({
        start: mockStart,
      }))

      return (
        <View
          testID="confetti-cannon"
          onAnimationEnd={onAnimationEnd}
          {...props}
        />
      )
    }
  )
  MockConfettiCannon.displayName = "MockConfettiCannon"
  return MockConfettiCannon
})

// --- Test Suite ---

describe("ConfettiCelebration Component", () => {
  const mockOnConfettiStop = jest.fn()

  beforeEach(() => {
    // Clear mocks before each test to ensure a clean state
    mockStart.mockClear()
    mockOnConfettiStop.mockClear()
  })

  it("should not render when startConfetti is false", () => {
    render(
      <ThemeProvider>
        <ConfettiCelebration startConfetti={false} />
      </ThemeProvider>
    )
    expect(screen.queryByTestId("confetti-cannon")).toBeNull()
  })

  it("should render and call the start method when startConfetti is true", () => {
    render(
      <ThemeProvider>
        <ConfettiCelebration startConfetti={true} />
      </ThemeProvider>
    )
    expect(screen.getByTestId("confetti-cannon")).toBeTruthy()
    expect(mockStart).toHaveBeenCalledTimes(1)
  })

  it("should call onConfettiStop when the onAnimationEnd prop is triggered", () => {
    render(
      <ThemeProvider>
        <ConfettiCelebration
          startConfetti={true}
          onConfettiStop={mockOnConfettiStop}
        />
      </ThemeProvider>
    )

    const confettiCannon = screen.getByTestId("confetti-cannon")
    act(() => {
      confettiCannon.props.onAnimationEnd()
    })
    expect(mockOnConfettiStop).toHaveBeenCalledTimes(1)
  })

  it("should not call start() again on re-render if startConfetti is already true", () => {
    const { rerender } = render(
      <ThemeProvider>
        <ConfettiCelebration startConfetti={true} />
      </ThemeProvider>
    )
    expect(mockStart).toHaveBeenCalledTimes(1)

    rerender(
      <ThemeProvider>
        <ConfettiCelebration startConfetti={true} />
      </ThemeProvider>
    )
    expect(mockStart).toHaveBeenCalledTimes(1)
  })
})

================
File: __tests__/confirmationModal.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  fireEvent,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import ConfirmationModal from "../src/components/confirmationModal"
import { hapticsService } from "../src/utils/hapticsService"

// --- Mocking Dependencies ---

// We mock the haptics service to verify that the correct feedback is triggered.
jest.mock("../src/utils/hapticsService", () => ({
  hapticsService: {
    light: jest.fn(),
    heavy: jest.fn(),
  },
}))

// --- Test Setup ---

// Custom render helper with ThemeProvider for consistency with other tests.
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

// --- Test Suite ---

describe("ConfirmationModal Component", () => {
  // Create mock functions for the callbacks.
  const onConfirmMock = jest.fn()
  const onCancelMock = jest.fn()

  // Define default props to use in tests.
  const defaultProps = {
    isVisible: true,
    title: "Confirm Action",
    message: "Are you sure you want to proceed?",
    confirmText: "Yes, Confirm",
    cancelText: "No, Cancel",
    onConfirm: onConfirmMock,
    onCancel: onCancelMock,
  }

  // Before each test, clear the mock call history to ensure test isolation.
  beforeEach(() => {
    jest.clearAllMocks()
  })

  // --- Test Cases ---

  describe("Rendering Logic", () => {
    it("should not be visible when isVisible prop is false", () => {
      renderWithTheme(<ConfirmationModal {...defaultProps} isVisible={false} />)

      // queryByTestId returns null if the element is not found, which is what we expect.
      expect(screen.queryByTestId("confirmation-modal-container")).toBeNull()
    })

    it("should render correctly with all props when isVisible is true", () => {
      renderWithTheme(<ConfirmationModal {...defaultProps} />)

      // The modal container should be in the DOM.
      expect(screen.getByTestId("confirmation-modal-container")).toBeTruthy()

      // Check if all the text content is rendered correctly.
      expect(screen.getByText("Confirm Action")).toBeTruthy()
      expect(screen.getByText("Are you sure you want to proceed?")).toBeTruthy()
      expect(screen.getByText("Yes, Confirm")).toBeTruthy()
      expect(screen.getByText("No, Cancel")).toBeTruthy()
    })
  })

  describe("User Interactions", () => {
    it("should call onConfirm and trigger heavy haptic feedback when confirm is pressed", () => {
      renderWithTheme(<ConfirmationModal {...defaultProps} />)

      const confirmButton = screen.getByText("Yes, Confirm")
      fireEvent.press(confirmButton)

      // Verify that the correct callbacks were called.
      expect(onConfirmMock).toHaveBeenCalledTimes(1)
      expect(onCancelMock).not.toHaveBeenCalled()

      // Verify that the correct haptic feedback was triggered.
      expect(hapticsService.heavy).toHaveBeenCalledTimes(1)
      expect(hapticsService.light).not.toHaveBeenCalled()
    })

    it("should call onCancel and trigger light haptic feedback when cancel is pressed", () => {
      renderWithTheme(<ConfirmationModal {...defaultProps} />)

      const cancelButton = screen.getByText("No, Cancel")
      fireEvent.press(cancelButton)

      // Verify that the correct callbacks were called.
      expect(onCancelMock).toHaveBeenCalledTimes(1)
      expect(onConfirmMock).not.toHaveBeenCalled()

      // Verify that the correct haptic feedback was triggered.
      expect(hapticsService.light).toHaveBeenCalledTimes(1)
      expect(hapticsService.heavy).not.toHaveBeenCalled()
    })

    it("should call onCancel when the modal's onRequestClose is triggered", () => {
      renderWithTheme(<ConfirmationModal {...defaultProps} />)

      const modalContainer = screen.getByTestId("confirmation-modal-container")

      // Firing 'requestClose' simulates a user dismissing the modal (e.g., Android back button).
      fireEvent(modalContainer, "requestClose")

      expect(onCancelMock).toHaveBeenCalledTimes(1)
      expect(onConfirmMock).not.toHaveBeenCalled()

      // The component also calls light haptics on cancel.
      expect(hapticsService.light).toHaveBeenCalledTimes(1)
      expect(hapticsService.heavy).not.toHaveBeenCalled()
    })
  })
})

================
File: __tests__/countdownTimer.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  act,
  cleanup,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import CountdownTimer from "../src/components/countdownTimer"

// Custom Render Helper with ThemeProvider
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("CountdownTimer Component", () => {
  beforeEach(() => {
    jest.useFakeTimers()
  })

  afterEach(() => {
    jest.useRealTimers()
    cleanup()
  })

  // Helper to calculate expected time string dynamically based on the mocked time
  const getExpectedTime = (mockNow: Date) => {
    const tomorrow = new Date(mockNow)
    tomorrow.setDate(mockNow.getDate() + 1)
    tomorrow.setHours(0, 0, 0, 0)
    const diff = tomorrow.getTime() - mockNow.getTime()

    const pad = (num: number) => num.toString().padStart(2, "0")
    const hours = pad(Math.floor((diff / (1000 * 60 * 60)) % 24))
    const minutes = pad(Math.floor((diff / 1000 / 60) % 60))
    const seconds = pad(Math.floor((diff / 1000) % 60))

    return `${hours}:${minutes}:${seconds}`
  }

  describe("Rendering and Countdown Logic", () => {
    it("should render correctly on initial load", () => {
      const mockTime = new Date("2025-11-15T10:30:00") // Local time construction
      jest.setSystemTime(mockTime)

      renderWithTheme(<CountdownTimer />)

      const expected = getExpectedTime(mockTime)
      expect(screen.getByText(`Next game in ${expected}`)).toBeTruthy()
    })

    it("should update the countdown every second", () => {
      const mockTime = new Date("2025-11-15T23:59:50")
      jest.setSystemTime(mockTime)
      renderWithTheme(<CountdownTimer />)

      const initialExpected = getExpectedTime(mockTime)
      expect(screen.getByText(`Next game in ${initialExpected}`)).toBeTruthy()

      act(() => {
        jest.advanceTimersByTime(1000) // Advance 1 second
      })

      const nextTime = new Date(mockTime.getTime() + 1000)
      const nextExpected = getExpectedTime(nextTime)
      expect(screen.getByText(`Next game in ${nextExpected}`)).toBeTruthy()
    })
  })

  describe("Component Lifecycle", () => {
    it("should clear the interval timer when the component is unmounted", () => {
      const clearIntervalSpy = jest.spyOn(global, "clearInterval")
      const { unmount } = renderWithTheme(<CountdownTimer />)
      expect(clearIntervalSpy).not.toHaveBeenCalled()
      unmount()
      expect(clearIntervalSpy).toHaveBeenCalledTimes(1)
      clearIntervalSpy.mockRestore()
    })
  })
})

================
File: __tests__/customLoadingIndicator.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  cleanup,
  within,
  RenderOptions,
} from "@testing-library/react-native"
import { Platform } from "react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import CustomLoadingIndicator from "../src/components/customLoadingIndicator"
import { lightColors } from "../src/styles/themes"
import { responsive } from "../src/styles/global"

// Mock react-native-svg to test its props without actual rendering
jest.mock("react-native-svg", () => {
  const React = require("react")
  const { View } = require("react-native")

  const createMockSvgComponent = (name: string) => {
    return (props: any) => (
      <View testID={`mock-svg-${name.toLowerCase()}`} {...props} />
    )
  }

  return {
    Svg: createMockSvgComponent("Svg"),
    Circle: createMockSvgComponent("Circle"),
  }
})

// Custom Render Helper with ThemeProvider
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("CustomLoadingIndicator Component", () => {
  // Store original Platform.OS to restore it after tests
  const originalPlatformOS = Platform.OS

  afterEach(() => {
    cleanup()
    // Restore original Platform.OS after each test
    Object.defineProperty(Platform, "OS", {
      get: () => originalPlatformOS,
    })
  })

  describe("Fallback to Standard ActivityIndicator", () => {
    it("should render the standard ActivityIndicator when isLowEndDevice is true", () => {
      renderWithTheme(<CustomLoadingIndicator isLowEndDevice={true} />)

      expect(screen.getByTestId("standard-activity-indicator")).toBeTruthy()
      expect(screen.queryByTestId("activity-indicator")).toBeNull()
    })

    it("should render the standard ActivityIndicator on the web platform", () => {
      Object.defineProperty(Platform, "OS", { get: () => "web" })

      renderWithTheme(<CustomLoadingIndicator />)

      expect(screen.getByTestId("standard-activity-indicator")).toBeTruthy()
      expect(screen.queryByTestId("activity-indicator")).toBeNull()
    })

    it("should still render the standard ActivityIndicator on web even if isLowEndDevice is false", () => {
      Object.defineProperty(Platform, "OS", { get: () => "web" })

      renderWithTheme(<CustomLoadingIndicator isLowEndDevice={false} />)

      expect(screen.getByTestId("standard-activity-indicator")).toBeTruthy()
      expect(screen.queryByTestId("activity-indicator")).toBeNull()
    })
  })

  describe("Custom SVG Indicator Rendering", () => {
    beforeEach(() => {
      // Ensure tests in this block run as if on a native platform
      Object.defineProperty(Platform, "OS", { get: () => "ios" })
    })

    it("should render the custom SVG indicator on a non-low-end native device by default", () => {
      renderWithTheme(<CustomLoadingIndicator />)

      expect(screen.getByTestId("activity-indicator")).toBeTruthy()
      expect(screen.queryByTestId("standard-activity-indicator")).toBeNull()
    })

    it("should render the Svg component with two Circle components inside", () => {
      renderWithTheme(<CustomLoadingIndicator />)

      const customIndicator = screen.getByTestId("activity-indicator")
      const svgContainer = within(customIndicator).getByTestId("mock-svg-svg")
      const circles = within(svgContainer).getAllByTestId("mock-svg-circle")

      expect(circles).toHaveLength(2)
    })

    it("should have correctly calculated props on the Circle components", () => {
      renderWithTheme(<CustomLoadingIndicator />)
      const colors = lightColors

      // Replicate the calculations from the component to verify props
      const size = responsive.scale(50)
      const strokeWidth = responsive.scale(4)
      const radius = size / 2 - strokeWidth / 2
      const circumference = 2 * Math.PI * radius

      const circles = screen.getAllByTestId("mock-svg-circle")
      const [circle1, circle2] = circles

      // Check Circle 1 (Primary color)
      expect(circle1.props.stroke).toBe(colors.primary)
      expect(circle1.props.strokeWidth).toBe(strokeWidth)
      expect(circle1.props.strokeDasharray).toBe(circumference)
      expect(circle1.props.strokeDashoffset).toBe(circumference * 0.25)
      expect(circle1.props.strokeLinecap).toBe("round")

      // Check Circle 2 (Tertiary color)
      expect(circle2.props.stroke).toBe(colors.tertiary)
      expect(circle2.props.strokeWidth).toBe(strokeWidth)
      expect(circle2.props.strokeDasharray).toBe(circumference)
      expect(circle2.props.strokeDashoffset).toBe(circumference * 0.75)
      expect(circle2.props.strokeLinecap).toBe("round")
    })
  })

  describe("Accessibility", () => {
    it("should have the correct accessibility props for the custom indicator", () => {
      Object.defineProperty(Platform, "OS", { get: () => "ios" })

      renderWithTheme(<CustomLoadingIndicator />)

      const customIndicator = screen.getByTestId("activity-indicator")
      expect(customIndicator.props.accessibilityLabel).toBe("Loading content")
      expect(customIndicator.props.accessibilityRole).toBe("progressbar")
    })
  })
})

================
File: __tests__/detailModal.test.tsx
================
import React, { ReactElement } from "react";
import {
  render,
  screen,
  fireEvent,
  cleanup,
  RenderOptions,
  act, // Correctly imported `act`
} from "@testing-library/react-native";
import { Text, Share, Alert } from "react-native";
import { ThemeProvider } from "../src/contexts/themeContext";
import DetailModal from "../src/components/detailModal";
import { hapticsService } from "../src/utils/hapticsService";
import { analyticsService } from "../src/utils/analyticsService";
import { generateShareMessage } from "../src/utils/shareUtils";
import { defaultPlayerGame } from "../src/models/default";
import { PlayerGame } from "../src/models/game";

// --- Mocking Dependencies ---
jest.mock("../src/utils/hapticsService");
jest.mock("../src/utils/analyticsService");
jest.mock("react-native/Libraries/Share/Share", () => ({
  ...jest.requireActual("react-native/Libraries/Share/Share"),
  share: jest.fn(),
}));
jest.spyOn(Alert, "alert");

// Custom Render Helper with ThemeProvider
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options);
};

// --- Mock Data ---
const mockPlayerGame: PlayerGame = {
  ...defaultPlayerGame,
  id: "test-game-123",
  playerID: "test-player-1",
  correctAnswer: true, // For testing the 'win' analytics event
  guesses: [{ itemId: 1 }],
};

const mockShareMessage = generateShareMessage(mockPlayerGame);

describe("DetailModal Component", () => {
  const toggleModalMock = jest.fn();

  beforeEach(() => {
    // Clear all mocks before each test to ensure isolation
    jest.clearAllMocks();
  });

  afterEach(cleanup);

  describe("Rendering and Visibility", () => {
    it("should not be visible when the 'show' prop is false", () => {
      renderWithTheme(
        <DetailModal show={false} toggleModal={toggleModalMock}>
          <Text>Child Content</Text>
        </DetailModal>
      );
      // The modal's content should not be in the component tree
      expect(screen.queryByText("Child Content")).toBeNull();
    });

    it("should be visible and render children when the 'show' prop is true", () => {
      renderWithTheme(
        <DetailModal show={true} toggleModal={toggleModalMock}>
          <Text>Visible Child Content</Text>
        </DetailModal>
      );
      expect(screen.getByText("Visible Child Content")).toBeTruthy();
      expect(screen.getByText("Close")).toBeTruthy();
    });

    it("should not render the Share button if 'playerGame' prop is not provided", () => {
      renderWithTheme(
        <DetailModal show={true} toggleModal={toggleModalMock}>
          <Text>Child Content</Text>
        </DetailModal>
      );
      expect(screen.queryByText("Share")).toBeNull();
    });

    it("should render the Share button if 'playerGame' prop is provided", () => {
      renderWithTheme(
        <DetailModal
          show={true}
          toggleModal={toggleModalMock}
          playerGame={mockPlayerGame}
        >
          <Text>Child Content</Text>
        </DetailModal>
      );
      expect(screen.getByText("Share")).toBeTruthy();
    });
  });

  describe("User Interactions and Dismissal", () => {
    it("should call toggleModal(false) and trigger haptics when the Close button is pressed", () => {
      renderWithTheme(
        <DetailModal show={true} toggleModal={toggleModalMock}>
          <Text>Child Content</Text>
        </DetailModal>
      );

      fireEvent.press(screen.getByText("Close"));

      expect(toggleModalMock).toHaveBeenCalledWith(false);
      expect(hapticsService.light).toHaveBeenCalledTimes(1);
    });

    it("should call toggleModal(false) when the modal backdrop is pressed", () => {
      renderWithTheme(
        <DetailModal show={true} toggleModal={toggleModalMock}>
          <Text>Child Content</Text>
        </DetailModal>
      );

      // The backdrop is the Pressable with the accessibility label for closing
      fireEvent.press(
        screen.getByLabelText("Close modal by tapping outside")
      );

      expect(toggleModalMock).toHaveBeenCalledWith(false);
      expect(hapticsService.light).toHaveBeenCalledTimes(1);
    });

    it("should call toggleModal(false) when onRequestClose is triggered (e.g., Android back button)", () => {
      renderWithTheme(
        <DetailModal show={true} toggleModal={toggleModalMock}>
          <Text>Child Content</Text>
        </DetailModal>
      );

      // The modal content is wrapped in a view that we can find by its child text
      const modal = screen.getByText("Child Content").parent?.parent?.parent;
      expect(modal).toBeDefined();

      // Fire the onRequestClose event on the Modal component itself
      fireEvent(modal!, "requestClose");

      expect(toggleModalMock).toHaveBeenCalledWith(false);
      expect(hapticsService.light).toHaveBeenCalledTimes(1);
    });
  });

  describe("Share Functionality", () => {
    it("should call Share API, haptics, and analytics on successful share", async () => {
      (Share.share as jest.Mock).mockResolvedValue({
        action: Share.sharedAction,
      });

      renderWithTheme(
        <DetailModal
          show={true}
          toggleModal={toggleModalMock}
          playerGame={mockPlayerGame}
        >
          <Text>Child Content</Text>
        </DetailModal>
      );

      fireEvent.press(screen.getByText("Share"));

      // Verify haptics were triggered
      expect(hapticsService.medium).toHaveBeenCalledTimes(1);

      // Verify analytics were tracked with the correct outcome ('win')
      expect(analyticsService.trackShareResults).toHaveBeenCalledWith("win");

      // Verify the Share API was called with the correct message
      await expect(Share.share).toHaveBeenCalledWith(
        {
          message: mockShareMessage,
          title: "Talkie Trivia Results",
        },
        {
          dialogTitle: "Share your Talkie Trivia results!",
        }
      );
    });

    it("should show an alert if the Share API fails", async () => {
      const errorMessage = "Sharing failed";
      (Share.share as jest.Mock).mockRejectedValue(new Error(errorMessage));

      renderWithTheme(
        <DetailModal
          show={true}
          toggleModal={toggleModalMock}
          playerGame={mockPlayerGame}
        >
          <Text>Child Content</Text>
        </DetailModal>
      );

      fireEvent.press(screen.getByText("Share"));

      // Wait for the async share process to complete
      await act(async () => {
        // This flushes the promise queue
        await new Promise((resolve) => setImmediate(resolve));
      });

      expect(Alert.alert).toHaveBeenCalledWith("Share Error", errorMessage);
    });

    it("should determine the correct 'lose' outcome for analytics", () => {
      const losingGame = { ...mockPlayerGame, correctAnswer: false };
      renderWithTheme(
        <DetailModal
          show={true}
          toggleModal={toggleModalMock}
          playerGame={losingGame}
        >
          <Text>Child Content</Text>
        </DetailModal>
      );

      fireEvent.press(screen.getByText("Share"));
      expect(analyticsService.trackShareResults).toHaveBeenCalledWith("lose");
    });

    it("should determine the correct 'give_up' outcome for analytics", () => {
      const gaveUpGame = {
        ...mockPlayerGame,
        gaveUp: true,
        correctAnswer: false,
      };
      renderWithTheme(
        <DetailModal
          show={true}
          toggleModal={toggleModalMock}
          playerGame={gaveUpGame}
        >
          <Text>Child Content</Text>
        </DetailModal>
      );

      fireEvent.press(screen.getByText("Share"));
      expect(analyticsService.trackShareResults).toHaveBeenCalledWith(
        "give_up"
      );
    });
  });
});

================
File: __tests__/difficultySelector.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  fireEvent,
  act,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import DifficultySelector from "../src/components/difficultySelector"
import { useGameStore } from "../src/state/gameStore"
import { useAuth } from "../src/contexts/authContext"
import { hapticsService } from "../src/utils/hapticsService"
import { DEFAULT_DIFFICULTY, DIFFICULTY_MODES } from "../src/config/difficulty"

// --- Mocking Dependencies ---
jest.mock("../src/state/gameStore")
jest.mock("../src/contexts/authContext")
jest.mock("../src/utils/hapticsService")

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

const mockSetDifficulty = jest.fn()
const mockUseGameStore = useGameStore as unknown as jest.Mock
const mockUseAuth = useAuth as jest.Mock

describe("DifficultySelector Component", () => {
  beforeEach(() => {
    jest.clearAllMocks()
    jest.useFakeTimers()

    mockUseAuth.mockReturnValue({ player: { id: "test-player" } })

    mockUseGameStore.mockImplementation((selector: (state: any) => any) => {
      const state = {
        difficulty: DEFAULT_DIFFICULTY,
        setDifficulty: mockSetDifficulty,
      }
      return selector(state)
    })
  })

  afterEach(() => {
    jest.useRealTimers()
  })

  describe("Rendering", () => {
    it("should render correctly with default difficulty selected", () => {
      renderWithTheme(<DifficultySelector />)

      expect(screen.getByText("Difficulty")).toBeTruthy()
      expect(screen.getByTestId("mock-icon-gamepad")).toBeTruthy()

      const mediumElements = screen.getAllByText(
        DIFFICULTY_MODES[DEFAULT_DIFFICULTY].label
      )
      expect(mediumElements.length).toBeGreaterThan(0)
    })
  })

  describe("Interactions", () => {
    it("should call setDifficulty when a new option is pressed", () => {
      renderWithTheme(<DifficultySelector />)

      const hardButton = screen.getByText("Hard")
      fireEvent.press(hardButton)

      expect(mockSetDifficulty).toHaveBeenCalledWith("LEVEL_4")
    })
  })
})

================
File: __tests__/emptyGuessTile.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import { EmptyGuessTile } from "../src/components/guess/emptyGuessTile"

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("Guess Component: EmptyGuessTile", () => {
  it("should render the correct guess number based on index", () => {
    // Index 0 should display "1", Index 4 should display "5"
    const { rerender } = renderWithTheme(<EmptyGuessTile index={0} />)
    expect(screen.getByText("1")).toBeTruthy()

    rerender(
      <ThemeProvider>
        <EmptyGuessTile index={4} />
      </ThemeProvider>
    )
    expect(screen.getByText("5")).toBeTruthy()
  })

  it("should have dashed border styling", () => {
    renderWithTheme(<EmptyGuessTile index={0} testID="empty-tile" />)

    const container = screen.getByTestId("empty-tile")

    expect(container.props.style).toEqual(
      expect.objectContaining({
        borderStyle: "dashed",
        borderWidth: 2,
      })
    )
  })
})

================
File: __tests__/errorBoundary.test.tsx
================
import React from "react"
import {
  render,
  screen,
  fireEvent,
  cleanup,
  act,
} from "@testing-library/react-native"
import { Text, Alert } from "react-native"
import * as Updates from "expo-updates"
import ErrorBoundary from "../src/components/errorBoundary"
import { analyticsService } from "../src/utils/analyticsService"

jest.mock("expo-updates")
jest.mock("../src/utils/analyticsService")
jest.spyOn(Alert, "alert")

const errorMessage = "Test Error Message"
const ProblemChild = () => {
  throw new Error(errorMessage)
}

const HealthyChild = () => <Text>Healthy Content</Text>

describe("ErrorBoundary Component", () => {
  let consoleErrorSpy: jest.SpyInstance

  beforeEach(() => {
    jest.clearAllMocks()
    consoleErrorSpy = jest.spyOn(console, "error").mockImplementation(() => {})
  })

  afterEach(() => {
    consoleErrorSpy.mockRestore()
    cleanup()
  })

  it("should render children components when no error is thrown", () => {
    render(
      <ErrorBoundary>
        <HealthyChild />
      </ErrorBoundary>
    )
    expect(screen.getByText("Healthy Content")).toBeTruthy()
  })

  it("should catch an error and display the fallback UI", () => {
    render(
      <ErrorBoundary>
        <ProblemChild />
      </ErrorBoundary>
    )
    expect(screen.getByText("Oops! Something went wrong.")).toBeTruthy()
    expect(analyticsService.trackErrorBoundary).toHaveBeenCalledWith(
      errorMessage
    )
  })

  it("should call Updates.reloadAsync when 'Reload App' is pressed", async () => {
    const consoleLogSpy = jest
      .spyOn(console, "log")
      .mockImplementation(() => {})
    render(
      <ErrorBoundary>
        <ProblemChild />
      </ErrorBoundary>
    )

    fireEvent.press(screen.getByTestId("reload-button"))

    expect(Updates.reloadAsync).toHaveBeenCalledTimes(1)
    consoleLogSpy.mockRestore()
  })
})

================
File: __tests__/errorMessage.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  fireEvent,
  cleanup,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import ErrorMessage from "../src/components/errorMessage"

// Custom Render Helper with ThemeProvider
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("ErrorMessage Component", () => {
  const onRetryMock = jest.fn()

  beforeEach(() => {
    onRetryMock.mockClear()
  })

  afterEach(cleanup)

  describe("Rendering Logic", () => {
    it("should render only the message when onRetry is not provided", () => {
      const message = "Something went wrong."
      renderWithTheme(<ErrorMessage message={message} />)

      // Check that the message is displayed
      expect(screen.getByText(message)).toBeTruthy()

      // Check that the retry button is NOT rendered
      expect(screen.queryByText("Retry")).toBeNull()
    })

    it("should render both the message and the retry button when onRetry is provided", () => {
      const message = "Network connection failed."
      renderWithTheme(<ErrorMessage message={message} onRetry={onRetryMock} />)

      expect(screen.getByText(message)).toBeTruthy()
      expect(screen.getByText("Retry")).toBeTruthy()
    })

    it("should render an empty message if an empty string is passed", () => {
      renderWithTheme(<ErrorMessage message="" />)

      // The Text component for the message should still be there, just empty.
      const messageElement = screen.getByText("")
      expect(messageElement).toBeTruthy()
    })
  })

  describe("Interaction", () => {
    it("should call the onRetry function when the retry button is pressed", () => {
      const message = "Could not load data."
      renderWithTheme(<ErrorMessage message={message} onRetry={onRetryMock} />)

      const retryButton = screen.getByText("Retry")
      fireEvent.press(retryButton)

      expect(onRetryMock).toHaveBeenCalledTimes(1)
    })

    it("should not call onRetry if the button is not pressed", () => {
      const message = "Another error."
      renderWithTheme(<ErrorMessage message={message} onRetry={onRetryMock} />)

      expect(onRetryMock).not.toHaveBeenCalled()
    })
  })
})

================
File: __tests__/facts.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  fireEvent,
  cleanup,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import Facts from "../src/components/facts"
import { TriviaItem } from "../src/models/trivia"
import { useExternalLink } from "../src/utils/hooks/useExternalLink"
import { analyticsService } from "../src/utils/analyticsService"
import { API_CONFIG } from "../src/config/constants"

// --- Mocking Dependencies ---
jest.mock("../src/utils/hooks/useExternalLink")
jest.mock("../src/utils/analyticsService")

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

const mockOpenLink = jest.fn()
const mockUseExternalLink = useExternalLink as jest.Mock
const mockAnalyticsService = analyticsService as jest.Mocked<
  typeof analyticsService
>

// --- Mock Data ---
const mockTriviaItem: TriviaItem = {
  id: 1,
  title: "Inception",
  description: "A thief who steals corporate secrets...",
  posterPath: "/inception_poster.jpg",
  releaseDate: "2010-07-16",
  metadata: {
    imdb_id: "tt1375666",
    tagline: "Your mind is the scene of the crime.",
  },
  hints: [
    { type: "director", label: "Director", value: "Christopher Nolan" },
    {
      type: "actors",
      label: "Actors",
      value: [
        { id: 1, name: "Leonardo DiCaprio", imdb_id: "nm0000138" },
        { id: 2, name: "Joseph Gordon-Levitt", imdb_id: "nm0330687" },
      ],
    },
    { type: "genre", label: "Genre", value: "Sci-Fi" },
  ],
}

describe("Facts Component", () => {
  beforeEach(() => {
    jest.clearAllMocks()
    mockUseExternalLink.mockReturnValue({ openLink: mockOpenLink })
  })

  afterEach(cleanup)

  describe("Conditional States", () => {
    it("should render the loading indicator when isLoading is true", () => {
      renderWithTheme(<Facts item={mockTriviaItem} isLoading={true} />)
      expect(screen.getByTestId("activity-indicator")).toBeTruthy()
      expect(screen.queryByText(mockTriviaItem.title)).toBeNull()
    })

    it("should render the error message when an error is provided", () => {
      const errorMessage = "Failed to load movie details."
      renderWithTheme(<Facts item={mockTriviaItem} error={errorMessage} />)
      expect(screen.getByText(errorMessage)).toBeTruthy()
      expect(screen.queryByText(mockTriviaItem.title)).toBeNull()
    })
  })

  describe("Content Rendering", () => {
    it("should render all movie details correctly", () => {
      renderWithTheme(<Facts item={mockTriviaItem} />)

      // Header and Tagline
      expect(screen.getByText(mockTriviaItem.title)).toBeTruthy()
      expect(screen.getByText(mockTriviaItem.metadata.tagline)).toBeTruthy()

      // Poster Image - FIX: Use getAllByTestId and select the first one
      const allImages = screen.getAllByTestId("mock-expo-image")
      const poster = allImages[0] // The main poster is rendered before the actor images
      expect(poster.props["data-source"]).toContain(mockTriviaItem.posterPath)

      // Hints (Director)
      expect(screen.getByText("Director: Christopher Nolan")).toBeTruthy()

      // Hints (Actors) - Check that the Actors component rendered its content
      expect(screen.getByText("Leonardo DiCaprio")).toBeTruthy()
    })

    it("should use a fallback image if posterPath is null", () => {
      const itemWithNoPoster = { ...mockTriviaItem, posterPath: "" }
      renderWithTheme(<Facts item={itemWithNoPoster} />)

      const allImages = screen.getAllByTestId("mock-expo-image")
      const poster = allImages[0]
      // The fileMock returns '1' for any require() call
      expect(poster.props.source).toBe(1)
    })

    it("should render the header as non-pressable if imdb_id is missing", () => {
      const itemWithoutImdb = {
        ...mockTriviaItem,
        metadata: { ...mockTriviaItem.metadata, imdb_id: null },
      }
      renderWithTheme(<Facts item={itemWithoutImdb} />)

      const headerPressable = screen.getByText(
        itemWithoutImdb.title
      ).parentElement
      expect(headerPressable?.props.onPress).toBeUndefined()

      expect(screen.queryByTestId("mock-icon-external-link-square")).toBeNull()
    })
  })

  describe("Interactions", () => {
    it("should call openLink and analytics when the linkable header is pressed", () => {
      renderWithTheme(<Facts item={mockTriviaItem} />)

      const headerPressable = screen.getByText(mockTriviaItem.title)
      fireEvent.press(headerPressable)

      const expectedUrl = `${API_CONFIG.IMDB_BASE_URL_TITLE}${mockTriviaItem.metadata.imdb_id}`
      expect(mockOpenLink).toHaveBeenCalledWith(expectedUrl)
      expect(mockAnalyticsService.trackImdbLinkTapped).toHaveBeenCalledWith(
        mockTriviaItem.title
      )
    })

    it("should call openLink and analytics when an actor is pressed", () => {
      renderWithTheme(<Facts item={mockTriviaItem} />)

      const actorToPress = screen.getByTestId("actor-pressable-1")
      fireEvent.press(actorToPress)

      const actor = mockTriviaItem.hints.find((h) => h.type === "actors")
        ?.value[0]
      const expectedUrl = `${API_CONFIG.IMDB_BASE_URL_NAME}${actor.imdb_id}`

      expect(mockOpenLink).toHaveBeenCalledWith(expectedUrl)
      expect(mockAnalyticsService.trackActorLinkTapped).toHaveBeenCalledWith(
        actor.name
      )
    })
  })
})

================
File: __tests__/flashMessages.test.tsx
================
// __tests__/flashMessages.test.tsx

import React, { ReactElement } from "react"
import {
  render,
  screen,
  act,
  cleanup,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import FlashMessages from "../src/components/flashMessages"

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("FlashMessages Component", () => {
  beforeEach(() => {
    jest.useFakeTimers()
  })

  afterEach(() => {
    jest.useRealTimers()
    cleanup()
  })

  describe("Rendering and Visibility", () => {
    it("should render null when the 'message' prop is null", () => {
      renderWithTheme(<FlashMessages message={null} />)
      expect(screen.queryByText(/.+/)).toBeNull()
    })

    it("should render the message when the 'message' prop is provided", () => {
      const testMessage = "This is a test message"
      renderWithTheme(<FlashMessages message={testMessage} />)
      // We just need to confirm it's in the document.
      expect(screen.getByText(testMessage)).toBeTruthy()
    })
  })

  describe("Lifecycle and Animations", () => {
    it("should trigger its disappear timer", () => {
      const testMessage = "This will disappear"
      const { rerender } = renderWithTheme(
        <FlashMessages message={testMessage} />
      )

      // Initially, the message is visible
      expect(screen.getByText(testMessage)).toBeTruthy()

      // We can't reliably test the "invisible" state due to animation and Jest limitations.
      // Instead, we confirm the timer logic works.
      // Advance timers to trigger the fade-out. The component is still mounted.
      act(() => {
        jest.advanceTimersByTime(3000)
      })
      expect(screen.getByText(testMessage)).toBeTruthy()

      // Now, if the parent component were to update and pass `message: null`, it would disappear.
      // Let's simulate that.
      rerender(
        <ThemeProvider>
          <FlashMessages message={null} />
        </ThemeProvider>
      )
      expect(screen.queryByText(testMessage)).toBeNull()
    })

    it("should update and reset its timer when the message prop changes", () => {
      const firstMessage = "First message"
      const secondMessage = "Second message"

      const { rerender } = renderWithTheme(
        <FlashMessages message={firstMessage} duration={2000} />
      )

      expect(screen.getByText(firstMessage)).toBeTruthy()

      // Advance time by 1500ms (less than the duration)
      act(() => {
        jest.advanceTimersByTime(1500)
      })

      // Rerender with a new message
      rerender(
        <ThemeProvider>
          <FlashMessages message={secondMessage} duration={2000} />
        </ThemeProvider>
      )

      // The new message should be visible, old one gone
      expect(screen.getByText(secondMessage)).toBeTruthy()
      expect(screen.queryByText(firstMessage)).toBeNull()

      // Advance time again by 1500ms. The first timer was cancelled,
      // so the second message should still be present.
      act(() => {
        jest.advanceTimersByTime(1500)
      })
      expect(screen.getByText(secondMessage)).toBeTruthy()
    })
  })
})

================
File: __tests__/fullPlotSection.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import FullPlotSection from "../src/components/gameOver/fullPlotSection"
import { useGameStore } from "../src/state/gameStore"

// Mock GameStore
jest.mock("../src/state/gameStore")
const mockUseGameStore = useGameStore as unknown as jest.Mock

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("GameOver Component: FullPlotSection", () => {
  beforeEach(() => {
    mockUseGameStore.mockImplementation((selector: any) =>
      selector({
        gameMode: "movies",
      })
    )
  })

  it("should render the plot overview provided via props", () => {
    const plot = "A young hobbit inherits a magical ring."
    renderWithTheme(<FullPlotSection overview={plot} />)
    expect(screen.getByText(plot)).toBeTruthy()
  })

  it("should display 'The Full Plot' title when game mode is movies", () => {
    mockUseGameStore.mockImplementation((selector: any) =>
      selector({ gameMode: "movies" })
    )
    renderWithTheme(<FullPlotSection overview="test" />)
    expect(screen.getByText("The Full Plot")).toBeTruthy()
  })

  it("should display 'The Full Description' title when game mode is videoGames", () => {
    mockUseGameStore.mockImplementation((selector: any) =>
      selector({ gameMode: "videoGames" })
    )
    renderWithTheme(<FullPlotSection overview="test" />)
    expect(screen.getByText("The Full Description")).toBeTruthy()
  })

  it("should display 'The Full Synopsis' title when game mode is tvShows", () => {
    mockUseGameStore.mockImplementation((selector: any) =>
      selector({ gameMode: "tvShows" })
    )
    renderWithTheme(<FullPlotSection overview="test" />)
    expect(screen.getByText("The Full Synopsis")).toBeTruthy()
  })
})

================
File: __tests__/game_screen.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, waitFor } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import { useGameStore } from "../src/state/gameStore"

// 1. Mock React.lazy to bypass dynamic imports
jest.mock("react", () => {
  const actualReact = jest.requireActual("react")
  return {
    ...actualReact,
    lazy: (factory: any) => {
      return function MockLazyComponent(props: any) {
        return <actualReact.Fragment>{props.children}</actualReact.Fragment>
      }
    },
    Suspense: ({ children }: { children: React.ReactNode }) => children,
  }
})

// 2. Mock the component modules that are being lazy-loaded.
// When `import("../../components/gameplayContainer")` is called, it returns this object.
jest.mock("../src/components/gameplayContainer", () => {
  const { View } = require("react-native")
  return {
    __esModule: true,
    default: () => <View testID="gameplay-container" />,
  }
})
jest.mock("../src/components/confettiCelebration", () => {
  const { View } = require("react-native")
  return {
    __esModule: true,
    default: () => <View testID="confetti" />,
  }
})
jest.mock("../src/components/flashMessages", () => {
  const { View } = require("react-native")
  return {
    __esModule: true,
    default: () => <View testID="flash-messages" />,
  }
})
jest.mock("../src/components/gameDifficultyToggle", () => {
  const { View } = require("react-native")
  return {
    __esModule: true,
    default: () => <View testID="difficulty-toggle" />,
  }
})

// Normal component mock
jest.mock("../src/components/titleHeader", () => {
  const { Text } = require("react-native")
  return ({ title }: any) => <Text>{title}</Text>
})

jest.mock("../src/state/gameStore")
jest.unmock("react") // Reset

jest.mock("react", () => {
  const actual = jest.requireActual("react")
  return {
    ...actual,
    lazy: jest.fn().mockImplementation(() => {
      const { View } = require("react-native")
      return (props: any) => <View testID="lazy-component" {...props} />
    }),
    Suspense: ({ children }: { children: React.ReactNode }) => children,
  }
})

import GameScreen from "../src/app/(tabs)/game"

const mockUseGameStore = useGameStore as unknown as jest.Mock

const renderWithTheme = (ui: ReactElement) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>)
}

describe("App: GameScreen", () => {
  beforeEach(() => {
    mockUseGameStore.mockImplementation((selector: any) =>
      selector({
        gameMode: "movies",
        showConfetti: false,
        handleConfettiStop: jest.fn(),
        flashMessage: null,
      })
    )
  })

  it("should render the header with correct title", async () => {
    renderWithTheme(<GameScreen />)
    await waitFor(() => {
      expect(screen.getByText("Find the title!")).toBeTruthy()
    })
  })

  it("should render lazy loaded components", async () => {
    renderWithTheme(<GameScreen />)
    await waitFor(() => {
      // We expect multiple lazy components (GameplayContainer, DifficultyToggle, etc.)
      const lazyComps = screen.getAllByTestId("lazy-component")
      expect(lazyComps.length).toBeGreaterThan(0)
    })
  })
})

================
File: __tests__/gameDifficultyToggle.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  fireEvent,
  cleanup,
  RenderOptions,
  within,
  act,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import GameDifficultyToggle from "../src/components/gameDifficultyToggle"
import { useGameStore } from "../src/state/gameStore"
import { hapticsService } from "../src/utils/hapticsService"
import { DEFAULT_DIFFICULTY, DIFFICULTY_MODES } from "../src/config/difficulty"
import { GameState } from "../src/state/gameStore"

jest.mock("../src/state/gameStore")
jest.mock("../src/utils/hapticsService")

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

const mockSetDifficulty = jest.fn()
const mockUseGameStore = useGameStore as unknown as jest.Mock

describe("GameDifficultyToggle Component", () => {
  const setMockStoreState = (overrides: Partial<GameState> = {}) => {
    const defaultState = {
      difficulty: DEFAULT_DIFFICULTY,
      setDifficulty: mockSetDifficulty,
      playerGame: { guesses: [] },
      isInteractionsDisabled: false,
      ...overrides,
    }
    mockUseGameStore.mockImplementation((selector: (state: any) => any) =>
      selector(defaultState)
    )
  }

  beforeEach(() => {
    jest.clearAllMocks()
    jest.useFakeTimers()
    setMockStoreState()
  })

  afterEach(() => {
    jest.useRealTimers()
    cleanup()
  })

  // Helper to get the main toggle button by its label and the fact it has a chevron icon
  const getToggleButton = (name: string) => {
    const buttons = screen.getAllByRole("button", { name })
    const toggleButton = buttons.find(
      (btn) =>
        within(btn).queryByTestId("mock-icon-chevron-down") ||
        within(btn).queryByTestId("mock-icon-chevron-up")
    )
    if (!toggleButton)
      throw new Error(
        `Could not find the main toggle button with name: ${name}`
      )
    return toggleButton
  }

  describe("Rendering", () => {
    it("should render the current difficulty label and be collapsed by default", () => {
      renderWithTheme(<GameDifficultyToggle />)

      expect(getToggleButton("Medium")).toBeTruthy()

      // The option buttons are rendered but should not be visible
      expect(screen.getByText("Easy")).not.toBeVisible()
      expect(screen.getByText("Hard")).not.toBeVisible()
    })
  })

  describe("Interactions", () => {
    it("should expand and show options when the toggle button is pressed", () => {
      renderWithTheme(<GameDifficultyToggle />)

      fireEvent.press(getToggleButton("Medium"))
      act(() => jest.runAllTimers())

      // FIX: Assert that the element is now in the tree and available.
      // `toBeVisible()` can be flaky with reanimated mocks.
      expect(screen.getByRole("button", { name: "Basic" })).toBeTruthy()
      expect(screen.getByRole("button", { name: "Hard" })).toBeTruthy()
      expect(hapticsService.light).toHaveBeenCalledTimes(1)
    })

    it("should call setDifficulty and collapse when an option is selected", () => {
      renderWithTheme(<GameDifficultyToggle />)

      fireEvent.press(getToggleButton("Medium"))
      act(() => jest.runAllTimers())

      const hardOptionButton = screen.getByRole("button", { name: "Hard" })
      fireEvent.press(hardOptionButton)
      act(() => jest.runAllTimers())

      expect(mockSetDifficulty).toHaveBeenCalledWith("LEVEL_4")
      expect(hapticsService.medium).toHaveBeenCalledTimes(1)

      // FIX: Assert that the element is no longer visible after collapsing.
      expect(hardOptionButton).not.toBeVisible()
    })
  })

  describe("Conditional Logic and Disabled States", () => {
    it("should be disabled if isInteractionsDisabled is true", () => {
      setMockStoreState({ isInteractionsDisabled: true })
      renderWithTheme(<GameDifficultyToggle />)

      const toggleButton = getToggleButton("Medium")
      expect(toggleButton.props.accessibilityState).toEqual({
        disabled: true,
        expanded: false,
      })

      fireEvent.press(toggleButton)
      expect(hapticsService.light).not.toHaveBeenCalled()
    })

    it("should disable options that have fewer max guesses than current guesses", () => {
      setMockStoreState({
        playerGame: {
          guesses: [{ itemId: 1 }, { itemId: 2 }, { itemId: 3 }, { itemId: 4 }],
        } as any,
      })
      renderWithTheme(<GameDifficultyToggle />)

      fireEvent.press(getToggleButton("Medium"))
      act(() => jest.runAllTimers())

      const extremeButton = screen.getByRole("button", { name: "Extreme" })
      const hardButton = screen.getByRole("button", { name: "Hard" })

      expect(extremeButton.props.accessibilityState).toEqual({ disabled: true })
      expect(hardButton.props.accessibilityState).toEqual({ disabled: false })
    })
  })
})

================
File: __tests__/gameHistory.test.tsx
================
// __tests__/gameHistory.test.tsx

import React, { ReactElement } from "react";
import {
  render,
  screen,
  fireEvent,
  cleanup,
  RenderOptions,
} from "@testing-library/react-native";
import { ThemeProvider } from "../src/contexts/themeContext";
import GameHistory from "../src/components/gameHistory";
import { useAuth } from "../src/contexts/authContext";
import { gameService } from "../src/services/gameService";
import { hapticsService } from "../src/utils/hapticsService";
import { GameHistoryEntry } from "../src/models/gameHistory";

// --- Mocking Dependencies ---
jest.mock("@shopify/flash-list", () => {
  const React = require("react");
  const { FlatList } = require("react-native");
  return {
    FlashList: React.forwardRef((props: any, ref: any) => (
      <FlatList ref={ref} {...props} />
    )),
  };
});
jest.mock("../src/contexts/authContext");
jest.mock("../src/services/gameService");
jest.mock("../src/utils/hapticsService");

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options);
};

const mockUseAuth = useAuth as jest.Mock;
const mockGameService = gameService as jest.Mocked<typeof gameService>;

const mockHistoryData: GameHistoryEntry[] = [
  { dateId: "2025-11-15", itemId: 101, itemTitle: "Inception", posterPath: "/inception.jpg", wasCorrect: true, gaveUp: false, guessCount: 2, guessesMax: 5, difficulty: "LEVEL_3", score: 850, gameMode: "movies" },
];

describe("GameHistory Component", () => {
  const onHistoryItemPressMock = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    mockUseAuth.mockReturnValue({ player: { id: "test-player-id" } });
  });

  afterEach(cleanup);

  describe("Loading State", () => {
    it("should display skeleton loaders while fetching data", () => {
      mockGameService.fetchGameHistory.mockReturnValue(new Promise(() => {}));
      
      renderWithTheme(<GameHistory onHistoryItemPress={onHistoryItemPressMock} />);

      // The refactored component now reliably renders these items
      const skeletons = screen.getAllByTestId("skeleton-item");
      expect(skeletons.length).toBe(5);
      expect(screen.queryByText("Inception")).toBeNull();
    });
  });

  describe("Data Display", () => {
    it("should render a list of game history items on successful fetch", async () => {
      mockGameService.fetchGameHistory.mockResolvedValue(mockHistoryData);
      
      renderWithTheme(<GameHistory onHistoryItemPress={onHistoryItemPressMock} />);

      expect(await screen.findByText("Inception")).toBeTruthy();
      expect(screen.getByText("Correct in 2/5 guesses!")).toBeTruthy();
      expect(screen.queryAllByTestId("skeleton-item").length).toBe(0);
    });
  });

  describe("Empty and Error States", () => {
    it("should display an empty message if no history is returned", async () => {
      mockGameService.fetchGameHistory.mockResolvedValue([]);
      renderWithTheme(<GameHistory onHistoryItemPress={onHistoryItemPressMock} />);
      expect(await screen.findByText("Play a game to see your history here!")).toBeTruthy();
    });

    it("should display an error message if the fetch fails", async () => {
      const consoleErrorSpy = jest.spyOn(console, "error").mockImplementation(() => {});
      mockGameService.fetchGameHistory.mockRejectedValue(new Error("Network Error"));
      renderWithTheme(<GameHistory onHistoryItemPress={onHistoryItemPressMock} />);
      expect(await screen.findByText("Could not load game history.")).toBeTruthy();
      consoleErrorSpy.mockRestore();
    });

    it("should display the empty message if there is no authenticated player", async () => {
      mockUseAuth.mockReturnValue({ player: null });
      renderWithTheme(<GameHistory onHistoryItemPress={onHistoryItemPressMock} />);

      // The component logic was updated to immediately set loading to false.
      // We still use findByText to wait for the state update.
      const emptyMessage = await screen.findByText("Play a game to see your history here!");
      expect(emptyMessage).toBeTruthy();
      expect(gameService.fetchGameHistory).not.toHaveBeenCalled();
      expect(screen.queryAllByTestId("skeleton-item").length).toBe(0);
    });
  });

  describe("Interaction", () => {
    it("should call onHistoryItemPress with the correct item when pressed", async () => {
      mockGameService.fetchGameHistory.mockResolvedValue(mockHistoryData);
      renderWithTheme(<GameHistory onHistoryItemPress={onHistoryItemPressMock} />);

      const firstItem = await screen.findByText("Inception");
      fireEvent.press(firstItem);

      expect(onHistoryItemPressMock).toHaveBeenCalledWith(mockHistoryData[0]);
    });
  });
});

================
File: __tests__/gameOverView.test.tsx
================
// __tests__/gameOverView.test.tsx

import React, { ReactElement } from "react"
import {
  render,
  screen,
  cleanup,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import GameOverView from "../src/components/gameOverView"
import { defaultPlayerGame } from "../src/models/default"
import { PlayerGame } from "../src/models/game"

// --- Mocking Child Components ---
// FIX: require dependencies inside the mock factory to avoid out-of-scope errors.
jest.mock("../src/components/facts", () => {
  const { View } = require("react-native")
  return (props: { item: any }) => (
    <View testID="mock-facts" data-itemid={props.item.id} />
  )
})
jest.mock("../src/components/gameOver/fullPlotSection", () => {
  const { View } = require("react-native")
  return (props: { overview: string }) => (
    <View testID="mock-full-plot" data-overview={props.overview} />
  )
})
jest.mock("../src/components/guesses", () => {
  const { View } = require("react-native")
  return (props: { lastGuessResult: any }) => (
    <View
      testID="mock-guesses"
      data-lastguess={props.lastGuessResult?.itemId}
    />
  )
})
jest.mock("../src/components/gameOver/shareResultButton", () => {
  const { View } = require("react-native")
  return (props: { playerGame: any }) => (
    <View testID="mock-share-button" data-gameid={props.playerGame.id} />
  )
})
jest.mock("../src/components/personalizedStatsMessage", () => {
  const { View } = require("react-native")
  return () => <View testID="mock-stats-message" />
})
jest.mock("../src/components/countdownTimer", () => {
  const { View } = require("react-native")
  return () => <View testID="mock-countdown-timer" />
})

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

// Mock data for different game outcomes
const mockPlayerGameWin: PlayerGame = {
  ...defaultPlayerGame,
  id: "win-game-1",
  correctAnswer: true,
  guesses: [{ itemId: 1 }, { itemId: 2 }],
  triviaItem: {
    ...defaultPlayerGame.triviaItem,
    id: 123,
    description: "The winning plot.",
  },
}

const mockPlayerGameLoss: PlayerGame = {
  ...defaultPlayerGame,
  id: "loss-game-1",
  correctAnswer: false,
  gaveUp: false,
  guesses: [{ itemId: 1 }, { itemId: 2 }, { itemId: 3 }],
  guessesMax: 3,
  triviaItem: {
    ...defaultPlayerGame.triviaItem,
    id: 456,
    description: "The losing plot.",
  },
}

const mockPlayerGameGiveUp: PlayerGame = {
  ...defaultPlayerGame,
  id: "giveup-game-1",
  correctAnswer: false,
  gaveUp: true,
  guesses: [{ itemId: 1 }],
  triviaItem: {
    ...defaultPlayerGame.triviaItem,
    id: 789,
    description: "The give-up plot.",
  },
}

const mockLastGuess = { itemId: 2, correct: true }

describe("GameOverView Component", () => {
  afterEach(cleanup)

  describe("Win Scenario", () => {
    beforeEach(() => {
      renderWithTheme(
        <GameOverView
          playerGame={mockPlayerGameWin}
          lastGuessResult={mockLastGuess}
        />
      )
    })

    it("should display the win title and message", () => {
      expect(screen.getByText("You Got It!")).toBeTruthy()
      expect(screen.getByText("You guessed it in 2 guesses!")).toBeTruthy()
    })

    it("should render all child components", () => {
      expect(screen.getByTestId("mock-facts")).toBeTruthy()
      expect(screen.getByTestId("mock-full-plot")).toBeTruthy()
      expect(screen.getByTestId("mock-guesses")).toBeTruthy()
      expect(screen.getByTestId("mock-share-button")).toBeTruthy()
      expect(screen.getByTestId("mock-stats-message")).toBeTruthy()
      expect(screen.getByTestId("mock-countdown-timer")).toBeTruthy()
    })

    it("should pass the correct props to child components", () => {
      expect(screen.getByTestId("mock-facts").props["data-itemid"]).toBe(
        mockPlayerGameWin.triviaItem.id
      )
      expect(screen.getByTestId("mock-full-plot").props["data-overview"]).toBe(
        mockPlayerGameWin.triviaItem.description
      )
      expect(screen.getByTestId("mock-guesses").props["data-lastguess"]).toBe(
        mockLastGuess.itemId
      )
      expect(screen.getByTestId("mock-share-button").props["data-gameid"]).toBe(
        mockPlayerGameWin.id
      )
    })
  })

  describe("Loss Scenario", () => {
    it("should display the loss title and message", () => {
      renderWithTheme(
        <GameOverView playerGame={mockPlayerGameLoss} lastGuessResult={null} />
      )
      expect(screen.getByText("So Close!")).toBeTruthy()
      expect(screen.getByText("Better luck next time.")).toBeTruthy()
    })
  })

  describe("Give Up Scenario", () => {
    it("should display the give up title and message", () => {
      renderWithTheme(
        <GameOverView
          playerGame={mockPlayerGameGiveUp}
          lastGuessResult={null}
        />
      )
      expect(screen.getByText("So Close!")).toBeTruthy()
      expect(
        screen.getByText("Sometimes you just know when to fold 'em.")
      ).toBeTruthy()
    })
  })
})

================
File: __tests__/gameplayContainer.test.tsx
================
// __tests__/gameplayContainer.test.tsx

import React, { ReactElement } from "react"
import {
  render,
  screen,
  cleanup,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import GameplayContainer from "../src/components/gameplayContainer"
import { useGameStore } from "../src/state/gameStore"
import { GameStatus, GameState } from "../src/state/gameStore"

// --- Mocking Dependencies ---
jest.mock("../src/components/clues", () => {
  const { View } = require("react-native")
  return () => <View testID="mock-clues" />
})
jest.mock("../src/components/gameplayView", () => {
  const { View } = require("react-native")
  return () => <View testID="mock-gameplay-view" />
})
jest.mock("../src/components/gameOverView", () => {
  const { View } = require("react-native")
  return () => <View testID="mock-game-over-view" />
})
jest.mock("../src/components/guesses", () => {
  const { View } = require("react-native")
  return () => <View testID="mock-guesses" />
})
jest.mock("../src/components/revealSequence", () => {
  const { View } = require("react-native")
  return (props: { onAnimationComplete: () => void }) => (
    <View
      testID="mock-reveal-sequence"
      onAnimationComplete={props.onAnimationComplete}
    />
  )
})
jest.mock("../src/state/gameStore")

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

// FIX: Use 'as unknown as jest.Mock' to satisfy TypeScript
const mockUseGameStore = useGameStore as unknown as jest.Mock
const mockCompleteRevealSequence = jest.fn()

const setMockStoreState = (gameStatus: GameStatus) => {
  const mockState: Partial<GameState> = {
    gameStatus,
    playerGame: { guesses: [] } as any,
    lastGuessResult: null,
    completeRevealSequence: mockCompleteRevealSequence,
  }

  mockUseGameStore.mockImplementation((selector: (state: any) => any) => {
    return selector(mockState)
  })
}

describe("GameplayContainer Component", () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  afterEach(cleanup)

  describe('when gameStatus is "playing"', () => {
    it("should render the core gameplay components", () => {
      setMockStoreState("playing")
      renderWithTheme(<GameplayContainer />)
      expect(screen.getByTestId("mock-clues")).toBeTruthy()
      expect(screen.getByTestId("mock-gameplay-view")).toBeTruthy()
      expect(screen.getByTestId("mock-guesses")).toBeTruthy()
    })
  })

  describe('when gameStatus is "gameOver"', () => {
    it("should render the GameOverView component and not the gameplay components", () => {
      setMockStoreState("gameOver")
      renderWithTheme(<GameplayContainer />)
      expect(screen.getByTestId("mock-game-over-view")).toBeTruthy()
      expect(screen.queryByTestId("mock-clues")).toBeNull()
      expect(screen.queryByTestId("mock-gameplay-view")).toBeNull()
    })
  })

  describe('when gameStatus is "revealing"', () => {
    it("should render gameplay components AND the RevealSequence", () => {
      setMockStoreState("revealing")
      renderWithTheme(<GameplayContainer />)
      expect(screen.getByTestId("mock-clues")).toBeTruthy()
      expect(screen.getByTestId("mock-reveal-sequence")).toBeTruthy()
    })

    it("should call completeRevealSequence when the animation completes", () => {
      setMockStoreState("revealing")
      renderWithTheme(<GameplayContainer />)
      const revealSequence = screen.getByTestId("mock-reveal-sequence")
      revealSequence.props.onAnimationComplete()
      expect(mockCompleteRevealSequence).toHaveBeenCalledTimes(1)
    })
  })
})

================
File: __tests__/gameplayView.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  fireEvent,
  cleanup,
  RenderOptions,
  act,
  within,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import GameplayView from "../src/components/gameplayView"
import { useGameStore } from "../src/state/gameStore"
import { hapticsService } from "../src/utils/hapticsService"
import { GameState } from "../src/state/gameStore"
import { GAME_MODE_CONFIG } from "../src/config/difficulty"

// --- Mocking Dependencies ---
jest.mock("../src/components/picker", () => {
  const { Text } = require("react-native")
  return () => <Text>mock-PickerContainer</Text>
})
jest.mock("../src/components/hint", () => {
  const { Text } = require("react-native")
  return () => <Text>mock-HintContainer</Text>
})
jest.mock("../src/components/confirmationModal", () => jest.fn(() => null))
jest.mock("../src/state/gameStore")
jest.mock("../src/utils/hapticsService")

import ConfirmationModal from "../src/components/confirmationModal"

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

const mockGiveUp = jest.fn()
const mockUseGameStore = useGameStore as unknown as jest.Mock
const MockedConfirmationModal = ConfirmationModal as unknown as jest.Mock

describe("GameplayView Component", () => {
  const setMockStoreState = (overrides: Partial<GameState> = {}) => {
    const defaultState: Partial<GameState> = {
      giveUp: mockGiveUp,
      isInteractionsDisabled: false,
      gameMode: "movies",
      ...overrides,
    }
    mockUseGameStore.mockImplementation((selector: (state: any) => any) =>
      selector(defaultState)
    )
  }

  beforeEach(() => {
    jest.clearAllMocks()
    setMockStoreState()
  })

  afterEach(cleanup)

  describe("Rendering", () => {
    it("should render all primary components", () => {
      renderWithTheme(<GameplayView />)
      expect(screen.getByText("mock-PickerContainer")).toBeTruthy()
      expect(screen.getByText("mock-HintContainer")).toBeTruthy()
      expect(screen.getByTestId("give-up-button")).toBeTruthy()
    })
  })

  describe("Give Up Flow", () => {
    it("should show the confirmation modal when 'Give Up?' is pressed", () => {
      renderWithTheme(<GameplayView />)
      fireEvent.press(screen.getByTestId("give-up-button"))
      expect(hapticsService.warning).toHaveBeenCalledTimes(1)
      const { isVisible } = MockedConfirmationModal.mock.calls.pop()[0]
      expect(isVisible).toBe(true)
    })

    it("should call the giveUp action when confirmed", () => {
      renderWithTheme(<GameplayView />)
      fireEvent.press(screen.getByTestId("give-up-button"))
      const { onConfirm } = MockedConfirmationModal.mock.calls.pop()[0]
      act(() => {
        onConfirm()
      })
      expect(mockGiveUp).toHaveBeenCalledTimes(1)
    })
  })

  describe("Disabled State", () => {
    it("should disable the 'Give Up?' button when isInteractionsDisabled is true", () => {
      setMockStoreState({ isInteractionsDisabled: true })
      renderWithTheme(<GameplayView />)
      const giveUpButton = screen.getByTestId("give-up-button")
      expect(giveUpButton).toBeDisabled()
    })

    it("should show the 'Give Up?' button in a loading state while the giveUp action is processing", () => {
      renderWithTheme(<GameplayView />)
      const giveUpButton = screen.getByTestId("give-up-button")

      expect(within(giveUpButton).getByText("Give Up?")).toBeTruthy()

      fireEvent.press(giveUpButton)
      const { onConfirm } = MockedConfirmationModal.mock.calls.pop()[0]

      act(() => {
        onConfirm()
      })

      // Re-query for the button after the re-render
      const giveUpButtonAfterClick = screen.getByTestId("give-up-button")
      expect(within(giveUpButtonAfterClick).queryByText("Give Up?")).toBeNull()
    })
  })
})

================
File: __tests__/gameStore.test.tsx
================
import { act, renderHook } from "@testing-library/react-native"
import { useGameStore } from "../src/state/gameStore"
import { defaultPlayerGame, defaultPlayerStats } from "../src/models/default"
import { analyticsService } from "../src/utils/analyticsService"

// Mocks
jest.mock("../src/utils/analyticsService")
jest.mock("../src/services/gameService")
jest.mock("@react-native-async-storage/async-storage", () =>
  require("@react-native-async-storage/async-storage/jest/async-storage-mock")
)

// Mock Data
const mockBasicItem = {
  id: 101,
  title: "The Matrix",
  releaseDate: "1999",
  posterPath: "/path",
}
const mockFullItem = {
  id: 101,
  title: "The Matrix",
  description: "Neo...",
  posterPath: "/path",
  releaseDate: "1999",
  metadata: {},
  hints: [
    { type: "director", label: "Director", value: "Wachowski" },
    { type: "genre", label: "Genre", value: "Sci-Fi" },
  ],
}

describe("State: gameStore", () => {
  const initialState = useGameStore.getState()

  beforeEach(() => {
    jest.clearAllMocks()
    useGameStore.setState({
      ...initialState,
      playerGame: {
        ...defaultPlayerGame,
        triviaItem: mockFullItem,
        guessesMax: 5,
      },
      playerStats: { ...defaultPlayerStats, hintsAvailable: 3 },
      fullItems: [mockFullItem],
      basicItems: [mockBasicItem],
      isInteractionsDisabled: false,
      difficulty: "LEVEL_3", // Medium: Implicit Feedback
    })
  })

  describe("makeGuess", () => {
    it("should process a correct guess", async () => {
      const { result } = renderHook(() => useGameStore())

      await act(async () => {
        result.current.makeGuess(mockBasicItem)
      })

      const state = result.current
      expect(state.playerGame.correctAnswer).toBe(true)
      expect(state.showConfetti).toBe(true)
      expect(state.isInteractionsDisabled).toBe(true) // Game over triggered
      expect(analyticsService.trackGuessMade).toHaveBeenCalledWith(
        1,
        true,
        101,
        "The Matrix"
      )
    })

    it("should process an incorrect guess and provide feedback", async () => {
      const { result } = renderHook(() => useGameStore())
      const wrongItem = { ...mockBasicItem, id: 999, title: "Wrong Movie" }

      await act(async () => {
        result.current.makeGuess(wrongItem)
      })

      const state = result.current
      expect(state.playerGame.correctAnswer).toBe(false)
      expect(state.playerGame.guesses).toHaveLength(1)
      expect(state.lastGuessResult?.correct).toBe(false)
      expect(analyticsService.trackGuessMade).toHaveBeenCalledWith(
        1,
        false,
        999,
        "Wrong Movie"
      )
    })

    it("should not allow guesses if game is over", () => {
      const { result } = renderHook(() => useGameStore())

      act(() => {
        useGameStore.setState({
          playerGame: { ...defaultPlayerGame, correctAnswer: true },
        })
      })

      act(() => {
        result.current.makeGuess(mockBasicItem)
      })

      // Should not have added a guess
      expect(useGameStore.getState().playerGame.guesses).toHaveLength(0)
    })
  })

  describe("useHint", () => {
    it("should decrement hintsAvailable and mark hint as used", () => {
      const { result } = renderHook(() => useGameStore())

      // Switch to a mode that allows manual hints (Level 2)
      act(() => {
        result.current.setDifficulty("LEVEL_2")
      })

      act(() => {
        result.current.useHint("director")
      })

      const state = result.current
      expect(state.playerGame.hintsUsed?.director).toBe(true)
      expect(state.playerStats.hintsAvailable).toBe(2) // Started with 3
      expect(analyticsService.trackHintUsed).toHaveBeenCalled()
    })

    it("should not allow using a hint if none available", () => {
      const { result } = renderHook(() => useGameStore())

      act(() => {
        result.current.setDifficulty("LEVEL_2")
        useGameStore.setState({
          playerStats: { ...defaultPlayerStats, hintsAvailable: 0 },
        })
      })

      act(() => {
        result.current.useHint("genre")
      })

      const state = result.current
      expect(state.playerGame.hintsUsed?.genre).toBeUndefined()
    })
  })

  describe("giveUp", () => {
    it("should mark game as gaveUp and disable interactions", async () => {
      const { result } = renderHook(() => useGameStore())

      await act(async () => {
        result.current.giveUp()
      })

      const state = result.current
      expect(state.playerGame.gaveUp).toBe(true)
      expect(state.isInteractionsDisabled).toBe(true)
      expect(analyticsService.trackGameGiveUp).toHaveBeenCalled()
    })
  })
})

================
File: __tests__/genres.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import Genres from "../src/components/genres"
import { Genre } from "../src/models/trivia"

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

// --- Mock Data ---
const mockGenres: Genre[] = [
  { id: 1, name: "Action" },
  { id: 2, name: "Adventure" },
  { id: 3, name: "Comedy" },
  { id: 4, name: "Drama" },
  { id: 5, name: "Fantasy" },
  { id: 6, name: "Horror" },
  { id: 7, name: "Sci-Fi" },
]

describe("Genres Component", () => {
  describe("Rendering Logic", () => {
    it("should render 'No genres available' when the list is empty", () => {
      renderWithTheme(<Genres genres={[]} />)
      expect(screen.getByText("No genres available")).toBeTruthy()
    })

    it("should render 'No genres available' when the genres prop is null", () => {
      renderWithTheme(<Genres genres={null} />)
      expect(screen.getByText("No genres available")).toBeTruthy()
    })

    it("should render all genres if count is less than default max (5)", () => {
      const fewGenres = mockGenres.slice(0, 3)
      renderWithTheme(<Genres genres={fewGenres} />)

      expect(screen.getByText("Action")).toBeTruthy()
      expect(screen.getByText("Adventure")).toBeTruthy()
      expect(screen.getByText("Comedy")).toBeTruthy()

      // Should not show "+X more"
      expect(screen.queryByText(/\+\d+ more/)).toBeNull()
    })

    it("should render exactly max genres (default 5) without truncation text", () => {
      const fiveGenres = mockGenres.slice(0, 5)
      renderWithTheme(<Genres genres={fiveGenres} />)

      expect(screen.getByText("Action")).toBeTruthy()
      expect(screen.getByText("Fantasy")).toBeTruthy()

      // Boundary check: If length == max, no "+ more" text
      expect(screen.queryByText(/\+\d+ more/)).toBeNull()
    })
  })

  describe("Truncation Logic", () => {
    it("should truncate the list and show '+X more' when exceeding default max (5)", () => {
      renderWithTheme(<Genres genres={mockGenres} />) // Length is 7

      // Should show first 5
      expect(screen.getByText("Action")).toBeTruthy()
      expect(screen.getByText("Fantasy")).toBeTruthy()

      // Should NOT show 6th and 7th in the list
      expect(screen.queryByText("Horror")).toBeNull()
      expect(screen.queryByText("Sci-Fi")).toBeNull()

      // Should show remaining count (7 - 5 = 2)
      expect(screen.getByText("+2 more")).toBeTruthy()
    })

    it("should respect a custom 'maxGenres' prop", () => {
      renderWithTheme(<Genres genres={mockGenres} maxGenres={2} />)

      // Should show first 2
      expect(screen.getByText("Action")).toBeTruthy()
      expect(screen.getByText("Adventure")).toBeTruthy()

      // Should NOT show 3rd
      expect(screen.queryByText("Comedy")).toBeNull()

      // Should show remaining count (7 - 2 = 5)
      expect(screen.getByText("+5 more")).toBeTruthy()
    })
  })

  describe("Styling and Content", () => {
    it("should handle long genre names with ellipsization props", () => {
      const longGenre: Genre[] = [
        { id: 99, name: "Super Extremely Long Genre Name That Does Not Fit" },
      ]
      renderWithTheme(<Genres genres={longGenre} />)

      const genreText = screen.getByText(
        "Super Extremely Long Genre Name That Does Not Fit"
      )

      // Verify the component passes numberOfLines and tail props to the Typography component
      expect(genreText.props.numberOfLines).toBe(1)
      expect(genreText.props.ellipsizeMode).toBe("tail")
    })
  })
})

================
File: __tests__/googleLogin.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  fireEvent,
  cleanup,
  RenderOptions,
  within,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import GoogleLogin from "../src/components/googleLogin"
import { useAuth } from "../src/contexts/authContext"
import { hapticsService } from "../src/utils/hapticsService"

// --- Mocking Dependencies ---
jest.mock("../src/contexts/authContext")
jest.mock("../src/utils/hapticsService")

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

const mockUseAuth = useAuth as jest.Mock
const mockHandleSignIn = jest.fn()
const mockHandleSignOut = jest.fn()

describe("GoogleLogin Component", () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  afterEach(cleanup)

  describe("Signed Out State", () => {
    it("should render 'Sign In with Google' button and call handleSignIn on press", () => {
      mockUseAuth.mockReturnValue({
        user: { isAnonymous: true },
        handleSignIn: mockHandleSignIn,
        isSigningIn: false,
        error: null,
      })

      renderWithTheme(<GoogleLogin />)
      const signInButton = screen.getByRole("button", {
        name: "Sign In with Google",
      })
      fireEvent.press(signInButton)

      expect(hapticsService.medium).toHaveBeenCalledTimes(1)
      expect(mockHandleSignIn).toHaveBeenCalledTimes(1)
    })
  })

  describe("Signed In State", () => {
    it("should render 'Sign Out' with displayName and call handleSignOut on press", () => {
      mockUseAuth.mockReturnValue({
        user: { isAnonymous: false, displayName: "Test User" },
        handleSignOut: mockHandleSignOut,
        isSigningIn: false,
        error: null,
      })

      renderWithTheme(<GoogleLogin />)
      const signOutButton = screen.getByRole("button", {
        name: "Sign Out Test User",
      })
      fireEvent.press(signOutButton)

      expect(hapticsService.medium).toHaveBeenCalledTimes(1)
      expect(mockHandleSignOut).toHaveBeenCalledTimes(1)
    })
  })

  describe("Loading State", () => {
    it("should render a loading indicator and be disabled when isSigningIn is true", () => {
      mockUseAuth.mockReturnValue({
        user: null,
        handleSignIn: mockHandleSignIn,
        isSigningIn: true, // Set loading state
        error: null,
      })

      renderWithTheme(<GoogleLogin />)

      const button = screen.getByRole("button")
      expect(button).toBeDisabled()

      // Query for the ActivityIndicator by the testID we added to the Button component.
      const activityIndicator = within(button).getByTestId("activity-indicator")
      expect(activityIndicator).toBeTruthy()

      // The button title should not be rendered while loading
      expect(screen.queryByText(/Sign In/)).toBeNull()
    })
  })

  describe("Error State", () => {
    it("should display an error message when an error is provided", () => {
      const errorMessage = "Authentication failed."
      mockUseAuth.mockReturnValue({
        user: null,
        error: errorMessage,
        isSigningIn: false,
      })

      renderWithTheme(<GoogleLogin />)
      expect(screen.getByText(errorMessage)).toBeTruthy()
    })
  })
})

================
File: __tests__/guesses.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import GuessesContainer from "../src/components/guesses"
import { useGameStore } from "../src/state/gameStore"
import { defaultPlayerGame } from "../src/models/default"
import { PlayerGame } from "../src/models/game"

// --- Mocks ---

// 1. Mock the child components to render standard Views with test data attributes
jest.mock("../src/components/guess/guessRow", () => {
  const { View } = require("react-native")
  return {
    GuessRow: jest.fn(({ index, isLastGuess, guess }) => (
      <View
        testID={`guess-row-${index}`}
        // @ts-ignore - Custom data prop for testing verification
        data-is-last={isLastGuess}
        // @ts-ignore - Custom data prop for testing verification
        data-item-id={guess.itemId}
      />
    )),
  }
})

jest.mock("../src/components/guess/emptyGuessTile", () => {
  const { View } = require("react-native")
  return {
    EmptyGuessTile: jest.fn(({ index }) => (
      <View testID={`empty-tile-${index}`} />
    )),
  }
})

jest.mock("../src/components/guess/skeletonRow", () => {
  const { View } = require("react-native")
  return {
    SkeletonRow: jest.fn(({ index }) => (
      <View testID={`skeleton-row-${index}`} />
    )),
  }
})

// 2. Mock FlashList to render a simple View with children
jest.mock("@shopify/flash-list", () => {
  const React = require("react")
  const { View } = require("react-native")
  return {
    FlashList: ({ data, renderItem }: any) => {
      return (
        <View testID="flash-list">
          {data.map((item: any, index: number) => (
            <React.Fragment key={index}>
              {renderItem({ item, index })}
            </React.Fragment>
          ))}
        </View>
      )
    },
  }
})

// 3. Mock the Game Store
jest.mock("../src/state/gameStore")
const mockUseGameStore = useGameStore as unknown as jest.Mock

// --- Helper Data ---
const mockBasicItems = [
  { id: 101, title: "Movie A", releaseDate: "2000", posterPath: "/a.jpg" },
  { id: 102, title: "Movie B", releaseDate: "2001", posterPath: "/b.jpg" },
]

const mockPlayerGame: PlayerGame = {
  ...defaultPlayerGame,
  id: "game-1",
  guessesMax: 5,
  triviaItem: { ...defaultPlayerGame.triviaItem, id: 100 }, // Correct answer ID is 100
  guesses: [
    { itemId: 101, hintInfo: [] }, // Wrong guess 1
    { itemId: 102, hintInfo: [] }, // Wrong guess 2
  ],
}

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

const setMockStoreState = (state: any) => {
  mockUseGameStore.mockImplementation((selector: any) => selector(state))
}

describe("GuessesContainer Component", () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe("Loading States", () => {
    it("should render SkeletonRows when global state is loading and no display game is provided", () => {
      setMockStoreState({
        loading: true,
        playerGame: defaultPlayerGame,
        basicItems: [],
      })

      renderWithTheme(<GuessesContainer lastGuessResult={null} />)

      // Should render skeletons up to guessesMax (default 5)
      const skeletons = screen.getAllByTestId(/skeleton-row-/)
      expect(skeletons).toHaveLength(5)
      expect(screen.queryByTestId(/guess-row-/)).toBeNull()
    })

    it("should NOT render skeletons if gameForDisplay is provided, even if global loading is true", () => {
      // This simulates the Profile -> History Detail view where data is passed in directly
      setMockStoreState({
        loading: true, // Global loading is true (maybe background sync)
        playerGame: defaultPlayerGame,
      })

      renderWithTheme(
        <GuessesContainer
          lastGuessResult={null}
          gameForDisplay={mockPlayerGame} // Explicit data passed
          allItemsForDisplay={mockBasicItems}
        />
      )

      // Should use the data from props, not show skeletons
      expect(screen.queryByTestId(/skeleton-row-/)).toBeNull()
      expect(screen.getAllByTestId(/guess-row-/)).toHaveLength(2)
    })
  })

  describe("Active Gameplay Rendering", () => {
    beforeEach(() => {
      setMockStoreState({
        loading: false,
        playerGame: mockPlayerGame,
        basicItems: mockBasicItems,
      })
    })

    it("should render a mix of GuessRows and EmptyGuessTiles based on current progress", () => {
      renderWithTheme(<GuessesContainer lastGuessResult={null} />)

      // Mock game has 2 guesses out of 5 max
      const guesses = screen.getAllByTestId(/guess-row-/)
      const empties = screen.getAllByTestId(/empty-tile-/)

      expect(guesses).toHaveLength(2)
      expect(empties).toHaveLength(3) // 5 max - 2 used = 3 empty
    })

    it("should pass correct props to GuessRow components", () => {
      renderWithTheme(<GuessesContainer lastGuessResult={null} />)

      const firstGuess = screen.getByTestId("guess-row-0")
      expect(firstGuess.props["data-item-id"]).toBe(101)
    })

    it("should identify the last guess correctly when lastGuessResult matches", () => {
      const lastGuessResult = {
        itemId: 102, // Matches the second guess in mockPlayerGame
        correct: false,
        feedback: "Wrong",
      }

      renderWithTheme(<GuessesContainer lastGuessResult={lastGuessResult} />)

      const firstGuess = screen.getByTestId("guess-row-0")
      const secondGuess = screen.getByTestId("guess-row-1")

      // The first guess is NOT the last one made
      expect(firstGuess.props["data-is-last"]).toBe(false)

      // The second guess IS the last one made
      expect(secondGuess.props["data-is-last"]).toBe(true)
    })

    it("should NOT mark a row as last guess if the IDs do not match", () => {
      // This edge case happens if state desyncs slightly or during resets
      const mismatchResult = {
        itemId: 999, // Doesn't match any guess in the list
        correct: false,
      }

      renderWithTheme(<GuessesContainer lastGuessResult={mismatchResult} />)

      const secondGuess = screen.getByTestId("guess-row-1")
      expect(secondGuess.props["data-is-last"]).toBe(false)
    })
  })

  describe("Profile/History View Rendering", () => {
    it("should render correctly using passed props (gameForDisplay)", () => {
      const historicGame: PlayerGame = {
        ...mockPlayerGame,
        guesses: [{ itemId: 101, hintInfo: [] }], // Only 1 guess
        guessesMax: 3, // Custom max for this specific game
      }

      // Global store might be empty or different
      setMockStoreState({
        loading: false,
        playerGame: defaultPlayerGame,
      })

      renderWithTheme(
        <GuessesContainer
          lastGuessResult={null}
          gameForDisplay={historicGame}
          allItemsForDisplay={mockBasicItems}
        />
      )

      // Should respect the props: 1 guess, 2 empties (total 3)
      expect(screen.getAllByTestId(/guess-row-/)).toHaveLength(1)
      expect(screen.getAllByTestId(/empty-tile-/)).toHaveLength(2)
    })
  })

  describe("Layout and Styling", () => {
    it("should calculate container height based on guessesMax", () => {
      setMockStoreState({
        loading: false,
        playerGame: { ...mockPlayerGame, guessesMax: 10 }, // 10 max guesses
        basicItems: [],
      })

      renderWithTheme(<GuessesContainer lastGuessResult={null} />)

      // We verify that the list renders 10 slots total (guesses + empty tiles).
      const totalSlots =
        screen.queryAllByTestId(/guess-row-/).length +
        screen.queryAllByTestId(/empty-tile-/).length
      expect(totalSlots).toBe(10)
    })
  })
})

================
File: __tests__/guessFeedbackUtils.test.tsx
================
import { generateImplicitHint } from "../src/utils/guessFeedbackUtils"
import { TriviaItem } from "../src/models/trivia"

// Mock Data Helper
const createItem = (id: number, hints: any[]): TriviaItem => ({
  id,
  title: `Movie ${id}`,
  description: "Plot",
  posterPath: "/path.jpg",
  releaseDate: "2020-01-01",
  metadata: {},
  // Use provided label or fallback to type (lowercase)
  hints: hints.map((h) => ({
    type: h.type,
    label: h.label || h.type,
    value: h.value,
  })),
})

describe("Utils: guessFeedbackUtils", () => {
  describe("generateImplicitHint", () => {
    it("should return standard negative feedback if no matches found", () => {
      const correct = createItem(1, [{ type: "director", value: "Nolan" }])
      const guessed = createItem(2, [{ type: "director", value: "Spielberg" }])

      const result = generateImplicitHint(guessed, correct, {})

      expect(result.feedback).toBe("Not quite! Try again.")
      expect(result.revealedHints).toEqual({})
      expect(result.hintInfo).toBeNull()
    })

    it("should identify a match for simple string values (e.g. Director)", () => {
      // We explicitly provide the Label "Director" to match real app data structure
      const correct = createItem(1, [
        { type: "director", label: "Director", value: "Nolan" },
      ])
      const guessed = createItem(2, [
        { type: "director", label: "Director", value: "Nolan" },
      ])

      const result = generateImplicitHint(guessed, correct, {})

      // Updated expectation to match the actual output format
      expect(result.feedback).toContain(
        "You're on the right track with the Director!"
      )
      expect(result.feedback).toContain("(Hint Revealed)")
      expect(result.revealedHints).toEqual({ director: true })
      expect(result.hintInfo).toHaveLength(1)
      expect(result.hintInfo![0].value).toBe("Nolan")
    })

    it("should identify a match for array values (e.g. Actors)", () => {
      const actorA = { id: 10, name: "Tom Hanks" }
      const actorB = { id: 11, name: "Tim Allen" }
      const actorC = { id: 12, name: "Carrie Fisher" }

      const correct = createItem(1, [
        { type: "actors", label: "Actors", value: [actorA, actorB] },
      ])
      const guessed = createItem(2, [
        { type: "actors", label: "Actors", value: [actorA, actorC] },
      ]) // Match on ActorA

      const result = generateImplicitHint(guessed, correct, {})

      expect(result.feedback).toContain(
        "You're on the right track with the Actors!"
      )
      expect(result.feedback).toContain("(Hint Revealed)")
      expect(result.revealedHints).toEqual({ actors: true })
    })

    it("should return 'getting warmer' if hint was already revealed previously", () => {
      const correct = createItem(1, [{ type: "director", value: "Nolan" }])
      const guessed = createItem(2, [{ type: "director", value: "Nolan" }])

      // Pass in 'director: true' as already used
      const result = generateImplicitHint(guessed, correct, { director: true })

      expect(result.feedback).toBe("You're getting warmer! Keep guessing.")
      // Should not add new revealed hints since it was already known
      expect(result.revealedHints).toEqual({})
      // But hintInfo should still be returned for display
      expect(result.hintInfo).not.toBeNull()
    })

    it("should handle error cases gracefully", () => {
      // @ts-ignore
      const result = generateImplicitHint(null, null)
      expect(result.feedback).toContain("unexpected error")
    })
  })
})

================
File: __tests__/guessRow.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import { GuessRow } from "../src/components/guess/guessRow"
import { BasicTriviaItem } from "../src/models/trivia"
import { Guess } from "../src/models/game"

// Mock Animations
jest.mock("../src/utils/hooks/useGuessAnimation", () => ({
  useGuessAnimation: () => ({
    animatedTileStyle: {},
    animatedContentStyle: {},
    animatedFeedbackStyle: {},
  }),
}))

// Mock Reanimated
jest.mock("react-native-reanimated", () => {
  const { View, Text } = require("react-native")
  return {
    default: { View, Text },
    View: View,
    Text: Text,
  }
})

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("Guess Component: GuessRow", () => {
  const mockBasicItems: BasicTriviaItem[] = [
    // Use a mid-year date to avoid timezone rollovers (e.g. Jan 1st -> Dec 31st prev year)
    {
      id: 101,
      title: "Correct Movie",
      releaseDate: "2020-07-01",
      posterPath: "",
    },
    {
      id: 102,
      title: "Wrong Movie",
      releaseDate: "1999-05-05",
      posterPath: "",
    },
  ]

  const correctGuess: Guess = { itemId: 101, hintInfo: [] }
  const wrongGuess: Guess = {
    itemId: 102,
    hintInfo: [{ type: "director", label: "Director", value: "Nolan" }],
  }

  it("should render the movie title and year", () => {
    renderWithTheme(
      <GuessRow
        index={0}
        guess={correctGuess}
        basicItems={mockBasicItems}
        isLastGuess={false}
        lastGuessResult={null}
        correctItemId={101}
      />
    )

    expect(screen.getByText(/Correct Movie/)).toBeTruthy()
    // Should reliably match 2020 with a July date
    expect(screen.getByText(/2020/)).toBeTruthy()
  })

  it("should display hints found if implicit feedback is active", () => {
    renderWithTheme(
      <GuessRow
        index={1}
        guess={wrongGuess}
        basicItems={mockBasicItems}
        isLastGuess={false}
        lastGuessResult={null}
        correctItemId={101}
      />
    )

    expect(screen.getByText("Nolan")).toBeTruthy()
  })

  it("should display feedback overlay if it is the last guess and incorrect", () => {
    const feedbackMsg = "Getting Warmer!"
    const result = { itemId: 102, correct: false, feedback: feedbackMsg }

    renderWithTheme(
      <GuessRow
        index={1}
        guess={wrongGuess}
        basicItems={mockBasicItems}
        isLastGuess={true}
        lastGuessResult={result}
        correctItemId={101}
      />
    )

    expect(screen.getByText(feedbackMsg)).toBeTruthy()
  })
})

================
File: __tests__/hint.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import HintContainer from "../src/components/hint"
import { useGameStore } from "../src/state/gameStore"
import { useHintLogic } from "../src/utils/hooks/useHintLogic"
import { DEFAULT_DIFFICULTY } from "../src/config/difficulty"

// --- Mocks ---

// 1. Mock the child UI component to verify it receives correct props
jest.mock("../src/components/hintUI", () => {
  const { View } = require("react-native")
  return (props: any) => (
    <View
      testID="mock-hint-ui"
      // @ts-ignore - storing props for assertions
      data-label={props.hintLabelText}
      // @ts-ignore
      data-disabled={props.isToggleDisabled}
    />
  )
})

// 2. Mock the logic hook to control internal state behaviors
jest.mock("../src/utils/hooks/useHintLogic")
const mockUseHintLogic = useHintLogic as jest.Mock

// 3. Mock the Game Store
// We need to mock it as a function that also has a 'getState' method
jest.mock("../src/state/gameStore", () => {
  const mockStore = jest.fn()
  // @ts-ignore
  mockStore.getState = jest.fn()
  return { useGameStore: mockStore }
})
const mockUseGameStore = useGameStore as unknown as jest.Mock
const mockGetState = (useGameStore as any).getState as jest.Mock

// 4. Mock Animations to avoid Reanimated issues
jest.mock("../src/utils/hooks/useSkeletonAnimation", () => ({
  useSkeletonAnimation: () => ({ opacity: 1 }),
}))

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

// Default mock return values for the logic hook
const defaultLogicReturn = {
  showHintOptions: false,
  hintLabelText: "Need a Hint?",
  isToggleDisabled: false,
  hintStatuses: {},
  highlightedHint: null,
  handleToggleHintOptions: jest.fn(),
  handleHintSelection: jest.fn(),
  displayedHintText: null,
  allHints: [],
  getHintText: (type: string) => `Mock Value for ${type}`,
}

const setMockStoreState = (stateOverrides: any) => {
  const fullState = {
    loading: false,
    difficulty: DEFAULT_DIFFICULTY,
    isInteractionsDisabled: false,
    playerStats: {},
    ...stateOverrides,
  }

  // Mock the hook selector usage: useGameStore(selector)
  mockUseGameStore.mockImplementation((selector: any) => selector(fullState))

  // Mock the direct access usage: useGameStore.getState()
  mockGetState.mockReturnValue(fullState)
}

describe("HintContainer Component", () => {
  beforeEach(() => {
    jest.clearAllMocks()
    mockUseHintLogic.mockReturnValue(defaultLogicReturn)
  })

  describe("Loading State", () => {
    it("should render the HintSkeleton when loading is true", () => {
      setMockStoreState({
        loading: true,
        difficulty: "LEVEL_3",
      })

      renderWithTheme(<HintContainer />)

      // The skeleton renders a generic View container.
      // We verify that the main HintUI or BasicHints are NOT there.
      expect(screen.queryByTestId("mock-hint-ui")).toBeNull()
      expect(screen.queryByText("All Hints Revealed")).toBeNull()
    })
  })

  describe("Difficulty Strategy: NONE_DISABLED / EXTREME", () => {
    it("should return null (render nothing) for Hard difficulty (LEVEL_4)", () => {
      setMockStoreState({
        difficulty: "LEVEL_4", // Hard: NONE_DISABLED
      })

      const { toJSON } = renderWithTheme(<HintContainer />)
      expect(toJSON()).toBeNull()
    })

    it("should return null (render nothing) for Extreme difficulty (LEVEL_5)", () => {
      setMockStoreState({
        difficulty: "LEVEL_5", // Extreme: EXTREME_CHALLENGE
      })

      const { toJSON } = renderWithTheme(<HintContainer />)
      expect(toJSON()).toBeNull()
    })
  })

  describe("Difficulty Strategy: ALL_REVEALED / HINTS_ONLY", () => {
    it("should render BasicHints (static list) for Basic difficulty (LEVEL_1)", () => {
      setMockStoreState({
        difficulty: "LEVEL_1", // Basic: HINTS_ONLY_REVEALED
        isInteractionsDisabled: false, // Game is active
      })

      renderWithTheme(<HintContainer />)

      expect(screen.getByText("All Hints Revealed")).toBeTruthy()
      expect(screen.getByText("Decade:")).toBeTruthy()
      // Verify it calls getHintText from the hook
      expect(screen.getByText("Mock Value for decade")).toBeTruthy()
    })

    it("should NOT render BasicHints if interactions are disabled (Game Over)", () => {
      setMockStoreState({
        difficulty: "LEVEL_1",
        isInteractionsDisabled: true,
      })

      // We need the logic hook to return "Game Over" label for this scenario
      mockUseHintLogic.mockReturnValue({
        ...defaultLogicReturn,
        hintLabelText: "Game Over",
        isToggleDisabled: true,
      })

      renderWithTheme(<HintContainer />)

      expect(screen.queryByText("All Hints Revealed")).toBeNull()
      expect(screen.getByTestId("mock-hint-ui")).toBeTruthy()
    })
  })

  describe("Difficulty Strategy: IMPLICIT_FEEDBACK (Medium)", () => {
    it("should render a simple text label when toggle is NOT disabled", () => {
      setMockStoreState({
        difficulty: "LEVEL_3", // Medium: IMPLICIT_FEEDBACK
        isInteractionsDisabled: false,
        playerStats: { hintsAvailable: 3 },
      })

      mockUseHintLogic.mockReturnValue({
        ...defaultLogicReturn,
        hintLabelText: "Hints are revealed by successful guesses!",
        isToggleDisabled: false, // Key condition
      })

      renderWithTheme(<HintContainer />)

      // Should see the text
      expect(
        screen.getByText("Hints are revealed by successful guesses!")
      ).toBeTruthy()
      // Should NOT render the complex HintUI
      expect(screen.queryByTestId("mock-hint-ui")).toBeNull()
    })

    it("should render HintUI when toggle IS disabled (e.g., Game Over)", () => {
      setMockStoreState({
        difficulty: "LEVEL_3",
        isInteractionsDisabled: true,
      })

      mockUseHintLogic.mockReturnValue({
        ...defaultLogicReturn,
        hintLabelText: "Game Over",
        isToggleDisabled: true,
      })

      renderWithTheme(<HintContainer />)

      // Should fall through to HintUI
      expect(screen.getByTestId("mock-hint-ui")).toBeTruthy()
    })
  })

  describe("Difficulty Strategy: USER_SPEND (Easy)", () => {
    it("should render HintUI for Easy difficulty (LEVEL_2)", () => {
      setMockStoreState({
        difficulty: "LEVEL_2", // Easy: USER_SPEND
        isInteractionsDisabled: false,
        playerStats: { hintsAvailable: 3 },
      })

      renderWithTheme(<HintContainer />)

      const hintUI = screen.getByTestId("mock-hint-ui")
      expect(hintUI).toBeTruthy()
      // Verify props passed to HintUI via the mocked hook values
      expect(hintUI.props["data-label"]).toBe("Need a Hint?")
      expect(hintUI.props["data-disabled"]).toBe(false)
    })

    it("should render null if HintUI has no label text (e.g., out of hints)", () => {
      setMockStoreState({
        difficulty: "LEVEL_2",
        isInteractionsDisabled: false,
      })

      // Simulate logic returning empty label (e.g., no hints left)
      mockUseHintLogic.mockReturnValue({
        ...defaultLogicReturn,
        hintLabelText: "",
      })

      const { toJSON } = renderWithTheme(<HintContainer />)
      expect(toJSON()).toBeNull()
    })
  })
})

================
File: __tests__/hintButton.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  fireEvent,
  screen,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import HintButton from "../src/components/hintButton"

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("HintButton Component", () => {
  const mockOnPress = jest.fn()

  beforeEach(() => {
    mockOnPress.mockClear()
  })

  describe("Rendering and States", () => {
    it("should render correctly in 'available' state", () => {
      renderWithTheme(
        <HintButton
          hintType="director"
          iconName="film-outline"
          label="Director"
          onPress={mockOnPress}
          status="available"
          accessibilityHintCount={3}
          isHighlighted={false}
        />
      )

      const button = screen.getByRole("button")
      expect(button).toBeTruthy()
      expect(screen.getByText("Director")).toBeTruthy()
      expect(button.props.accessibilityState.disabled).toBe(false)
      expect(button.props.accessibilityLabel).toContain("3 hints available")
    })

    it("should render correctly in 'disabled' state", () => {
      renderWithTheme(
        <HintButton
          hintType="genre"
          iconName="folder-open-outline"
          label="Genre"
          onPress={mockOnPress}
          status="disabled"
          accessibilityHintCount={0}
          isHighlighted={false}
        />
      )

      const button = screen.getByRole("button")
      // Check for visual disabled prop/style (opacity usually handled by style)
      expect(button.props.accessibilityState.disabled).toBe(true)
      expect(button.props.accessibilityLabel).toBe("Genre hint unavailable.")
    })

    it("should render correctly in 'used' state", () => {
      renderWithTheme(
        <HintButton
          hintType="year"
          iconName="calendar-outline"
          label="Year"
          onPress={mockOnPress}
          status="used"
          accessibilityHintCount={2}
          isHighlighted={false}
        />
      )

      const button = screen.getByRole("button")
      expect(button.props.accessibilityLabel).toBe("Re-view the year hint.")
    })
  })

  describe("Interaction", () => {
    it("should call onPress with hintType when pressed", () => {
      renderWithTheme(
        <HintButton
          hintType="director"
          iconName="film-outline"
          label="Director"
          onPress={mockOnPress}
          status="available"
          accessibilityHintCount={3}
          isHighlighted={false}
        />
      )

      fireEvent.press(screen.getByRole("button"))
      expect(mockOnPress).toHaveBeenCalledWith("director")
    })

    it("should NOT call onPress when disabled", () => {
      renderWithTheme(
        <HintButton
          hintType="director"
          iconName="film-outline"
          label="Director"
          onPress={mockOnPress}
          status="disabled"
          accessibilityHintCount={0}
          isHighlighted={false}
        />
      )

      fireEvent.press(screen.getByRole("button"))
      expect(mockOnPress).not.toHaveBeenCalled()
    })
  })
})

================
File: __tests__/hintUI.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  fireEvent,
  screen,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import HintUI from "../src/components/hintUI"
import { Hint } from "../src/models/trivia"

// --- Mocks ---
jest.mock("../src/components/hintButton", () => {
  const { View } = require("react-native")
  return (props: any) => (
    <View
      testID={`mock-hint-button-${props.hintType}`}
      // @ts-ignore
      data-label={props.label}
      // @ts-ignore
      data-status={props.status}
    />
  )
})

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

// --- Mock Data ---
const mockHints: Hint[] = [
  { type: "director", label: "Director", value: "Spielberg" },
  { type: "genre", label: "Genre", value: "Action" },
]

const mockHintStatuses = {
  director: "available",
  genre: "disabled",
} as const

describe("HintUI Component", () => {
  const mockHandleToggle = jest.fn()
  const mockHandleSelection = jest.fn()

  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe("Rendering", () => {
    it("should render the toggle label", () => {
      renderWithTheme(
        <HintUI
          showHintOptions={false}
          displayedHintText={null}
          hintLabelText="Need a Hint?"
          isToggleDisabled={false}
          hintsAvailable={3}
          hintStatuses={mockHintStatuses}
          highlightedHint={null}
          handleToggleHintOptions={mockHandleToggle}
          handleHintSelection={mockHandleSelection}
          allHints={mockHints}
        />
      )

      expect(screen.getByText("Need a Hint?")).toBeTruthy()
    })

    it("should render the correct number of HintButtons based on allHints prop", () => {
      renderWithTheme(
        <HintUI
          showHintOptions={true}
          displayedHintText={null}
          hintLabelText="Toggle Hints"
          isToggleDisabled={false}
          hintsAvailable={3}
          hintStatuses={mockHintStatuses}
          highlightedHint={null}
          handleToggleHintOptions={mockHandleToggle}
          handleHintSelection={mockHandleSelection}
          allHints={mockHints}
        />
      )

      expect(screen.getByTestId("mock-hint-button-director")).toBeTruthy()
      expect(screen.getByTestId("mock-hint-button-genre")).toBeTruthy()
    })

    it("should display the hint text when provided", () => {
      const hintText = "This is the hint text."
      renderWithTheme(
        <HintUI
          showHintOptions={false}
          displayedHintText={hintText}
          hintLabelText="Toggle Hints"
          isToggleDisabled={false}
          hintsAvailable={2}
          hintStatuses={mockHintStatuses}
          highlightedHint={null}
          handleToggleHintOptions={mockHandleToggle}
          handleHintSelection={mockHandleSelection}
          allHints={mockHints}
        />
      )

      expect(screen.getByText(hintText)).toBeTruthy()
    })
  })

  describe("Interactions", () => {
    it("should call handleToggleHintOptions when label is pressed", () => {
      renderWithTheme(
        <HintUI
          showHintOptions={false}
          displayedHintText={null}
          hintLabelText="Click Me"
          isToggleDisabled={false}
          hintsAvailable={3}
          hintStatuses={mockHintStatuses}
          highlightedHint={null}
          handleToggleHintOptions={mockHandleToggle}
          handleHintSelection={mockHandleSelection}
          allHints={mockHints}
        />
      )

      fireEvent.press(screen.getByText("Click Me"))
      expect(mockHandleToggle).toHaveBeenCalledTimes(1)
    })

    it("should disable the toggle press when isToggleDisabled is true", () => {
      renderWithTheme(
        <HintUI
          showHintOptions={false}
          displayedHintText={null}
          hintLabelText="Disabled Label"
          isToggleDisabled={true}
          hintsAvailable={0}
          hintStatuses={mockHintStatuses}
          highlightedHint={null}
          handleToggleHintOptions={mockHandleToggle}
          handleHintSelection={mockHandleSelection}
          allHints={mockHints}
        />
      )

      fireEvent.press(screen.getByText("Disabled Label"))
      expect(mockHandleToggle).not.toHaveBeenCalled()
    })
  })
})

================
File: __tests__/historyDetailModal.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  waitFor,
  fireEvent,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import HistoryDetailModal from "../src/components/historyDetailModal"
import { useAuth } from "../src/contexts/authContext"
import { gameService } from "../src/services/gameService"
import { getGameDataService } from "../src/services/gameServiceFactory"
import { GameHistoryEntry } from "../src/models/gameHistory"
import { defaultPlayerGame, defaultTriviaItem } from "../src/models/default"
import { PlayerGame } from "../src/models/game"
import { TriviaItem } from "../src/models/trivia"

// --- Mocks ---

// 1. Mock Contexts and Services
jest.mock("../src/contexts/authContext")
jest.mock("../src/services/gameService")
jest.mock("../src/services/gameServiceFactory")

// 2. Mock React.lazy
// We override lazy to bypass the dynamic import and just render the component.
// Crucially, we define the mock logic entirely inside the factory.
jest.mock("react", () => {
  const React = jest.requireActual("react")
  return {
    ...React,
    lazy: (factory: any) => {
      // We return a functional component that renders a placeholder View.
      // We can determine WHICH component this is by checking the props passed to it
      // during render. This is a workaround for not being able to see the factory URL.
      const LazyComponent = (props: any) => {
        // Need to require react-native here because we are inside the factory scope
        const { View, Text, Pressable } = require("react-native")

        // Heuristic to identify DetailModal
        if (props.toggleModal) {
          return props.show ? (
            <View testID="mock-detail-modal">
              <Pressable onPress={() => props.toggleModal(false)}>
                <Text>Close</Text>
              </Pressable>
              {props.children}
            </View>
          ) : null
        }

        // Heuristic to identify Facts
        if (props.item && props.item.title) {
          return <View testID="mock-facts" data-title={props.item.title} />
        }

        // Heuristic to identify GuessesContainer
        if (props.gameForDisplay || props.lastGuessResult !== undefined) {
          const count = props.gameForDisplay?.guesses?.length ?? 0
          return <View testID="mock-guesses" data-guesses-count={count} />
        }

        return <View testID="unknown-lazy-component" />
      }
      return LazyComponent
    },
    Suspense: ({ children }: any) => children,
  }
})

// --- Helper Types & Data ---
const mockUseAuth = useAuth as jest.Mock
const mockGameService = gameService as jest.Mocked<typeof gameService>
const mockGetGameDataService = getGameDataService as jest.Mock

const mockHistoryItem: GameHistoryEntry = {
  dateId: "2023-01-01",
  itemId: 123,
  itemTitle: "Mock Movie",
  posterPath: "/mock.jpg",
  wasCorrect: true,
  gaveUp: false,
  guessCount: 3,
  guessesMax: 5,
  difficulty: "LEVEL_3",
  score: 500,
  gameMode: "movies",
}

const mockTriviaItem: TriviaItem = {
  ...defaultTriviaItem,
  id: 123,
  title: "Mock Movie Full",
  description: "A mock description",
}

const mockPlayerGame: PlayerGame = {
  ...defaultPlayerGame,
  id: "player-1-2023-01-01",
  guesses: [
    { itemId: 1, hintInfo: [] },
    { itemId: 123, hintInfo: [] },
  ],
}

// Mock Data Service Implementation
const mockDataService = {
  getItemById: jest.fn(),
  getDailyTriviaItemAndLists: jest.fn(),
}

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("HistoryDetailModal Component", () => {
  const onCloseMock = jest.fn()

  beforeEach(() => {
    jest.clearAllMocks()

    // Default auth state: logged in
    mockUseAuth.mockReturnValue({ player: { id: "player-1" } })

    // Default service factory return
    mockGetGameDataService.mockReturnValue(mockDataService)

    // Default data resolves
    mockDataService.getItemById.mockResolvedValue(mockTriviaItem)
    mockGameService.fetchPlayerGameById.mockResolvedValue(mockPlayerGame)
    mockDataService.getDailyTriviaItemAndLists.mockResolvedValue({
      basicItems: [],
    })
  })

  describe("Visibility and Initialization", () => {
    it("should render nothing if historyItem is null", async () => {
      renderWithTheme(
        <HistoryDetailModal historyItem={null} onClose={onCloseMock} />
      )
      expect(screen.queryByTestId("mock-detail-modal")).toBeNull()
    })

    it("should render the modal but NO content if player is null (not logged in)", async () => {
      mockUseAuth.mockReturnValue({ player: null })
      renderWithTheme(
        <HistoryDetailModal
          historyItem={mockHistoryItem}
          onClose={onCloseMock}
        />
      )

      // The modal wrapper should be present because historyItem is not null
      await waitFor(() => {
        expect(screen.getByTestId("mock-detail-modal")).toBeTruthy()
      })

      // BUT the content fetching should not have triggered, so no Facts or Guesses
      expect(screen.queryByTestId("mock-facts")).toBeNull()
      expect(screen.queryByTestId("mock-guesses")).toBeNull()
    })

    it("should call services with correct IDs when mounted", async () => {
      renderWithTheme(
        <HistoryDetailModal
          historyItem={mockHistoryItem}
          onClose={onCloseMock}
        />
      )

      await waitFor(() => {
        expect(mockGetGameDataService).toHaveBeenCalledWith("movies")
        expect(mockDataService.getItemById).toHaveBeenCalledWith(123)
        expect(mockGameService.fetchPlayerGameById).toHaveBeenCalledWith(
          "player-1-2023-01-01"
        )
      })
    })
  })

  describe("Data Loading and Display", () => {
    it("should show error message if data fetch fails", async () => {
      const consoleSpy = jest
        .spyOn(console, "error")
        .mockImplementation(() => {})

      mockDataService.getItemById.mockRejectedValue(new Error("Network Error"))

      renderWithTheme(
        <HistoryDetailModal
          historyItem={mockHistoryItem}
          onClose={onCloseMock}
        />
      )

      await waitFor(() => {
        expect(screen.getByText("Network Error")).toBeTruthy()
      })

      consoleSpy.mockRestore()
    })

    it("should render Facts and Guesses when data loads successfully", async () => {
      renderWithTheme(
        <HistoryDetailModal
          historyItem={mockHistoryItem}
          onClose={onCloseMock}
        />
      )

      // Wait for the suspense fallback to resolve and content to appear
      await waitFor(() => {
        expect(screen.getByTestId("mock-facts")).toBeTruthy()
        expect(screen.getByTestId("mock-guesses")).toBeTruthy()
      })

      // Verify props passed to children via our lazy mock attributes
      const facts = screen.getByTestId("mock-facts")
      const guesses = screen.getByTestId("mock-guesses")

      // @ts-ignore
      expect(facts.props["data-title"]).toBe("Mock Movie Full")
      // @ts-ignore - we mocked guesses length is 2 in mockPlayerGame
      expect(guesses.props["data-guesses-count"]).toBe(2)
    })
  })

  describe("Interaction", () => {
    it("should call onClose when DetailModal close is triggered", async () => {
      renderWithTheme(
        <HistoryDetailModal
          historyItem={mockHistoryItem}
          onClose={onCloseMock}
        />
      )

      // Wait for modal to appear
      await waitFor(() => screen.getByTestId("mock-detail-modal"))

      // Mock DetailModal renders a "Close" text inside a Pressable that calls toggleModal(false)
      fireEvent.press(screen.getByText("Close"))

      expect(onCloseMock).toHaveBeenCalledTimes(1)
    })
  })
})

================
File: __tests__/loadingIndicator.test.tsx
================
import React, { ReactElement } from "react"
import { Platform } from "react-native"
import {
  render,
  screen,
  cleanup,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import LoadingIndicator from "../src/components/loadingIndicator"
import Constants from "expo-constants"

// --- Mocks ---

// 1. Mock the child CustomLoadingIndicator to inspect the 'isLowEndDevice' prop
jest.mock("../src/components/customLoadingIndicator", () => {
  const { View } = require("react-native")
  return (props: any) => (
    <View
      testID="mock-custom-indicator"
      // @ts-ignore - passing data for test verification
      data-low-end={props.isLowEndDevice}
    />
  )
})

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("LoadingIndicator Component", () => {
  const originalPlatformOS = Platform.OS

  // Reset Platform and Constants after each test
  afterEach(() => {
    cleanup()
    Object.defineProperty(Platform, "OS", {
      get: () => originalPlatformOS,
    })
    // @ts-ignore
    Constants.deviceYearClass = 2020 // Reset to a safe default
  })

  describe("Rendering Content", () => {
    it("should render the container and custom indicator", () => {
      renderWithTheme(<LoadingIndicator />)
      expect(screen.getByTestId("loading-indicator-container")).toBeTruthy()
      expect(screen.getByTestId("mock-custom-indicator")).toBeTruthy()
    })

    it("should render the message text when provided", () => {
      const testMessage = "Please wait, loading data..."
      renderWithTheme(<LoadingIndicator message={testMessage} />)
      expect(screen.getByText(testMessage)).toBeTruthy()
    })

    it("should NOT render text component if message is undefined", () => {
      renderWithTheme(<LoadingIndicator />)
      // The component structure is: View -> [CustomIndicator, (Optional Text)]
      // We grab the container and check its children.
      const container = screen.getByTestId("loading-indicator-container")

      // React Native testing library often flattens children or represents them differently.
      // If the text element isn't rendered, querying for any text will fail, which is what we want.
      // But we can't query for "empty text".
      // A safe check is that only one child testID exists.

      // We assume success if no text node is found.
      expect(screen.queryByText(/.+/)).toBeNull()
    })
  })

  describe("Device Capability Logic", () => {
    // Logic in component:
    // threshold = 2018
    // requiredClass = 2018 - 2011 = 7
    // isLowEnd = deviceYearClass < 7

    it("should set isLowEndDevice to false on Web regardless of year class", () => {
      Object.defineProperty(Platform, "OS", { get: () => "web" })
      // @ts-ignore - force a low number
      Constants.deviceYearClass = 1

      renderWithTheme(<LoadingIndicator />)

      const indicator = screen.getByTestId("mock-custom-indicator")
      // @ts-ignore
      expect(indicator.props["data-low-end"]).toBe(false)
    })

    it("should set isLowEndDevice to true if deviceYearClass is low (e.g. < 7)", () => {
      Object.defineProperty(Platform, "OS", { get: () => "ios" })
      // @ts-ignore
      Constants.deviceYearClass = 6 // 6 < 7

      renderWithTheme(<LoadingIndicator />)

      const indicator = screen.getByTestId("mock-custom-indicator")
      // @ts-ignore
      expect(indicator.props["data-low-end"]).toBe(true)
    })

    it("should set isLowEndDevice to false if deviceYearClass is high (e.g. >= 7)", () => {
      Object.defineProperty(Platform, "OS", { get: () => "android" })
      // @ts-ignore
      Constants.deviceYearClass = 2020 // 2020 >= 7

      renderWithTheme(<LoadingIndicator />)

      const indicator = screen.getByTestId("mock-custom-indicator")
      // @ts-ignore
      expect(indicator.props["data-low-end"]).toBe(false)
    })

    it("should set isLowEndDevice to false if deviceYearClass is null/undefined", () => {
      Object.defineProperty(Platform, "OS", { get: () => "ios" })
      // @ts-ignore
      Constants.deviceYearClass = null

      renderWithTheme(<LoadingIndicator />)

      const indicator = screen.getByTestId("mock-custom-indicator")
      // @ts-ignore
      expect(indicator.props["data-low-end"]).toBe(false)
    })
  })
})

================
File: __tests__/network.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import NetworkContainer from "../src/components/network"

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("NetworkContainer Component", () => {
  describe("Connection States", () => {
    it("should NOT render anything when isConnected is true", () => {
      renderWithTheme(<NetworkContainer isConnected={true} />)

      // The component returns null, so querying for the text should fail
      expect(screen.queryByText("Network is not connected")).toBeNull()
    })

    it("should render the warning banner when isConnected is false", () => {
      renderWithTheme(<NetworkContainer isConnected={false} />)

      // The warning text should now be visible
      expect(screen.getByText("Network is not connected")).toBeTruthy()
    })
  })
})

================
File: __tests__/networkContest.test.tsx
================
import React from "react"
import { View, Text } from "react-native"
import { render, waitFor, screen, act } from "@testing-library/react-native"
import { NetworkProvider, useNetwork } from "../src/contexts/networkContext"
import * as Network from "expo-network"
import { analyticsService } from "../src/utils/analyticsService"

// Mocks
jest.mock("expo-network", () => ({
  getNetworkStateAsync: jest.fn(),
  addNetworkStateListener: jest.fn(),
}))
jest.mock("../src/utils/analyticsService")

// Helper Component to consume the context
const TestComponent = () => {
  const { isNetworkConnected } = useNetwork()
  return (
    <View>
      <Text testID="status">
        {isNetworkConnected === null
          ? "Unknown"
          : isNetworkConnected
          ? "Connected"
          : "Disconnected"}
      </Text>
    </View>
  )
}

describe("Context: NetworkContext", () => {
  let listenerCallback: ((state: Network.NetworkState) => void) | null = null

  beforeEach(() => {
    jest.clearAllMocks()
    // Setup default listener mock
    ;(Network.addNetworkStateListener as jest.Mock).mockImplementation((cb) => {
      listenerCallback = cb
      return { remove: jest.fn() }
    })
  })

  it("should initialize with the current network state", async () => {
    // Mock initial state: Connected
    ;(Network.getNetworkStateAsync as jest.Mock).mockResolvedValue({
      isInternetReachable: true,
    })

    render(
      <NetworkProvider>
        <TestComponent />
      </NetworkProvider>
    )

    // Should eventually show Connected
    await waitFor(() => {
      expect(screen.getByTestId("status").children[0]).toBe("Connected")
    })

    expect(analyticsService.trackNetworkStatusChange).toHaveBeenCalledWith(true)
  })

  it("should handle initial network failure (offline)", async () => {
    // Mock initial state: Disconnected (false)
    ;(Network.getNetworkStateAsync as jest.Mock).mockResolvedValue({
      isInternetReachable: false,
    })

    render(
      <NetworkProvider>
        <TestComponent />
      </NetworkProvider>
    )

    await waitFor(() => {
      expect(screen.getByTestId("status").children[0]).toBe("Disconnected")
    })
  })

  it("should handle errors during initialization", async () => {
    // Mock failure
    const consoleSpy = jest.spyOn(console, "error").mockImplementation(() => {})
    ;(Network.getNetworkStateAsync as jest.Mock).mockRejectedValue(
      new Error("Network error")
    )

    render(
      <NetworkProvider>
        <TestComponent />
      </NetworkProvider>
    )

    // Should default to false (Disconnected) on error as per implementation
    await waitFor(() => {
      expect(screen.getByTestId("status").children[0]).toBe("Disconnected")
    })

    consoleSpy.mockRestore()
  })

  it("should update state when network listener fires", async () => {
    ;(Network.getNetworkStateAsync as jest.Mock).mockResolvedValue({
      isInternetReachable: true,
    })

    render(
      <NetworkProvider>
        <TestComponent />
      </NetworkProvider>
    )

    await waitFor(() => screen.getByText("Connected"))

    // Simulate disconnection
    expect(listenerCallback).toBeDefined()
    act(() => {
      // @ts-ignore
      listenerCallback({ isInternetReachable: false })
    })

    await waitFor(() => {
      expect(screen.getByTestId("status").children[0]).toBe("Disconnected")
    })

    expect(analyticsService.trackNetworkStatusChange).toHaveBeenCalledWith(
      false
    )
  })

  it("should throw error if useNetwork is used outside of provider", () => {
    // Suppress React console error for boundary test
    const consoleSpy = jest.spyOn(console, "error").mockImplementation(() => {})

    const BadComponent = () => {
      useNetwork()
      return null
    }

    expect(() => render(<BadComponent />)).toThrow(
      "useNetwork must be used within a NetworkProvider"
    )

    consoleSpy.mockRestore()
  })
})

================
File: __tests__/personalizedStatsMessage.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  waitFor,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import PersonalizedStatsMessage from "../src/components/personalizedStatsMessage"
import { useAuth } from "../src/contexts/authContext"
import { useGameStore } from "../src/state/gameStore"
import { gameService } from "../src/services/gameService"
import { defaultPlayerGame, defaultPlayerStats } from "../src/models/default"

// --- Mocks ---
jest.mock("../src/contexts/authContext")
jest.mock("../src/state/gameStore")
jest.mock("../src/services/gameService")

// --- Helper Data ---
const mockPlayer = { id: "player-1" }
const mockHistory = [
  { wasCorrect: true, dateId: "1" },
  { wasCorrect: true, dateId: "2" },
  { wasCorrect: false, dateId: "3" },
  { wasCorrect: true, dateId: "4" },
  { wasCorrect: true, dateId: "5" },
  { wasCorrect: false, dateId: "6" },
  { wasCorrect: true, dateId: "7" },
] // 5 wins out of 7

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

const mockUseAuth = useAuth as jest.Mock
const mockUseGameStore = useGameStore as unknown as jest.Mock
const mockGameService = gameService as jest.Mocked<typeof gameService>

const setMockStoreState = (overrides: any) => {
  const state = {
    playerStats: { ...defaultPlayerStats, ...overrides.playerStats },
    playerGame: { ...defaultPlayerGame, ...overrides.playerGame },
  }
  mockUseGameStore.mockImplementation((selector: any) => selector(state))
}

describe("PersonalizedStatsMessage Component", () => {
  beforeEach(() => {
    jest.clearAllMocks()
    mockUseAuth.mockReturnValue({ player: mockPlayer })
    mockGameService.fetchGameHistory.mockResolvedValue([])
  })

  describe("Loading and Empty States", () => {
    it("should render nothing while loading or if player/stats are missing", async () => {
      setMockStoreState({ playerStats: null })

      // Initially loading, so should be null
      const { toJSON } = renderWithTheme(<PersonalizedStatsMessage />)
      // We can't check loading state easily as it's internal useState(true)
      // But if stats are missing even after load, it returns null.

      await waitFor(() => {
        // After effect runs, loading is false. But stats are null.
        // Expect no message container.
        expect(screen.queryByText(/./)).toBeNull()
      })
    })
  })

  describe("Winning Scenarios", () => {
    it("should show 'New high streak' message if current streak matches max streak (>1)", async () => {
      setMockStoreState({
        playerGame: { correctAnswer: true, guesses: [{}, {}] },
        playerStats: { currentStreak: 5, maxStreak: 5 },
      })

      renderWithTheme(<PersonalizedStatsMessage />)

      await waitFor(() => {
        expect(
          screen.getByText(/New high streak: 5 wins in a row!/i)
        ).toBeTruthy()
      })
    })

    it("should show 'winning streak' message if current streak >= 3 (and not new high)", async () => {
      setMockStoreState({
        playerGame: { correctAnswer: true, guesses: [{}, {}] },
        playerStats: { currentStreak: 4, maxStreak: 10 },
      })

      renderWithTheme(<PersonalizedStatsMessage />)

      await waitFor(() => {
        expect(
          screen.getByText(/You're on a 4-day winning streak!/i)
        ).toBeTruthy()
      })
    })

    it("should show 'perfect score' message if guessed in 1 try", async () => {
      setMockStoreState({
        playerGame: { correctAnswer: true, guesses: [{}] }, // 1 guess
        playerStats: { currentStreak: 1, maxStreak: 10 },
      })

      renderWithTheme(<PersonalizedStatsMessage />)

      await waitFor(() => {
        expect(
          screen.getByText(/A perfect score! Guessed on the first try!/i)
        ).toBeTruthy()
      })
    })
  })

  describe("Losing Scenarios", () => {
    it("should show 'amazing streak' consolation if streak was broken (>3)", async () => {
      setMockStoreState({
        playerGame: { correctAnswer: false },
        playerStats: { currentStreak: 4 }, // Streak that just ended?
        // Note: The component logic reads `playerStats.currentStreak`.
        // If the game just ended in a loss, `_processGameOver` usually resets currentStreak to 0.
        // However, `PersonalizedStatsMessage` might be reading the stats *before* reset or logic assumes
        // `currentStreak` is the *previous* streak in this context?
        // Let's check source: `if (!playerGame.correctAnswer && playerStats.currentStreak > 3)`
        // This implies the stats passed in still have the streak, OR it's interpreting it as "you *had* a streak".
        // If `_processGameOver` sets streak to 0 on loss, this condition `currentStreak > 3` would fail.
        //
        // Looking at `gameStore.ts`, `_processGameOver` sets `draft.currentStreak = 0` on loss.
        // So `playerStats` in store will have 0.
        // This suggests `PersonalizedStatsMessage` might never show this message if it relies on the *updated* store state.
        // Unless `playerStats` hasn't updated yet? But `GameOverView` shows *after* processing.
        //
        // Potential Bug in Source Logic?
        // If `playerStats.currentStreak` is 0, the condition `> 3` is false.
        // We will test assuming the component logic is what we are testing, even if it might be unreachable in real app flow without delayed updates.
      })

      // Manually forcing a state that satisfies the condition to verify the component's rendering logic.
      setMockStoreState({
        playerGame: { correctAnswer: false },
        playerStats: { currentStreak: 4 },
      })

      renderWithTheme(<PersonalizedStatsMessage />)

      await waitFor(() => {
        expect(
          screen.getByText(/You had an amazing 4-day streak./i)
        ).toBeTruthy()
      })
    })
  })

  describe("History Analysis Scenarios", () => {
    it("should show win rate if history > 5 items", async () => {
      setMockStoreState({
        playerGame: { correctAnswer: false },
        playerStats: { currentStreak: 0 },
      })
      // @ts-ignore
      mockGameService.fetchGameHistory.mockResolvedValue(mockHistory)

      renderWithTheme(<PersonalizedStatsMessage />)

      await waitFor(() => {
        // 5 wins out of 7 items = ~71%
        expect(
          screen.getByText(/Your win rate over the last 7 days is 71%./i)
        ).toBeTruthy()
      })
    })

    it("should show default message if no other conditions met", async () => {
      setMockStoreState({
        playerGame: { correctAnswer: false },
        playerStats: { currentStreak: 0 },
      })
      mockGameService.fetchGameHistory.mockResolvedValue([]) // No history

      renderWithTheme(<PersonalizedStatsMessage />)

      await waitFor(() => {
        expect(
          screen.getByText(/Come back tomorrow for another movie!/i)
        ).toBeTruthy()
      })
    })
  })
})

================
File: __tests__/picker.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  fireEvent,
  act,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import PickerContainer from "../src/components/picker"
import { useGameStore } from "../src/state/gameStore"
import { hapticsService } from "../src/utils/hapticsService"
import { search } from "fast-fuzzy"
import { BasicTriviaItem, TriviaItem } from "../src/models/trivia"

// --- Mocks ---

// 1. Mock `fast-fuzzy` to control search results
jest.mock("fast-fuzzy", () => ({
  search: jest.fn(),
}))

// 2. Mock `hapticsService`
jest.mock("../src/utils/hapticsService", () => ({
  hapticsService: {
    light: jest.fn(),
    medium: jest.fn(),
    heavy: jest.fn(),
  },
}))

// 3. Mock `useGameStore` and `zustand/react/shallow`
jest.mock("../src/state/gameStore")
jest.mock("zustand/react/shallow", () => ({
  useShallow: (fn: any) => fn,
}))

// 4. Mock Child Components to expose event handlers
// This allows us to trigger the container's logic via props passed to children.

// Mock PickerUI: Renders an input to drive query, and a list to drive item rendering
jest.mock("../src/components/pickerUI", () => {
  const { View, TextInput } = require("react-native")
  return {
    PickerUI: ({
      handleInputChange,
      renderItem,
      results,
      query,
      placeholder,
    }: any) => (
      <View testID="mock-picker-ui">
        <TextInput
          testID="mock-input"
          value={query}
          onChangeText={handleInputChange}
          placeholder={placeholder}
        />
        {/* We manually render the list items using the container's renderItem prop */}
        {results &&
          results.map((item: any, index: number) => (
            <View key={item.id}>{renderItem({ item, index })}</View>
          ))}
      </View>
    ),
  }
})

// Mock PickerItem: Renders pressables to drive selection logic
jest.mock("../src/components/pickerItem", () => {
  const { View, Text, Pressable } = require("react-native")
  return (props: any) => (
    <Pressable
      testID={`picker-item-${props.item.id}`}
      onPress={() => props.onSelect(props.item)}
      onLongPress={() => props.onLongPress(props.item)}
    >
      <Text>{props.item.title}</Text>
      {props.isExpanded && <Text>EXPANDED_DETAILS</Text>}
      {props.isDisabled && <Text>DISABLED</Text>}
    </Pressable>
  )
})

// Mock PickerSkeleton
jest.mock("../src/components/pickerSkeleton", () => {
  const { View } = require("react-native")
  return () => <View testID="mock-picker-skeleton" />
})

// Mock TutorialTooltip
jest.mock("../src/components/tutorialTooltip", () => {
  const { View, Text } = require("react-native")
  return ({ isVisible, text }: any) =>
    isVisible ? <Text testID="mock-tooltip">{text}</Text> : null
})

// --- Test Data ---
const mockBasicItems: BasicTriviaItem[] = [
  {
    id: 1,
    title: "Inception",
    releaseDate: "2010",
    posterPath: "/inception.jpg",
  },
  {
    id: 2,
    title: "Interstellar",
    release_date: "2014",
    poster_path: "/interstellar.jpg",
  } as any, // casting for mismatch prop names in some mocks
]

const mockFullItems: TriviaItem[] = [
  {
    id: 1,
    title: "Inception",
    description: "Dreams...",
    posterPath: "/inception.jpg",
    releaseDate: "2010",
    metadata: {},
    hints: [],
  },
]

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

const mockUseGameStore = useGameStore as unknown as jest.Mock
const mockMakeGuess = jest.fn()
const mockDismissGuessInputTip = jest.fn()

const defaultStoreState = {
  isInteractionsDisabled: false,
  basicItems: mockBasicItems,
  fullItems: mockFullItems,
  makeGuess: mockMakeGuess,
  loading: false,
  tutorialState: { showGuessInputTip: false, showResultsTip: false },
  dismissGuessInputTip: mockDismissGuessInputTip,
  dismissResultsTip: jest.fn(),
  gameMode: "movies",
}

describe("PickerContainer Component", () => {
  beforeEach(() => {
    jest.clearAllMocks()
    jest.useFakeTimers()
    mockUseGameStore.mockImplementation((selector: any) =>
      selector(defaultStoreState)
    )
    // Default search behavior: return everything if query matches nothing specific in mock
    ;(search as jest.Mock).mockReturnValue([])
  })

  afterEach(() => {
    jest.useRealTimers()
  })

  describe("Rendering", () => {
    it("should render Skeleton when loading is true", () => {
      mockUseGameStore.mockImplementation((selector: any) =>
        selector({ ...defaultStoreState, loading: true })
      )
      renderWithTheme(<PickerContainer />)
      expect(screen.getByTestId("mock-picker-skeleton")).toBeTruthy()
      expect(screen.queryByTestId("mock-picker-ui")).toBeNull()
    })

    it("should render PickerUI when loading is false", () => {
      renderWithTheme(<PickerContainer />)
      expect(screen.getByTestId("mock-picker-ui")).toBeTruthy()
      // Check if placeholder text is passed correctly based on game mode
      expect(
        screen.getByPlaceholderText("Search for a movie title...")
      ).toBeTruthy()
    })

    it("should show tutorial tooltip if enabled in state", () => {
      mockUseGameStore.mockImplementation((selector: any) =>
        selector({
          ...defaultStoreState,
          tutorialState: { showGuessInputTip: true },
        })
      )
      renderWithTheme(<PickerContainer />)
      expect(screen.getByTestId("mock-tooltip")).toBeTruthy()
    })
  })

  describe("Search Logic", () => {
    it("should debounce search input and update results", () => {
      // Setup mock search result
      ;(search as jest.Mock).mockReturnValue([mockBasicItems[0]])

      renderWithTheme(<PickerContainer />)

      const input = screen.getByTestId("mock-input")
      fireEvent.changeText(input, "Incep")

      // Should not have searched yet (debounce)
      expect(search).not.toHaveBeenCalled()

      // Advance timers
      act(() => {
        jest.advanceTimersByTime(300)
      })

      // Now search should have been called
      expect(search).toHaveBeenCalledWith(
        "Incep",
        mockBasicItems,
        expect.anything()
      )
      expect(hapticsService.light).toHaveBeenCalled() // Haptic on result found

      // Verify result list renders
      expect(screen.getByText("Inception")).toBeTruthy()
    })

    it("should NOT search if query is too short (< 2 chars)", () => {
      renderWithTheme(<PickerContainer />)
      const input = screen.getByTestId("mock-input")

      fireEvent.changeText(input, "I")

      act(() => {
        jest.advanceTimersByTime(500)
      })

      expect(search).not.toHaveBeenCalled()
      expect(screen.queryByText("Inception")).toBeNull()
    })

    it("should clear results if input is cleared", () => {
      // 1. Populate results
      ;(search as jest.Mock).mockReturnValue([mockBasicItems[0]])
      renderWithTheme(<PickerContainer />)
      const input = screen.getByTestId("mock-input")
      fireEvent.changeText(input, "Incep")
      act(() => jest.runAllTimers())
      expect(screen.getByText("Inception")).toBeTruthy()

      // 2. Clear input
      fireEvent.changeText(input, "")
      act(() => jest.runAllTimers())

      // 3. Verify results gone
      expect(screen.queryByText("Inception")).toBeNull()
    })

    it("should not trigger search if interactions are disabled", () => {
      mockUseGameStore.mockImplementation((selector: any) =>
        selector({ ...defaultStoreState, isInteractionsDisabled: true })
      )

      renderWithTheme(<PickerContainer />)
      const input = screen.getByTestId("mock-input")
      fireEvent.changeText(input, "Inception")

      act(() => jest.runAllTimers())

      expect(search).not.toHaveBeenCalled()
    })
  })

  describe("Item Interaction", () => {
    beforeEach(() => {
      // Pre-load results for interaction tests
      ;(search as jest.Mock).mockReturnValue([mockBasicItems[0]])
    })

    it("should expand item details on long press", () => {
      renderWithTheme(<PickerContainer />)

      // Search to show items
      fireEvent.changeText(screen.getByTestId("mock-input"), "Incep")
      act(() => jest.runAllTimers())

      const item = screen.getByTestId("picker-item-1")

      // Initial state: collapsed
      expect(screen.queryByText("EXPANDED_DETAILS")).toBeNull()

      // Perform Long Press
      fireEvent(item, "longPress")

      // Should call haptics and expand
      expect(hapticsService.medium).toHaveBeenCalled()
      expect(screen.getByText("EXPANDED_DETAILS")).toBeTruthy()
    })

    it("should collapse item if long pressed again", () => {
      renderWithTheme(<PickerContainer />)
      fireEvent.changeText(screen.getByTestId("mock-input"), "Incep")
      act(() => jest.runAllTimers())
      const item = screen.getByTestId("picker-item-1")

      // Expand
      fireEvent(item, "longPress")
      expect(screen.getByText("EXPANDED_DETAILS")).toBeTruthy()

      // Collapse
      fireEvent(item, "longPress")
      expect(screen.queryByText("EXPANDED_DETAILS")).toBeNull()
    })

    it("should call makeGuess and clear input on select", () => {
      renderWithTheme(<PickerContainer />)
      const input = screen.getByTestId("mock-input")

      // Type and search
      fireEvent.changeText(input, "Incep")
      act(() => jest.runAllTimers())

      // Select
      const item = screen.getByTestId("picker-item-1")
      fireEvent.press(item)

      // Assertions
      expect(mockMakeGuess).toHaveBeenCalledWith(mockBasicItems[0])

      // Input should be cleared (component calls handleInputChange("") on select)
      // Note: In this test setup, the TextInput value is controlled by the 'query' state passed into the mock.
      // Since we are re-rendering after state update, we verify the prop value.
      expect(input.props.value).toBe("")
    })

    it("should collapse extended details when a new search is started", () => {
      renderWithTheme(<PickerContainer />)
      fireEvent.changeText(screen.getByTestId("mock-input"), "Incep")
      act(() => jest.runAllTimers())

      // Expand item
      const item = screen.getByTestId("picker-item-1")
      fireEvent(item, "longPress")
      expect(screen.getByText("EXPANDED_DETAILS")).toBeTruthy()

      // Change text
      fireEvent.changeText(screen.getByTestId("mock-input"), "Inception 2")

      // Should immediately collapse details (logic: setExpandedItemId(null) in handleInputChange)
      expect(screen.queryByText("EXPANDED_DETAILS")).toBeNull()
    })
  })
})

================
File: __tests__/pickerItem.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  fireEvent,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import PickerItem from "../src/components/pickerItem"
import { BasicTriviaItem, TriviaItem } from "../src/models/trivia"
import { API_CONFIG } from "../src/config/constants"
import { Platform } from "react-native"

// --- Mocks ---

// Mock LayoutAnimation to prevent native errors and verify calls
jest.mock("react-native/Libraries/LayoutAnimation/LayoutAnimation", () => ({
  ...jest.requireActual(
    "react-native/Libraries/LayoutAnimation/LayoutAnimation"
  ),
  configureNext: jest.fn(),
  Presets: { easeInEaseOut: "easeInEaseOut" },
}))

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

// --- Mock Data ---
const mockBasicItem: BasicTriviaItem = {
  id: 1,
  title: "The Matrix",
  releaseDate: "1999-03-31",
  posterPath: "/f89U3ADr1oiB1s9GkdPOEpXUk5H.jpg",
}

const mockDetailedItem: TriviaItem = {
  id: 1,
  title: "The Matrix",
  description: "A computer hacker learns...",
  posterPath: "/f89U3ADr1oiB1s9GkdPOEpXUk5H.jpg",
  releaseDate: "1999-03-31",
  metadata: {},
  hints: [],
}

const mockOnSelect = jest.fn()
const mockOnLongPress = jest.fn()

describe("PickerItem Component", () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe("Collapsed State (Default)", () => {
    it("should render the basic info correctly", () => {
      renderWithTheme(
        <PickerItem
          item={mockBasicItem}
          detailedItem={null}
          isDisabled={false}
          isExpanded={false}
          onSelect={mockOnSelect}
          onLongPress={mockOnLongPress}
        />
      )

      // Check title and year formatting
      expect(screen.getByText("The Matrix (1999)")).toBeTruthy()

      // Check Image source
      const image = screen.getByTestId("mock-expo-image")
      expect(image.props["data-source"]).toBe(
        `${API_CONFIG.TMDB_IMAGE_BASE_URL_W92}${mockBasicItem.posterPath}`
      )
    })

    it("should use a default image if posterPath is missing", () => {
      const itemNoPoster = { ...mockBasicItem, posterPath: "" }
      renderWithTheme(
        <PickerItem
          item={itemNoPoster}
          detailedItem={null}
          isDisabled={false}
          isExpanded={false}
          onSelect={mockOnSelect}
          onLongPress={mockOnLongPress}
        />
      )

      const image = screen.getByTestId("mock-expo-image")
      // In Jest mocks for require(), images usually resolve to 1
      expect(image.props.source).toBe(1)
    })

    it("should NOT render expanded details", () => {
      renderWithTheme(
        <PickerItem
          item={mockBasicItem}
          detailedItem={mockDetailedItem} // Even if data exists...
          isDisabled={false}
          isExpanded={false} // ...it shouldn't show if isExpanded is false
          onSelect={mockOnSelect}
          onLongPress={mockOnLongPress}
        />
      )

      expect(screen.queryByText("Tap this item to select.")).toBeNull()
    })
  })

  describe("Expanded State", () => {
    it("should render expanded details when isExpanded is true and detailedItem is provided", () => {
      renderWithTheme(
        <PickerItem
          item={mockBasicItem}
          detailedItem={mockDetailedItem}
          isDisabled={false}
          isExpanded={true}
          onSelect={mockOnSelect}
          onLongPress={mockOnLongPress}
        />
      )

      // Should show the detailed view content
      expect(screen.getByText("Tap this item to select.")).toBeTruthy()
      expect(screen.getByText("Release Year: 1999")).toBeTruthy()

      // Should show the larger image
      const images = screen.getAllByTestId("mock-expo-image")
      // First is the small thumbnail, second is the expanded preview
      const expandedImage = images[1]
      expect(expandedImage.props["data-source"]).toBe(
        `${API_CONFIG.TMDB_IMAGE_BASE_URL_W500}${mockBasicItem.posterPath}`
      )
    })

    it("should trigger LayoutAnimation when expansion state changes", () => {
      const { configureNext } = require("react-native").LayoutAnimation

      // Initial render
      const { rerender } = renderWithTheme(
        <PickerItem
          item={mockBasicItem}
          detailedItem={null}
          isDisabled={false}
          isExpanded={false}
          onSelect={mockOnSelect}
          onLongPress={mockOnLongPress}
        />
      )

      // It runs once on mount
      if (Platform.OS !== "web") {
        expect(configureNext).toHaveBeenCalledTimes(1)
      }

      // Update prop to expand
      rerender(
        <ThemeProvider>
          <PickerItem
            item={mockBasicItem}
            detailedItem={mockDetailedItem}
            isDisabled={false}
            isExpanded={true}
            onSelect={mockOnSelect}
            onLongPress={mockOnLongPress}
          />
        </ThemeProvider>
      )

      // It should run again on update
      if (Platform.OS !== "web") {
        expect(configureNext).toHaveBeenCalledTimes(2)
      }
    })
  })

  describe("Interactions", () => {
    it("should call onSelect with the item when pressed", () => {
      renderWithTheme(
        <PickerItem
          item={mockBasicItem}
          detailedItem={null}
          isDisabled={false}
          isExpanded={false}
          onSelect={mockOnSelect}
          onLongPress={mockOnLongPress}
        />
      )

      fireEvent.press(screen.getByRole("button"))
      expect(mockOnSelect).toHaveBeenCalledWith(mockBasicItem)
    })

    it("should call onLongPress with the item when long pressed", () => {
      renderWithTheme(
        <PickerItem
          item={mockBasicItem}
          detailedItem={null}
          isDisabled={false}
          isExpanded={false}
          onSelect={mockOnSelect}
          onLongPress={mockOnLongPress}
        />
      )

      const pressable = screen.getByRole("button")
      fireEvent(pressable, "longPress")
      expect(mockOnLongPress).toHaveBeenCalledWith(mockBasicItem)
    })

    it("should be disabled when isDisabled is true", () => {
      renderWithTheme(
        <PickerItem
          item={mockBasicItem}
          detailedItem={null}
          isDisabled={true}
          isExpanded={false}
          onSelect={mockOnSelect}
          onLongPress={mockOnLongPress}
        />
      )

      const pressable = screen.getByRole("button")
      expect(pressable.props.accessibilityState.disabled).toBe(true)

      fireEvent.press(pressable)
    })
  })
})

================
File: __tests__/pickerSkeleton.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import PickerSkeleton from "../src/components/pickerSkeleton"

// --- Mocks ---

// Mock the animation hook to ensure it's being used,
// and to avoid complex Reanimated setup in this unit test.
jest.mock("../src/utils/hooks/useSkeletonAnimation", () => ({
  useSkeletonAnimation: jest.fn(() => ({ opacity: 0.5 })),
}))

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("PickerSkeleton Component", () => {
  it("should render the skeleton container", () => {
    renderWithTheme(<PickerSkeleton />)

    // The component is an Animated.View with an internal structure.
    // Since we don't have explicit testIDs on the internal views in the source,
    // we verify the root element renders without crashing.
    // However, adding a testID is recommended for robust testing.
    // Assuming the component structure from source:
    // <Animated.View style={[styles.container, animatedStyle]}>
    //   <View style={styles.inputContainer}>...

    // We can inspect the style of the rendered element if we don't add a testID,
    // or we can update the component to have a testID.
    // Based on previous tests, we assume we can rely on structure or add testID in a real scenario.
    // For now, we check if *something* rendered.
    expect(screen.toJSON()).toBeTruthy()
  })

  it("should use the skeleton animation style", () => {
    const {
      useSkeletonAnimation,
    } = require("../src/utils/hooks/useSkeletonAnimation")
    renderWithTheme(<PickerSkeleton />)
    expect(useSkeletonAnimation).toHaveBeenCalled()
  })
})

================
File: __tests__/pickerUI.test.tsx
================
import React, { ReactElement } from "react"
import { Text } from "react-native"
import {
  render,
  screen,
  fireEvent,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import { PickerUI } from "../src/components/pickerUI"
import { BasicTriviaItem } from "../src/models/trivia"

// --- Mocks ---

// Mock FlashList to render items simply
jest.mock("@shopify/flash-list", () => {
  const { View } = require("react-native")
  return {
    FlashList: ({ data, renderItem }: any) => (
      <View testID="flash-list">
        {data.map((item: any, index: number) => (
          <View key={item.id}>{renderItem({ item, index })}</View>
        ))}
      </View>
    ),
  }
})

// Mock Reanimated: useAnimatedStyle just passes styles through
jest.mock("react-native-reanimated", () => {
  const { View } = require("react-native")
  return {
    ...jest.requireActual("react-native-reanimated/mock"),
    default: {
      View: View,
      Text: View, // if Text is animated
    },
  }
})

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

// --- Mock Data ---
const mockResults: BasicTriviaItem[] = [
  { id: 1, title: "Movie A", releaseDate: "2000", posterPath: "/a.jpg" },
  { id: 2, title: "Movie B", releaseDate: "2001", posterPath: "/b.jpg" },
]

const mockRenderItem = ({ item }: any) => (
  <Text testID={`item-${item.id}`}>{item.title}</Text>
)
const mockHandleInputChange = jest.fn()

describe("PickerUI Component", () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe("Search Input", () => {
    it("should render the input with placeholder and query", () => {
      renderWithTheme(
        <PickerUI
          query="Inception"
          isSearching={false}
          results={[]}
          showResults={false}
          animatedInputStyle={{}}
          isInteractionsDisabled={false}
          handleInputChange={mockHandleInputChange}
          renderItem={mockRenderItem}
          placeholder="Search..."
        />
      )

      const input = screen.getByPlaceholderText("Search...")
      expect(input.props.value).toBe("Inception")
      expect(input.props.editable).toBe(true)
    })

    it("should be disabled when isInteractionsDisabled is true", () => {
      renderWithTheme(
        <PickerUI
          query=""
          isSearching={false}
          results={[]}
          showResults={false}
          animatedInputStyle={{}}
          isInteractionsDisabled={true}
          handleInputChange={mockHandleInputChange}
          renderItem={mockRenderItem}
          placeholder="Search..."
        />
      )

      const input = screen.getByPlaceholderText("Search...")
      expect(input.props.editable).toBe(false)
    })

    it("should call handleInputChange when text changes", () => {
      renderWithTheme(
        <PickerUI
          query=""
          isSearching={false}
          results={[]}
          showResults={false}
          animatedInputStyle={{}}
          isInteractionsDisabled={false}
          handleInputChange={mockHandleInputChange}
          renderItem={mockRenderItem}
          placeholder="Search..."
        />
      )

      const input = screen.getByPlaceholderText("Search...")
      fireEvent.changeText(input, "Matrix")
      expect(mockHandleInputChange).toHaveBeenCalledWith("Matrix")
    })

    it("should show activity indicator when isSearching is true", () => {
      renderWithTheme(
        <PickerUI
          query="Mat"
          isSearching={true}
          results={[]}
          showResults={true}
          animatedInputStyle={{}}
          isInteractionsDisabled={false}
          handleInputChange={mockHandleInputChange}
          renderItem={mockRenderItem}
          placeholder="Search..."
        />
      )

      // ActivityIndicator usually doesn't have text, but we can check for existence
      // or check that "Searching..." text appears in the results container if implemented that way.
      // Looking at source: `isSearching` triggers an ActivityIndicator inside inputContainer
      // AND "Searching..." text in resultsContainer if showResults is true.

      // Check for ActivityIndicator (implicit role='progressbar' or similar, but default RN mock is simple)
      // We can just check if the text "Searching..." is present as per source logic:
      // {isSearching ? <Text...>Searching...</Text> : ...}

      expect(screen.getByText("Searching...")).toBeTruthy()
    })
  })

  describe("Results List", () => {
    it("should NOT render results container if showResults is false", () => {
      renderWithTheme(
        <PickerUI
          query="Mat"
          isSearching={false}
          results={mockResults}
          showResults={false} // Key prop
          animatedInputStyle={{}}
          isInteractionsDisabled={false}
          handleInputChange={mockHandleInputChange}
          renderItem={mockRenderItem}
          placeholder="Search..."
        />
      )

      expect(screen.queryByTestId("flash-list")).toBeNull()
    })

    it("should render the list of results when showResults is true and results exist", () => {
      renderWithTheme(
        <PickerUI
          query="Mo"
          isSearching={false}
          results={mockResults}
          showResults={true}
          animatedInputStyle={{}}
          isInteractionsDisabled={false}
          handleInputChange={mockHandleInputChange}
          renderItem={mockRenderItem}
          placeholder="Search..."
        />
      )

      expect(screen.getByTestId("flash-list")).toBeTruthy()
      expect(screen.getByText("Movie A")).toBeTruthy()
      expect(screen.getByText("Movie B")).toBeTruthy()

      // Should also show the hint text
      expect(screen.getByText(/Hold any result to preview/)).toBeTruthy()
    })

    it("should render 'No titles found' if results are empty and query is long enough", () => {
      renderWithTheme(
        <PickerUI
          query="Zxywq"
          isSearching={false}
          results={[]}
          showResults={true}
          animatedInputStyle={{}}
          isInteractionsDisabled={false}
          handleInputChange={mockHandleInputChange}
          renderItem={mockRenderItem}
          placeholder="Search..."
        />
      )

      expect(screen.getByText('No titles found for "Zxywq"')).toBeTruthy()
    })

    it("should render nothing if results are empty but query is too short (< 2)", () => {
      renderWithTheme(
        <PickerUI
          query="Z"
          isSearching={false}
          results={[]}
          showResults={true} // Container might set this true? Logic says `showResults` is passed in.
          // Source logic: query.length >= 2 ? <NoResults> : null
          animatedInputStyle={{}}
          isInteractionsDisabled={false}
          handleInputChange={mockHandleInputChange}
          renderItem={mockRenderItem}
          placeholder="Search..."
        />
      )

      expect(screen.queryByText(/No titles found/)).toBeNull()
    })
  })
})

================
File: __tests__/playerStats.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import PlayerStatsContainer from "../src/components/playerStats"
import { defaultPlayerStats } from "../src/models/default"
import PlayerStats from "../src/models/playerStats"

// --- Mocks ---

// Mock WinChart to avoid complex SVG/Victory rendering
jest.mock("../src/components/winChart", () => {
  const { View } = require("react-native")
  return (props: any) => (
    <View testID="mock-win-chart" data-wins={JSON.stringify(props.wins)} />
  )
})

// Mock StatItem to verify props passed
jest.mock("../src/components/statItem", () => {
  const { Text, View } = require("react-native")
  return (props: any) => (
    <View testID={`stat-item-${props.label}`}>
      <Text>
        {props.label}: {props.value}
      </Text>
    </View>
  )
})

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

// --- Mock Data ---
const mockPlayer = { id: "player-1", name: "Test Player" }
const mockStats: PlayerStats = {
  ...defaultPlayerStats,
  games: 10,
  currentStreak: 3,
  maxStreak: 5,
  hintsAvailable: 2,
  allTimeScore: 1250,
  wins: [1, 2, 3, 0, 4], // Distribution array
}

describe("PlayerStatsContainer Component", () => {
  describe("Empty State", () => {
    it("should render 'No statistics available' if player is null", () => {
      renderWithTheme(
        <PlayerStatsContainer player={null} playerStats={mockStats} />
      )
      expect(screen.getByText("No statistics available.")).toBeTruthy()
    })

    it("should render 'No statistics available' if playerStats is null", () => {
      renderWithTheme(
        <PlayerStatsContainer player={mockPlayer} playerStats={null} />
      )
      expect(screen.getByText("No statistics available.")).toBeTruthy()
    })
  })

  describe("Data Rendering", () => {
    it("should render the WinChart with correct data", () => {
      renderWithTheme(
        <PlayerStatsContainer player={mockPlayer} playerStats={mockStats} />
      )

      const chart = screen.getByTestId("mock-win-chart")
      expect(chart).toBeTruthy()
      // Verify props passed to chart
      // @ts-ignore
      expect(JSON.parse(chart.props["data-wins"])).toEqual(mockStats.wins)
    })

    it("should render all stat items with correct values", () => {
      renderWithTheme(
        <PlayerStatsContainer player={mockPlayer} playerStats={mockStats} />
      )

      // All-Time Score
      expect(screen.getByText("All-Time Score: 1,250")).toBeTruthy()

      // Games Played
      expect(screen.getByText("Games Played: 10")).toBeTruthy()

      // Current Streak
      expect(screen.getByText("Current Streak: 3")).toBeTruthy()

      // Max Streak
      expect(screen.getByText("Max Streak: 5")).toBeTruthy()

      // Hints Available
      expect(screen.getByText("Hints Available: 2")).toBeTruthy()
    })

    it("should format large score numbers with commas", () => {
      const largeStats = { ...mockStats, allTimeScore: 1000000 }
      renderWithTheme(
        <PlayerStatsContainer player={mockPlayer} playerStats={largeStats} />
      )

      expect(screen.getByText("All-Time Score: 1,000,000")).toBeTruthy()
    })
  })
})

================
File: __tests__/profile_screen.test.tsx
================
import React, { ReactElement } from "react"
import { View } from "react-native"
import { render, screen, waitFor } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import { useAuth } from "../src/contexts/authContext"
import { useGameStore } from "../src/state/gameStore"

// 1. Mock React.lazy to avoid dynamic import error and circular dependency.
jest.mock("react", () => {
  const actual = jest.requireActual("react")
  return {
    ...actual,
    lazy: (factory: any) => {
      const Component = (props: any) => {
        // Use STRING "View" to avoid requiring react-native which causes circular dependency
        return actual.createElement(
          "View",
          { ...props, testID: "lazy-component" },
          props.children
        )
      }
      return Component
    },
    Suspense: ({ children }: any) => children,
  }
})

// 2. Mock the modules.
jest.mock("../src/components/googleLogin", () => () => <></>)
jest.mock("../src/components/playerStats", () => () => <></>)
jest.mock("../src/components/gameHistory", () => () => <></>)
jest.mock("../src/components/themeSelector", () => () => <></>)
jest.mock("../src/components/difficultySelector", () => () => <></>)
jest.mock("../src/components/historyDetailModal", () => () => <></>)

jest.mock("../src/contexts/authContext")
jest.mock("../src/state/gameStore")

import ProfileScreen from "../src/app/(tabs)/profile"

const mockUseAuth = useAuth as jest.Mock
const mockUseGameStore = useGameStore as unknown as jest.Mock

const renderWithTheme = (ui: ReactElement) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>)
}

describe("App: ProfileScreen", () => {
  beforeEach(() => {
    jest.clearAllMocks()
    mockUseGameStore.mockImplementation((selector: any) =>
      selector({
        playerStats: {},
        loading: false,
      })
    )
  })

  it("should show loading indicator if authentication is loading", () => {
    mockUseAuth.mockReturnValue({ player: null, user: null })
    mockUseGameStore.mockImplementation((selector: any) =>
      selector({ loading: true })
    )

    renderWithTheme(<ProfileScreen />)

    expect(screen.getByTestId("loading-indicator-container")).toBeTruthy()
  })

  it("should render guest profile correctly", async () => {
    mockUseAuth.mockReturnValue({
      player: { name: "Guest" },
      user: { isAnonymous: true },
    })

    renderWithTheme(<ProfileScreen />)

    await waitFor(() => {
      expect(screen.getByText("Welcome, Guest!")).toBeTruthy()
      expect(screen.getByText("Save Your Progress")).toBeTruthy()
    })
  })

  it("should render signed-in user profile correctly", async () => {
    mockUseAuth.mockReturnValue({
      player: { name: "Test User" },
      user: { isAnonymous: false },
    })

    renderWithTheme(<ProfileScreen />)

    await waitFor(() => {
      expect(screen.getByText("Welcome, Test User!")).toBeTruthy()
      expect(screen.queryByText("Save Your Progress")).toBeNull()
    })
  })
})

================
File: __tests__/profileSection.test.tsx
================
import React, { ReactElement } from "react"
import { Text } from "react-native"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import ProfileSection from "../src/components/profileSection"

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("ProfileSection Component", () => {
  it("should render the title and icon", () => {
    renderWithTheme(
      <ProfileSection title="My Section" icon="user">
        <Text>Child Content</Text>
      </ProfileSection>
    )

    // Check Title
    expect(screen.getByText("My Section")).toBeTruthy()

    // Check Icon (Mocked FontAwesome usually renders text with the icon name)
    expect(screen.getByTestId("mock-icon-user")).toBeTruthy()
  })

  it("should render children content", () => {
    renderWithTheme(
      <ProfileSection title="Settings" icon="cog">
        <Text testID="child-element">Inner Content</Text>
      </ProfileSection>
    )

    expect(screen.getByTestId("child-element")).toBeTruthy()
    expect(screen.getByText("Inner Content")).toBeTruthy()
  })
})

================
File: __tests__/revealSequence.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  act,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import RevealSequence from "../src/components/revealSequence"
import { useGameStore } from "../src/state/gameStore"
import { defaultPlayerGame } from "../src/models/default"
import { API_CONFIG } from "../src/config/constants"

// --- Mocks ---

// Mock Reanimated to handle layout animations predictably
// We don't need deep mocks since we are testing the callback via timer advancement
jest.mock("react-native-reanimated", () => {
  const Reanimated = jest.requireActual("react-native-reanimated/mock")
  return {
    ...Reanimated,
    // Ensure runOnJS executes the callback
    runOnJS: (fn: Function) => fn,
    // Ensure withDelay calls callback after delay (simulated)
    withDelay: (delay: number, animation: any) => {
      return animation
    },
    // Ensure withTiming calls callback immediately for test purposes if provided
    withTiming: (toValue: number, config: any, callback: any) => {
      if (callback) callback(true) // Simulate completion
      return { value: toValue }
    },
    useSharedValue: (initial: number) => ({ value: initial }),
    useAnimatedStyle: (fn: Function) => fn(),
  }
})

// Mock Game Store
jest.mock("../src/state/gameStore")
const mockUseGameStore = useGameStore as unknown as jest.Mock

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

const mockTriviaItem = {
  ...defaultPlayerGame.triviaItem,
  id: 101,
  title: "The Matrix",
  posterPath: "/matrix_poster.jpg",
}

const setMockStoreState = (state: any) => {
  mockUseGameStore.mockImplementation((selector: any) => selector(state))
}

describe("RevealSequence Component", () => {
  const onAnimationCompleteMock = jest.fn()

  beforeEach(() => {
    jest.clearAllMocks()
    jest.useFakeTimers()

    setMockStoreState({
      playerGame: {
        ...defaultPlayerGame,
        triviaItem: mockTriviaItem,
      },
    })
  })

  afterEach(() => {
    jest.useRealTimers()
  })

  it("should render the correct movie title and poster", () => {
    renderWithTheme(
      <RevealSequence onAnimationComplete={onAnimationCompleteMock} />
    )

    expect(screen.getByText("The Matrix")).toBeTruthy()

    const image = screen.getByTestId("mock-expo-image")
    expect(image.props["data-source"]).toBe(
      `${API_CONFIG.TMDB_IMAGE_BASE_URL_W500}${mockTriviaItem.posterPath}`
    )
  })

  it("should render fallback image if posterPath is missing", () => {
    setMockStoreState({
      playerGame: {
        ...defaultPlayerGame,
        triviaItem: { ...mockTriviaItem, posterPath: null },
      },
    })

    renderWithTheme(
      <RevealSequence onAnimationComplete={onAnimationCompleteMock} />
    )

    const image = screen.getByTestId("mock-expo-image")
    // Fallback require returns 1 in Jest
    expect(image.props.source).toBe(1)
  })

  it("should call onAnimationComplete after the sequence finishes", () => {
    renderWithTheme(
      <RevealSequence onAnimationComplete={onAnimationCompleteMock} />
    )

    // The component has multiple animations chained with delays.
    // The final callback is inside a `setTimeout` within the `withTiming` completion callback.
    // 1. Initial delay + animation duration
    // 2. setTimeout of 1000ms

    // Since we mocked `withTiming` to execute the callback immediately,
    // we just need to advance the timer for the setTimeout(..., 1000).

    expect(onAnimationCompleteMock).not.toHaveBeenCalled()

    act(() => {
      jest.advanceTimersByTime(2000) // Advance past 1000ms
    })

    expect(onAnimationCompleteMock).toHaveBeenCalledTimes(1)
  })
})

================
File: __tests__/scoreUtils.test.tsx
================
import { calculateScore } from "../src/utils/scoreUtils"
import { defaultPlayerGame } from "../src/models/default"
import { PlayerGame } from "../src/models/game"

describe("Utils: scoreUtils", () => {
  const baseGame: PlayerGame = {
    ...defaultPlayerGame,
    correctAnswer: true,
    guessesMax: 5,
    difficulty: "LEVEL_3", // Medium
    hintsUsed: {},
  }

  describe("calculateScore", () => {
    it("should return 0 if the answer is incorrect", () => {
      const game: PlayerGame = { ...baseGame, correctAnswer: false }
      expect(calculateScore(game)).toBe(0)
    })

    it("should return max score for 1st guess in Hard mode", () => {
      // Level 4 multiplier is 0.85. Max base is 1000.
      // Expected: 850
      const game: PlayerGame = {
        ...baseGame,
        difficulty: "LEVEL_4",
        guesses: [{ itemId: 1 }], // 1 guess used
        guessesMax: 5,
      }
      expect(calculateScore(game)).toBe(850)
    })

    it("should calculate correct degradation for Medium mode", () => {
      // Level 3 (Medium): Multiplier 0.7 (Max 700). Range % is 0.6.
      // Max = 700. Pool = 700 * 0.6 = 420. Base = 280.
      // 5 Guesses Max.
      // 1 guess:  280 + 420 * (4/4) = 700
      // 3 guesses: 280 + 420 * (2/4) = 490

      const game: PlayerGame = {
        ...baseGame,
        difficulty: "LEVEL_3",
        guesses: [{ itemId: 1 }, { itemId: 2 }, { itemId: 3 }], // 3 guesses
        guessesMax: 5,
      }
      expect(calculateScore(game)).toBe(490)
    })

    it("should return base win points for the last possible guess", () => {
      // Level 3. Base win points = 280.
      const game: PlayerGame = {
        ...baseGame,
        difficulty: "LEVEL_3",
        guesses: [
          { itemId: 1 },
          { itemId: 2 },
          { itemId: 3 },
          { itemId: 4 },
          { itemId: 5 },
        ], // 5 guesses (max)
        guessesMax: 5,
      }
      expect(calculateScore(game)).toBe(280)
    })

    it("should deduct points for hints used in Level 2 (Easy)", () => {
      // Level 2: Multiplier 0.55 (550 Max). Range 0.65.
      // Pool = 550 * 0.65 = 357.5. Base = 192.5.
      // 1 guess = 550.
      // Penalty = 50 per hint.
      const game: PlayerGame = {
        ...baseGame,
        difficulty: "LEVEL_2",
        guesses: [{ itemId: 1 }],
        hintsUsed: { director: true, genre: true }, // 2 hints
      }

      // Expected: 550 - (2 * 50) = 450
      expect(calculateScore(game)).toBe(450)
    })

    it("should not return negative scores", () => {
      // Force a scenario where penalties exceed score
      const game: PlayerGame = {
        ...baseGame,
        difficulty: "LEVEL_2", // Easy
        guesses: [
          { itemId: 1 },
          { itemId: 2 },
          { itemId: 3 },
          { itemId: 4 },
          { itemId: 5 },
        ], // Last guess (low base score)
        // Excessive hints to drive score negative
        hintsUsed: { a: true, b: true, c: true, d: true, e: true, f: true },
        guessesMax: 5,
      }
      // Even if math goes negative, function should return 0 or minimum floor
      expect(calculateScore(game)).toBeGreaterThanOrEqual(0)
    })

    it("should handle unknown difficulty gracefully", () => {
      const consoleSpy = jest
        .spyOn(console, "error")
        .mockImplementation(() => {})
      const game: PlayerGame = {
        ...baseGame,
        // @ts-ignore
        difficulty: "LEVEL_999",
      }
      expect(calculateScore(game)).toBe(0)
      expect(consoleSpy).toHaveBeenCalled()
      consoleSpy.mockRestore()
    })
  })
})

================
File: __tests__/shareResultButton.test.tsx
================
import React, { ReactElement } from "react"
import { Alert } from "react-native"
import {
  render,
  screen,
  fireEvent,
  waitFor,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import ShareResultButton from "../src/components/gameOver/shareResultButton"
import { shareGameResult } from "../src/utils/shareUtils"
import { defaultPlayerGame } from "../src/models/default"

// Mock dependencies
jest.mock("../src/utils/shareUtils")
jest.spyOn(Alert, "alert")

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("GameOver Component: ShareResultButton", () => {
  const mockPlayerGame = { ...defaultPlayerGame, id: "test-game-1" }
  let consoleErrorSpy: jest.SpyInstance

  beforeEach(() => {
    jest.clearAllMocks()
    consoleErrorSpy = jest.spyOn(console, "error").mockImplementation(() => {})
  })

  afterEach(() => {
    consoleErrorSpy.mockRestore()
  })

  it("should render the share button", () => {
    renderWithTheme(<ShareResultButton playerGame={mockPlayerGame} />)
    expect(screen.getByText("Share Your Result")).toBeTruthy()
  })

  it("should call shareGameResult with playerGame when pressed", async () => {
    ;(shareGameResult as jest.Mock).mockResolvedValue(true)

    renderWithTheme(<ShareResultButton playerGame={mockPlayerGame} />)
    fireEvent.press(screen.getByRole("button"))

    await waitFor(() => {
      expect(shareGameResult).toHaveBeenCalledWith(mockPlayerGame)
    })
  })

  it("should show an Alert if sharing fails", async () => {
    const errorMsg = "Share failed"
    // Make the share utility throw an error
    ;(shareGameResult as jest.Mock).mockRejectedValue(new Error(errorMsg))

    renderWithTheme(<ShareResultButton playerGame={mockPlayerGame} />)
    fireEvent.press(screen.getByRole("button"))

    await waitFor(() => {
      expect(Alert.alert).toHaveBeenCalledWith(
        "Sharing Failed",
        "An error occurred while trying to share your results."
      )
    })

    // Verify the error was logged (and suppressed from test output)
    expect(consoleErrorSpy).toHaveBeenCalled()
  })

  it("should prevent double clicks while sharing is in progress", async () => {
    // Create a promise that we can control
    let resolveShare: (value: unknown) => void
    const sharePromise = new Promise((resolve) => {
      resolveShare = resolve
    })
    ;(shareGameResult as jest.Mock).mockReturnValue(sharePromise)

    renderWithTheme(<ShareResultButton playerGame={mockPlayerGame} />)

    const button = screen.getByRole("button")

    // First press
    fireEvent.press(button)

    // Second press immediately after
    fireEvent.press(button)

    // Should only have been called once so far
    expect(shareGameResult).toHaveBeenCalledTimes(1)

    // Resolve the promise
    // @ts-ignore
    resolveShare(true)

    await waitFor(() => expect(shareGameResult).toHaveBeenCalledTimes(1))
  })
})

================
File: __tests__/skeletonRow.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import { SkeletonRow } from "../src/components/guess/skeletonRow"
import { useSkeletonAnimation } from "../src/utils/hooks/useSkeletonAnimation"

// Mock Animation
jest.mock("../src/utils/hooks/useSkeletonAnimation")

// Fixed Reanimated Mock
jest.mock("react-native-reanimated", () => {
  const { View } = require("react-native")
  return {
    __esModule: true,
    default: {
      View: View, // Animated.View becomes just View
    },
    // If the component uses named exports like useSharedValue, they need to be here or in the global mock
    useSharedValue: jest.fn(() => ({ value: 0 })),
    useAnimatedStyle: jest.fn(() => ({})),
  }
})

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("Guess Component: SkeletonRow", () => {
  beforeEach(() => {
    ;(useSkeletonAnimation as jest.Mock).mockReturnValue({ opacity: 0.5 })
  })

  it("should render the index number correctly", () => {
    renderWithTheme(<SkeletonRow index={2} />)
    // Display index is 0-based in code, but displayed as 1-based
    expect(screen.getByText("3")).toBeTruthy()
  })

  it("should render the skeleton text container", () => {
    const { toJSON } = renderWithTheme(<SkeletonRow index={0} />)
    expect(toJSON()).toMatchSnapshot()
  })

  it("should call useSkeletonAnimation", () => {
    renderWithTheme(<SkeletonRow index={0} />)
    expect(useSkeletonAnimation).toHaveBeenCalled()
  })
})

================
File: __tests__/statItem.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import StatItem from "../src/components/statItem"

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("StatItem Component", () => {
  it("should render label and string value", () => {
    renderWithTheme(<StatItem label="Current Streak" value="5" />)

    expect(screen.getByText("Current Streak")).toBeTruthy()
    expect(screen.getByText("5")).toBeTruthy()
  })

  it("should render numeric value correctly", () => {
    renderWithTheme(<StatItem label="Score" value={1500} />)

    expect(screen.getByText("Score")).toBeTruthy()
    // React Native renders numbers as strings in Text
    expect(screen.getByText("1500")).toBeTruthy()
  })

  it("should apply custom value styles if provided", () => {
    // We can't easily check style computation with testing-library in a unit test
    // without inspecting the JSON tree style prop, but we can verify the render doesn't crash.
    // A snapshot or explicit prop check would be deeper, but for functionality:

    renderWithTheme(
      <StatItem
        label="Styled Value"
        value="100"
        valueStyle={{ color: "red" }}
      />
    )

    expect(screen.getByText("100")).toBeTruthy()
  })
})

================
File: __tests__/stringUtils.test.tsx
================
import { normalizeSearchString } from "../src/utils/stringUtils"

describe("Utils: stringUtils", () => {
  describe("normalizeSearchString", () => {
    it("should return empty string for null or undefined input", () => {
      // @ts-ignore
      expect(normalizeSearchString(null)).toBe("")
      // @ts-ignore
      expect(normalizeSearchString(undefined)).toBe("")
    })

    it("should remove diacritics (accents)", () => {
      expect(normalizeSearchString("Amlie")).toBe("Amelie")
      expect(normalizeSearchString("Crme Brle")).toBe("Creme Brulee")
      expect(normalizeSearchString("u")).toBe("Nu")
    })

    it("should handle standard ascii strings unchanged", () => {
      expect(normalizeSearchString("Star Wars")).toBe("Star Wars")
    })

    it("should handle mixed casing and special characters correctly", () => {
      // Function only normalizes NFD forms, it doesn't strip non-alphanumeric or lowercase
      // based on the implementation in source.
      expect(normalizeSearchString("WALLE")).toBe("WALLE")
    })
  })
})

================
File: __tests__/tabs_layout.test.tsx
================
import React from "react"
import { render, screen } from "@testing-library/react-native"
import { useFonts } from "expo-font"

// Fixed mock for expo-font
jest.mock("expo-font", () => ({
  useFonts: jest.fn(),
}))

jest.mock("expo-router", () => ({
  Tabs: Object.assign((props: any) => <>{props.children}</>, {
    Screen: ({ name }: { name: string }) => {
      const { View } = require("react-native")
      return <View testID={`tab-${name}`} />
    },
  }),
}))

jest.mock("../src/contexts/themeContext", () => ({
  useTheme: () => ({
    colors: {
      primary: "blue",
      textSecondary: "gray",
      surface: "white",
      background: "white",
      border: "black",
    },
  }),
}))

import TabLayout from "../src/app/(tabs)/_layout"

describe("App: TabsLayout", () => {
  beforeEach(() => {
    jest.clearAllMocks()
    // Default to NOT loaded
    ;(useFonts as jest.Mock).mockReturnValue([false, null])
  })

  it("should show loading indicator if fonts are not loaded", () => {
    render(<TabLayout />)
    expect(screen.getByTestId("loading-indicator-container")).toBeTruthy()
  })

  it("should show error message if font loading fails", () => {
    const errorMsg = "Font load failed"
    const error = new Error(errorMsg)
    // We must mock the return value BEFORE rendering
    ;(useFonts as jest.Mock).mockReturnValue([true, error])

    render(<TabLayout />)

    expect(screen.getByText(errorMsg)).toBeTruthy()
  })

  it("should render tabs when fonts are loaded", () => {
    ;(useFonts as jest.Mock).mockReturnValue([true, null])
    render(<TabLayout />)
    expect(screen.toJSON()).toBeDefined()
  })
})

================
File: __tests__/themeSelector.test.tsx
================
import React from "react"
import { render, fireEvent, screen } from "@testing-library/react-native"
import { ThemeContext } from "../src/contexts/themeContext"
import ThemeSelector from "../src/components/themeSelector"
import { lightColors } from "../src/styles/themes"

// --- Mock Context ---
const mockSetTheme = jest.fn()

const renderWithMockContext = (
  currentTheme: "light" | "dark" | "system" = "system"
) => {
  return render(
    <ThemeContext.Provider
      value={{
        theme: currentTheme,
        setTheme: mockSetTheme,
        colors: lightColors,
        colorScheme: "light",
      }}
    >
      <ThemeSelector />
    </ThemeContext.Provider>
  )
}

describe("ThemeSelector Component", () => {
  beforeEach(() => {
    mockSetTheme.mockClear()
  })

  it("should render all theme options", () => {
    renderWithMockContext()

    expect(screen.getByText("Theme")).toBeTruthy()
    expect(screen.getByText("Light")).toBeTruthy()
    expect(screen.getByText("Dark")).toBeTruthy()
    expect(screen.getByText("System")).toBeTruthy()
  })

  it("should indicate the currently selected theme", () => {
    renderWithMockContext("dark")

    // We check accessibility state "selected" which is set on the Pressable
    const darkButton = screen.getByRole("button", { name: "Set theme to Dark" })
    expect(darkButton.props.accessibilityState.selected).toBe(true)

    const lightButton = screen.getByRole("button", {
      name: "Set theme to Light",
    })
    expect(lightButton.props.accessibilityState.selected).toBe(false)
  })

  it("should call setTheme when an option is pressed", () => {
    renderWithMockContext("light")

    const systemButton = screen.getByRole("button", {
      name: "Set theme to System",
    })
    fireEvent.press(systemButton)

    expect(mockSetTheme).toHaveBeenCalledWith("system")
  })
})

================
File: __tests__/titleHeader.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import TitleHeader from "../src/components/titleHeader"

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("TitleHeader Component", () => {
  it("should render the title correctly", () => {
    const testTitle = "Guess the Movie"
    renderWithTheme(<TitleHeader title={testTitle} />)

    expect(screen.getByText(testTitle)).toBeTruthy()
  })

  it("should render with heading typography styles", () => {
    // While we can't verify exact pixels easily, we can ensure it renders.
    renderWithTheme(<TitleHeader title="Header Test" />)
    expect(screen.toJSON()).toBeTruthy()
  })
})

================
File: __tests__/tutorialTip.test.tsx
================
import React, { ReactElement } from "react"
import {
  render,
  screen,
  fireEvent,
  RenderOptions,
} from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import TutorialTooltip from "../src/components/tutorialTooltip"
import { hapticsService } from "../src/utils/hapticsService"

// --- Mocks ---
jest.mock("../src/utils/hapticsService")

// Mock Reanimated
jest.mock("react-native-reanimated", () => {
  const Reanimated = jest.requireActual("react-native-reanimated/mock")
  return {
    ...Reanimated,
    useSharedValue: jest.fn((initialValue) => ({ value: initialValue })),
    useAnimatedStyle: jest.fn((fn) => fn()),
    withTiming: jest.fn((toValue) => toValue), // Return target value immediately
    interpolate: jest.fn(() => 0),
  }
})

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("TutorialTooltip Component", () => {
  const mockOnDismiss = jest.fn()

  beforeEach(() => {
    jest.clearAllMocks()
  })

  it("should render nothing when isVisible is false", () => {
    const { toJSON } = renderWithTheme(
      <TutorialTooltip
        isVisible={false}
        text="Tip text"
        onDismiss={mockOnDismiss}
      />
    )
    expect(toJSON()).toBeNull()
  })

  it("should render the text and button when isVisible is true", () => {
    renderWithTheme(
      <TutorialTooltip
        isVisible={true}
        text="This is a helpful tip."
        onDismiss={mockOnDismiss}
      />
    )

    expect(screen.getByText("This is a helpful tip.")).toBeTruthy()
    expect(screen.getByText("Got it")).toBeTruthy()
  })

  it("should call onDismiss and haptics when 'Got it' is pressed", () => {
    renderWithTheme(
      <TutorialTooltip
        isVisible={true}
        text="Tip text"
        onDismiss={mockOnDismiss}
      />
    )

    fireEvent.press(screen.getByText("Got it"))

    expect(hapticsService.medium).toHaveBeenCalled()
    expect(mockOnDismiss).toHaveBeenCalledTimes(1)
  })
})

================
File: __tests__/typography.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import { Typography } from "../src/components/ui/typography"
import { lightColors } from "../src/styles/themes"

const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("UI Component: Typography", () => {
  it("should render children text correctly", () => {
    renderWithTheme(<Typography>Hello World</Typography>)
    expect(screen.getByText("Hello World")).toBeTruthy()
  })

  it("should render body variant by default", () => {
    renderWithTheme(<Typography>Body Text</Typography>)
    const text = screen.getByText("Body Text")

    // Body text usually has Arvo-Regular
    expect(text.props.style).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          fontFamily: "Arvo-Regular",
          color: lightColors.textSecondary,
        }),
      ])
    )
  })

  it("should render h1 variant with bold font", () => {
    renderWithTheme(<Typography variant="h1">Header 1</Typography>)
    const text = screen.getByText("Header 1")

    expect(text.props.style).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          fontFamily: "Arvo-Bold",
          color: lightColors.textPrimary,
        }),
      ])
    )
  })

  it("should render error variant with error color", () => {
    renderWithTheme(<Typography variant="error">Error Message</Typography>)
    const text = screen.getByText("Error Message")

    expect(text.props.style).toEqual(
      expect.arrayContaining([
        expect.objectContaining({ color: lightColors.error }),
      ])
    )
  })

  it("should accept and merge custom style props", () => {
    renderWithTheme(
      <Typography style={{ fontSize: 99 }}>Custom Size</Typography>
    )
    const text = screen.getByText("Custom Size")

    expect(text.props.style).toEqual(
      expect.arrayContaining([expect.objectContaining({ fontSize: 99 })])
    )
  })
})

================
File: __tests__/useExternalLink.test.tsx
================
import { renderHook, act } from "@testing-library/react-native"
import { Alert } from "react-native"
import * as Linking from "expo-linking"
import { useExternalLink } from "../src/utils/hooks/useExternalLink"

// Mocks
jest.mock("expo-linking", () => ({
  canOpenURL: jest.fn(),
  openURL: jest.fn(),
}))
jest.spyOn(Alert, "alert")

describe("Hook: useExternalLink", () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  it("should alert if the URL is missing", async () => {
    const { result } = renderHook(() => useExternalLink())

    await act(async () => {
      // @ts-ignore - testing null input
      await result.current.openLink(null)
    })

    expect(Alert.alert).toHaveBeenCalledWith(
      "Link Unavailable",
      "No link was found for this item."
    )
    expect(Linking.canOpenURL).not.toHaveBeenCalled()
  })

  it("should open the URL if it is supported", async () => {
    ;(Linking.canOpenURL as jest.Mock).mockResolvedValue(true)
    const { result } = renderHook(() => useExternalLink())
    const testUrl = "https://example.com"

    await act(async () => {
      await result.current.openLink(testUrl)
    })

    expect(Linking.canOpenURL).toHaveBeenCalledWith(testUrl)
    expect(Linking.openURL).toHaveBeenCalledWith(testUrl)
    expect(Alert.alert).not.toHaveBeenCalled()
  })

  it("should alert if the URL is not supported", async () => {
    ;(Linking.canOpenURL as jest.Mock).mockResolvedValue(false)
    const { result } = renderHook(() => useExternalLink())
    const testUrl = "invalid-scheme://test"

    await act(async () => {
      await result.current.openLink(testUrl)
    })

    expect(Linking.canOpenURL).toHaveBeenCalledWith(testUrl)
    expect(Linking.openURL).not.toHaveBeenCalled()
    expect(Alert.alert).toHaveBeenCalledWith(
      "Unsupported Link",
      expect.stringContaining(testUrl)
    )
  })

  it("should alert if checking/opening the link throws an error", async () => {
    const errorMsg = "Network error"
    ;(Linking.canOpenURL as jest.Mock).mockRejectedValue(new Error(errorMsg))
    const { result } = renderHook(() => useExternalLink())

    await act(async () => {
      await result.current.openLink("https://example.com")
    })

    expect(Alert.alert).toHaveBeenCalledWith(
      "Link Error",
      expect.stringContaining(errorMsg)
    )
  })
})

================
File: __tests__/useGoogleAuth.test.tsx
================
import { renderHook, act, waitFor } from "@testing-library/react-native"
import { useGoogleAuth } from "../src/utils/hooks/useGoogleAuth"
import { useIdTokenAuthRequest } from "expo-auth-session/providers/google"
import {
  getAuth,
  signInWithCredential,
  signOut,
  GoogleAuthProvider,
} from "firebase/auth"
import { analyticsService } from "../src/utils/analyticsService"

// Mocks
jest.mock("firebase/auth")
jest.mock("../src/utils/analyticsService")

// Mock expo-constants
jest.mock("expo-constants", () => ({
  expoConfig: {
    extra: {
      androidClientId: "android-id",
      expoClientId: "expo-id",
      iosClientId: "ios-id",
      webClientId: "web-id",
    },
  },
}))

// Properly mock the expo-auth-session provider
jest.mock("expo-auth-session/providers/google", () => ({
  useIdTokenAuthRequest: jest.fn(),
}))

describe("Hook: useGoogleAuth", () => {
  const mockOnAuthStateChange = jest.fn()
  const mockPromptAsync = jest.fn()
  const mockUseIdTokenAuthRequest = useIdTokenAuthRequest as jest.Mock

  beforeEach(() => {
    jest.clearAllMocks()
    // Default behavior: no request, no response, just the prompt function
    mockUseIdTokenAuthRequest.mockReturnValue([null, null, mockPromptAsync])
    ;(getAuth as jest.Mock).mockReturnValue({})
  })

  it("should initiate Google sign-in when handleSignIn is called", async () => {
    const { result } = renderHook(() => useGoogleAuth(mockOnAuthStateChange))

    await act(async () => {
      await result.current.handleSignIn()
    })

    expect(result.current.isLoading).toBe(true)
    expect(result.current.authError).toBeNull()
    expect(analyticsService.trackGoogleSignInStart).toHaveBeenCalled()
    expect(mockPromptAsync).toHaveBeenCalled()
  })

  it("should handle successful Google response and Firebase sign-in", async () => {
    const { result, rerender } = renderHook(() =>
      useGoogleAuth(mockOnAuthStateChange)
    )

    const mockUser = { uid: "test-uid" }
    ;(signInWithCredential as jest.Mock).mockResolvedValue({ user: mockUser })

    // Update mock to simulate successful response
    mockUseIdTokenAuthRequest.mockReturnValue([
      null,
      { type: "success", params: { id_token: "valid-token" } },
      mockPromptAsync,
    ])
    rerender({})

    await waitFor(() => {
      expect(GoogleAuthProvider.credential).toHaveBeenCalledWith("valid-token")
      expect(signInWithCredential).toHaveBeenCalled()
      expect(analyticsService.trackGoogleSignInSuccess).toHaveBeenCalledWith(
        "test-uid"
      )
      expect(result.current.isLoading).toBe(false)
      expect(result.current.authError).toBeNull()
    })
  })

  it("should handle Firebase sign-in failure after Google success", async () => {
    const { result, rerender } = renderHook(() =>
      useGoogleAuth(mockOnAuthStateChange)
    )

    ;(signInWithCredential as jest.Mock).mockRejectedValue(
      new Error("Firebase Error")
    )

    mockUseIdTokenAuthRequest.mockReturnValue([
      null,
      { type: "success", params: { id_token: "valid-token" } },
      mockPromptAsync,
    ])

    rerender({})

    await waitFor(() => {
      expect(result.current.authError).toContain(
        "Firebase sign-in error: Firebase Error"
      )
      expect(analyticsService.trackGoogleSignInFailure).toHaveBeenCalledWith(
        expect.any(String)
      )
      expect(result.current.isLoading).toBe(false)
    })
  })

  it("should handle Google sign-in errors directly", async () => {
    const { result, rerender } = renderHook(() =>
      useGoogleAuth(mockOnAuthStateChange)
    )

    mockUseIdTokenAuthRequest.mockReturnValue([
      null,
      { type: "error", error: { message: "Google Auth Failed" } },
      mockPromptAsync,
    ])

    rerender({})

    await waitFor(() => {
      expect(result.current.authError).toContain(
        "Google sign-in error: Google Auth Failed"
      )
      expect(analyticsService.trackGoogleSignInFailure).toHaveBeenCalledWith(
        expect.any(String)
      )
      expect(result.current.isLoading).toBe(false)
    })
  })

  it("should handle sign out", async () => {
    const { result } = renderHook(() => useGoogleAuth(mockOnAuthStateChange))

    await act(async () => {
      await result.current.handleSignOut()
    })

    expect(analyticsService.trackSignOut).toHaveBeenCalled()
    expect(signOut).toHaveBeenCalled()
    expect(result.current.isLoading).toBe(false)
    expect(result.current.authError).toBeNull()
  })

  it("should handle sign out errors", async () => {
    const { result } = renderHook(() => useGoogleAuth(mockOnAuthStateChange))
    ;(signOut as jest.Mock).mockRejectedValue(new Error("SignOut Failed"))

    await act(async () => {
      await result.current.handleSignOut()
    })

    expect(result.current.authError).toContain("Sign-out error: SignOut Failed")
    expect(result.current.isLoading).toBe(false)
  })
})

================
File: __tests__/useGuessAnimation.test.tsx
================
import { renderHook } from "@testing-library/react-native"
import { useGuessAnimation } from "../src/utils/hooks/useGuessAnimation"
import { useThemeTokens } from "../src/utils/hooks/useStyles"

// Mock Reanimated
// We need a semi-functional mock to verify values change
jest.mock("react-native-reanimated", () => {
  const Reanimated = jest.requireActual("react-native-reanimated/mock")
  return {
    ...Reanimated,
    withTiming: (toValue: number, config: any, callback: any) => {
      // Return the value so we can inspect it in tests, simpler than full simulation
      if (callback) setTimeout(() => callback(true), config.duration || 0)
      return { value: toValue } // In real app this is an object, for test verification this suffices if we mock the styles
    },
    withSequence: (...args: any[]) => args[args.length - 1], // Return last value for simplicity in checking final state
    withDelay: (delay: number, animation: any) => animation,
    useSharedValue: (initial: any) => ({ value: initial }),
    useAnimatedStyle: (fn: Function) => fn(),
    interpolate: () => 0, // Simplified return
  }
})

// Mock Theme
jest.mock("../src/utils/hooks/useStyles")
const mockTheme = {
  colors: {
    surface: "#surface",
    success: "#success",
    error: "#error",
  },
}
;(useThemeTokens as jest.Mock).mockReturnValue(mockTheme)

describe("Hook: useGuessAnimation", () => {
  beforeEach(() => {
    jest.useFakeTimers()
  })

  afterEach(() => {
    jest.useRealTimers()
  })

  it("should initialize with default values", () => {
    const { result } = renderHook(() =>
      useGuessAnimation({
        isCorrect: false,
        isLastGuess: false,
        lastGuessResult: null,
        theme: mockTheme as any,
      })
    )

    // Check initial styles structure
    // Since we mocked useAnimatedStyle to execute immediately, we can check the result
    expect(result.current.animatedTileStyle).toBeDefined()
    expect(result.current.animatedContentStyle).toBeDefined()
  })

  // Note: Testing exact animation sequences with shared values in Jest often requires
  // checking that specific 'withTiming' / 'withSequence' functions were CALLED with expected params.
  // However, since we verify the hook doesn't crash and returns styles,
  // we rely on the mocks.

  it("should trigger success animation flow when correct", () => {
    // We can't easily spy on internal shared values without a more complex mock.
    // Instead, we verify the hook runs without error under success conditions.
    // Integration tests or Detox are better for visual verification.

    const { result } = renderHook(() =>
      useGuessAnimation({
        isCorrect: true,
        isLastGuess: true,
        lastGuessResult: { itemId: 1, correct: true },
        theme: mockTheme as any,
      })
    )

    expect(result.current.animatedTileStyle).toBeTruthy()
  })

  it("should trigger failure animation flow when incorrect", () => {
    const { result } = renderHook(() =>
      useGuessAnimation({
        isCorrect: false,
        isLastGuess: true,
        lastGuessResult: { itemId: 1, correct: false, feedback: "Wrong" },
        theme: mockTheme as any,
      })
    )

    expect(result.current.animatedFeedbackStyle).toBeTruthy()
  })
})

================
File: __tests__/useHintLogic.test.tsx
================
import { renderHook, act } from "@testing-library/react-native"
import { useHintLogic } from "../src/utils/hooks/useHintLogic"
import { useGameStore } from "../src/state/gameStore"
import { defaultPlayerGame } from "../src/models/default"

// Mock dependencies
jest.mock("../src/utils/hapticsService", () => ({
  hapticsService: { light: jest.fn(), medium: jest.fn() },
}))
jest.mock("react-native/Libraries/LayoutAnimation/LayoutAnimation", () => ({
  ...jest.requireActual(
    "react-native/Libraries/LayoutAnimation/LayoutAnimation"
  ),
  configureNext: jest.fn(),
}))

describe("Hook: useHintLogic", () => {
  const initialState = useGameStore.getState()
  const mockItem = {
    id: 1,
    title: "Test",
    description: "Desc",
    posterPath: "",
    releaseDate: "",
    metadata: {},
    hints: [
      { type: "director", label: "Director", value: "Nolan" },
      { type: "genre", label: "Genre", value: "Action" },
    ],
  }

  beforeEach(() => {
    useGameStore.setState({
      ...initialState,
      playerGame: { ...defaultPlayerGame, triviaItem: mockItem, hintsUsed: {} },
      // Ensure hints are available
      playerStats: { ...initialState.playerStats, hintsAvailable: 5 },
      // Explicitly set Difficulty to LEVEL_2 which maps to USER_SPEND strategy
      difficulty: "LEVEL_2",
      isInteractionsDisabled: false,
    })
  })

  it("should allow toggling hint options in USER_SPEND mode", () => {
    const { result } = renderHook(() => useHintLogic())

    expect(result.current.showHintOptions).toBe(false)

    act(() => {
      result.current.handleToggleHintOptions()
    })

    expect(result.current.showHintOptions).toBe(true)
  })

  it("should correctly calculate hint statuses", () => {
    useGameStore.setState({
      playerGame: {
        ...defaultPlayerGame,
        triviaItem: mockItem,
        hintsUsed: { director: true },
      },
    })

    const { result } = renderHook(() => useHintLogic())

    expect(result.current.hintStatuses["director"]).toBe("used")
    expect(result.current.hintStatuses["genre"]).toBe("available")
  })

  it("should disable toggle if difficulty is Hard (NONE_DISABLED)", () => {
    // Override difficulty for this specific test
    useGameStore.setState({ difficulty: "LEVEL_4" })

    const { result } = renderHook(() => useHintLogic())

    expect(result.current.hintStatuses["director"]).toBe("disabled")
  })

  it("should handle hint selection and trigger store action", () => {
    const { result } = renderHook(() => useHintLogic())
    const spyUseHint = jest.spyOn(useGameStore.getState(), "useHint")

    // 1. Open options first (not strictly required by logic but good for realism)
    act(() => {
      result.current.handleToggleHintOptions()
    })

    // 2. Select a hint
    act(() => {
      result.current.handleHintSelection("genre")
    })

    // 3. Verify action was called
    expect(spyUseHint).toHaveBeenCalledWith("genre")

    // 4. Verify display text updated (logic hook sets this state locally on selection)
    expect(result.current.displayedHintText).toBe("Action")
  })
})

================
File: __tests__/useStyles.test.tsx
================
import { renderHook } from "@testing-library/react-native"
import { useStyles, useThemeTokens } from "../src/utils/hooks/useStyles"
import * as ThemeContext from "../src/contexts/themeContext"
import { lightColors, darkColors } from "../src/styles/themes"

// Mock context
jest.mock("../src/contexts/themeContext")

describe("Hooks: useStyles", () => {
  const mockSetTheme = jest.fn()

  beforeEach(() => {
    jest.clearAllMocks()
  })

  it("should return styles using the current theme colors", () => {
    // Mock Light Theme
    jest.spyOn(ThemeContext, "useTheme").mockReturnValue({
      theme: "light",
      colorScheme: "light",
      colors: lightColors,
      setTheme: mockSetTheme,
    })

    const styleFactory = (theme: any) => ({
      container: {
        backgroundColor: theme.colors.background,
        padding: theme.spacing.medium,
      },
    })

    const { result } = renderHook(() => useStyles(styleFactory))

    expect(result.current.container.backgroundColor).toBe(
      lightColors.background
    )
  })

  it("should update styles when theme changes to dark", () => {
    // Mock Dark Theme
    jest.spyOn(ThemeContext, "useTheme").mockReturnValue({
      theme: "dark",
      colorScheme: "dark",
      colors: darkColors,
      setTheme: mockSetTheme,
    })

    const styleFactory = (theme: any) => ({
      text: {
        color: theme.colors.textPrimary,
      },
    })

    const { result } = renderHook(() => useStyles(styleFactory))

    expect(result.current.text.color).toBe(darkColors.textPrimary)
  })

  it("should provide access to raw theme tokens", () => {
    jest.spyOn(ThemeContext, "useTheme").mockReturnValue({
      theme: "light",
      colorScheme: "light",
      colors: lightColors,
      setTheme: mockSetTheme,
    })

    const { result } = renderHook(() => useThemeTokens())

    expect(result.current.colors).toBe(lightColors)
    expect(result.current.spacing).toBeDefined()
    expect(result.current.typography).toBeDefined()
    expect(result.current.shadows).toBeDefined()
  })
})

================
File: __tests__/utils.test.ts
================
import { u } from "../src/styles/utils"

describe("Utils: Global Styles (u)", () => {
  it("should define flexbox utilities", () => {
    expect(u.flex).toEqual({ flex: 1 })
    expect(u.flexRow).toEqual({ flexDirection: "row" })
    expect(u.justifyCenter).toEqual({ justifyContent: "center" })
    expect(u.alignCenter).toEqual({ alignItems: "center" })
  })

  it("should define sizing utilities", () => {
    expect(u.wFull).toEqual({ width: "100%" })
    expect(u.hFull).toEqual({ height: "100%" })
  })

  it("should define spacing utilities correctly", () => {
    expect(u.pSm).toHaveProperty("padding")
    expect(u.mSm).toHaveProperty("margin")

    expect(u.mtMd).toHaveProperty("marginTop")
    // mbLg does not exist, checking mbMd instead
    expect(u.mbMd).toHaveProperty("marginBottom")
    expect(u.pxSm).toHaveProperty("paddingHorizontal")
  })

  it("should define text utilities", () => {
    expect(u.textCenter).toEqual({ textAlign: "center" })
    expect(u.fontBold).toHaveProperty("fontFamily", "Arvo-Bold")
  })
})

================
File: __tests__/whereToWatch.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import WhereToWatch from "../src/components/whereToWatch"

// --- Mocks ---
// Override the global vector-icons mock to include FontAwesome5
jest.mock("@expo/vector-icons", () => {
  const { Text } = require("react-native")
  const MockIcon = ({ name, ...props }: any) => (
    <Text testID={`mock-icon-${name}`} {...props}>
      {name}
    </Text>
  )
  return {
    FontAwesome5: MockIcon,
  }
})

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("WhereToWatch Component", () => {
  it("should render the title", () => {
    renderWithTheme(<WhereToWatch />)
    expect(screen.getByText("Where to Watch")).toBeTruthy()
  })

  it("should render the streaming provider icons/labels", () => {
    renderWithTheme(<WhereToWatch />)

    // We check for the text labels of the providers
    expect(screen.getByText("Netflix")).toBeTruthy()
    expect(screen.getByText("Prime Video")).toBeTruthy()
    expect(screen.getByText("Disney+")).toBeTruthy()
    expect(screen.getByText("Rent")).toBeTruthy()
  })

  it("should render the disclaimer text", () => {
    renderWithTheme(<WhereToWatch />)

    expect(
      screen.getByText(
        "*Streaming availability is illustrative and may change."
      )
    ).toBeTruthy()
  })

  it("should verify icons are rendered", () => {
    renderWithTheme(<WhereToWatch />)

    // Verify the testIDs generated by our local mock
    expect(screen.getByTestId("mock-icon-netflix")).toBeTruthy()
    expect(screen.getByTestId("mock-icon-amazon")).toBeTruthy()
    expect(screen.getByTestId("mock-icon-plus")).toBeTruthy()
    expect(screen.getByTestId("mock-icon-ticket-alt")).toBeTruthy()
  })
})

================
File: __tests__/winChart.test.tsx
================
import React, { ReactElement } from "react"
import { render, screen, RenderOptions } from "@testing-library/react-native"
import { ThemeProvider } from "../src/contexts/themeContext"
import WinChart from "../src/components/winChart"

// --- Mocks ---

jest.mock("victory-native", () => {
  const { View } = require("react-native")
  return {
    VictoryBar: (props: any) => (
      <View
        testID="mock-victory-bar"
        data-chart-data={JSON.stringify(props.data)}
      />
    ),
    VictoryChart: ({ children }: any) => (
      <View testID="mock-victory-chart">{children}</View>
    ),
    VictoryAxis: () => <View testID="mock-victory-axis" />,
    VictoryLabel: () => <View testID="mock-victory-label" />,
  }
})

jest.mock("../src/components/statItem", () => {
  const { Text, View } = require("react-native")
  return (props: any) => (
    <View testID={`stat-item-${props.label}`}>
      <Text>
        {props.label}: {props.value}
      </Text>
    </View>
  )
})

// --- Test Setup ---
const renderWithTheme = (ui: ReactElement, options?: RenderOptions) => {
  return render(<ThemeProvider>{ui}</ThemeProvider>, options)
}

describe("WinChart Component", () => {
  describe("Empty State", () => {
    it("should render empty message if total wins is 0", () => {
      const emptyWins = [0, 0, 0, 0, 0]
      renderWithTheme(<WinChart wins={emptyWins} />)

      expect(
        screen.getByText(
          "Your win distribution will appear here after your first win!"
        )
      ).toBeTruthy()

      expect(screen.queryByTestId("mock-victory-chart")).toBeNull()
    })
  })

  describe("Data Rendering", () => {
    it("should render the chart with correct data format", () => {
      const testWins = [1, 5, 2, 0, 1] // 1 win in 1 guess, 5 in 2 guesses, etc.
      renderWithTheme(<WinChart wins={testWins} />)

      const chart = screen.getByTestId("mock-victory-chart")
      expect(chart).toBeTruthy()

      const bar = screen.getByTestId("mock-victory-bar")

      // Verify data transformation: index -> x, count -> y
      // @ts-ignore
      const passedData = JSON.parse(bar.props["data-chart-data"])

      expect(passedData).toEqual([
        { x: 1, y: 1 },
        { x: 2, y: 5 },
        { x: 3, y: 2 },
        { x: 4, y: 0 },
        { x: 5, y: 1 },
      ])
    })

    it("should have a descriptive accessibility label", () => {
      const testWins = [1, 0, 2, 0, 0]
      renderWithTheme(<WinChart wins={testWins} />)

      const label = screen.getByLabelText(/Bar chart showing win distribution/)
      expect(label).toBeTruthy()

      expect(label.props.accessibilityLabel).toContain("1 win with 1 guess")
      expect(label.props.accessibilityLabel).toContain("2 wins with 3 guesses")
    })
  })
})

================
File: .expo-shared/assets.json
================
{
  "12bb71342c6255bbf50437ec8f4441c083f47cdb74bd89160c15e4f43e52a1cb": true,
  "40b842e832070c58deac6aa9e08fa459302ee3f9da492c7e77d93d2fbf4a56fd": true
}

================
File: .github/workflows/unit-tests.yml
================
name: Unit Tests

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  test:
    name: Run Tests & Coverage
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: Install Dependencies
        run: npm install

      - name: Type Check
        run: npx tsc --noEmit

      - name: Run Tests with Coverage
        run: npm test -- --watchAll=false --ci --maxWorkers=2 --coverage

      - name: Upload Coverage Report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-html
          path: coverage/lcov-report/
          retention-days: 5
    
      - name: Upload to Codecov
        uses: codecov/codecov-action@v3
        with:
          directory: ./coverage/
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: true

================
File: .idx/dev.nix
================
# To learn more about how to use Nix to configure your environment
# see: https://firebase.google.com/docs/studio/customize-workspace
{ pkgs, ... }: {
  # Which nixpkgs channel to use.
  channel = "stable-24.05"; # or "unstable"

  # Use https://search.nixos.org/packages to find packages
  packages = [
    # pkgs.go
    # pkgs.python311
    # pkgs.python311Packages.pip
    # pkgs.nodejs_20
    # pkgs.nodePackages.nodemon
  ];

  # Sets environment variables in the workspace
  env = {};
  idx = {
    # Search for the extensions you want on https://open-vsx.org/ and use "publisher.id"
    extensions = [
      # "vscodevim.vim"
    ];

    # Enable previews
    previews = {
      enable = true;
      previews = {
        # web = {
        #   # Example: run "npm run dev" with PORT set to IDX's defined port for previews,
        #   # and show it in IDX's web preview panel
        #   command = ["npm" "run" "dev"];
        #   manager = "web";
        #   env = {
        #     # Environment variables to set for your server
        #     PORT = "$PORT";
        #   };
        # };
      };
    };

    # Workspace lifecycle hooks
    workspace = {
      # Runs when a workspace is first created
      onCreate = {
        # Example: install JS dependencies from NPM
        # npm-install = "npm install";
      };
      # Runs when the workspace is (re)started
      onStart = {
        # Example: start a background task to watch and re-build backend code
        # watch-backend = "npm run watch-backend";
      };
    };
  };
}

================
File: .maestro/flows/give-up.yaml
================
appId: com.unrealities.talkietrivia
---
- launchApp:
    clearState: true

# 0. Wait for Load
- extendedWaitUntil:
    visible: "Search for a movie title..."
    timeout: 45000
- tapOn: 
    text: "Got it"
    optional: true

# 1. Test Cancel Logic
- scrollUntilVisible:
    element:
        id: "give-up-button"
    direction: DOWN
- tapOn: 
    id: "give-up-button"

- assertVisible: "Are you sure you want to give up on this movie?"
- tapOn: "Cancel"
# Ensure we are back in the game
- assertVisible: "Search for a movie title..."

# 2. Test Confirm Logic
- tapOn: 
    id: "give-up-button"
- tapOn: "Give Up"

# 3. Verify Game Over State
- extendedWaitUntil:
    visible: "So Close!"
    timeout: 5000
- assertVisible: "fold 'em" # Part of "Sometimes you just know when to fold 'em"

================
File: .maestro/flows/happy-path-win.yaml
================
appId: com.unrealities.talkietrivia
---
- launchApp:
    clearState: true

# 0. WAIT FOR DATA LOAD
- extendedWaitUntil:
    visible: "Search for a movie title..."
    timeout: 45000

# DISMISS TOOLTIP 1
- tapOn: 
    text: "Got it"
    optional: true

# 1. Handle Onboarding / Login
- tapOn: "Profile.*" 

- extendedWaitUntil:
    visible: "Sign In with Google"
    timeout: 5000

- tapOn: "Sign In with Google" 

- extendedWaitUntil:
    visible: "Sign Out E2E User"
    timeout: 8000

# 2. Go back to Game
- tapOn: "Game.*"
- extendedWaitUntil:
    visible: "Search for a movie title..."
    timeout: 5000

# 3. Search for a wrong movie
- tapOn: "Search for a movie title..."
- inputText: "Titanic"
- pressKey: Enter
- hideKeyboard

# DISMISS TOOLTIP 2
- extendedWaitUntil:
    visible: "Got it"
    timeout: 5000 
- tapOn: "Got it"

# Select Titanic
- assertVisible:
    id: "result-item-Titanic"
- tapOn:
    id: "result-item-Titanic"

# Verify feedback (Titanic shares Leonardo DiCaprio with Inception, so we get a hint!)
- extendedWaitUntil:
    visible: "You're on the right track with the Actors.*"
    timeout: 3000

# 4. Win the Game
- tapOn: "Search for a movie title..."
- inputText: "Inception"
- pressKey: Enter
- hideKeyboard

# Select Inception
- assertVisible:
    id: "result-item-Inception"
- tapOn: 
    id: "result-item-Inception"

# 5. Verify Win State
- extendedWaitUntil:
    visible: "You Got It!"
    timeout: 5000
- assertVisible: "Share Your Result"

# 6. Verify Persistence
- tapOn: "Profile.*"
- extendedWaitUntil:
    visible: "Statistics"
    timeout: 5000

# Scroll to find stats (Handles small screens)
- scrollUntilVisible:
    element:
        text: "Games Played"
    direction: DOWN
    timeout: 5000

# Check stats exist
- assertVisible: "Games Played"
- assertVisible: "Current Streak"

================
File: .maestro/flows/history-check.yaml
================
appId: com.unrealities.talkietrivia
---
- launchApp:
    clearState: true

# 0. Init
- extendedWaitUntil:
    visible: "Search for a movie title..."
    timeout: 45000
# DISMISS TOOLTIP 1
- tapOn: 
    text: "Got it"
    optional: true

# 1. Change Difficulty
- tapOn: "Profile.*"
- scrollUntilVisible:
    element:
        text: "Hard"
    direction: DOWN
- tapOn: "Hard"

# 2. Verify Difficulty Impact (Go back to game)
- tapOn: "Game"
# In Hard mode, the hint section usually disappears or changes state. 
# We can check if the Difficulty selector at the top of the game screen updated.
- assertVisible: "Hard" 

# 3. Complete a quick game (Win)
- tapOn: "Search for a movie title..."
- inputText: "Inception"
- pressKey: Enter
- hideKeyboard
- extendedWaitUntil:
    visible: "result-item-Inception"
    timeout: 5000
- tapOn: "result-item-Inception"
- extendedWaitUntil:
    visible: "You Got It!"
    timeout: 5000

# 4. Check History
- tapOn: "Profile"
- scrollUntilVisible:
    element:
        text: "Game History"
    direction: DOWN
    timeout: 5000

# Verify the history item exists (Inception)
# Note: You might need to remove accessible={true} from GameHistoryItem in `src/components/gameHistory.tsx` 
# just like we did for PlayerStats for this to work reliably.
- scrollUntilVisible:
    element:
        text: "Inception"
    direction: DOWN
    timeout: 5000
- tapOn: "Inception"

# 5. Verify History Detail Modal
- extendedWaitUntil:
    visible: "Your Guesses"
    timeout: 3000
- assertVisible: "Inception (2010)"
- tapOn: "Close"

================
File: .maestro/flows/losing-game.yaml
================
appId: com.unrealities.talkietrivia
---
- launchApp:
    clearState: true

# 0. Wait for Load
- extendedWaitUntil:
    visible: "Search for a movie title..."
    timeout: 45000

# Dismiss Tooltip
- tapOn: 
    text: "Got it"
    optional: true

# 1. Make 5 Incorrect Guesses
# We use a loop concept by repeating commands, selecting 5 different movies
- runFlow:
    commands:
        - tapOn: "Search for a movie title..."
        - inputText: "Titanic"
        - pressKey: Enter
        - hideKeyboard
        - extendedWaitUntil:
            visible: "result-item-Titanic (1997)"
            timeout: 5000
        - tapOn: "result-item-Titanic (1997)"
        - waitForAnimationToEnd

        - tapOn: "Search for a movie title..."
        - inputText: "Avatar"
        - pressKey: Enter
        - hideKeyboard
        - extendedWaitUntil:
            visible: "result-item-Avatar"
            timeout: 5000
        - tapOn: "result-item-Avatar"
        - waitForAnimationToEnd

        - tapOn: "Search for a movie title..."
        - inputText: "Matrix"
        - pressKey: Enter
        - hideKeyboard
        - extendedWaitUntil:
            visible: "result-item-The Matrix"
            timeout: 5000
        - tapOn: "result-item-The Matrix"
        - waitForAnimationToEnd

        - tapOn: "Search for a movie title..."
        - inputText: "Shrek"
        - pressKey: Enter
        - hideKeyboard
        - extendedWaitUntil:
            visible: "result-item-Shrek"
            timeout: 5000
        - tapOn: "result-item-Shrek"
        - waitForAnimationToEnd

        # Final Guess (Game Over)
        - tapOn: "Search for a movie title..."
        - inputText: "Jaws"
        - pressKey: Enter
        - hideKeyboard
        - extendedWaitUntil:
            visible: "result-item-Jaws"
            timeout: 5000
        - tapOn: "result-item-Jaws"

# 2. Verify Loss State
- extendedWaitUntil:
    visible: "So Close!"
    timeout: 5000
- assertVisible: "Better luck next time."

# 3. Verify Correct Answer is Revealed
# Assuming Inception is the daily movie based on mocks
- assertVisible: "Inception" 
- assertVisible: "The Full Plot"

# 4. Verify Stats Reset
- tapOn: "Profile"
- scrollUntilVisible:
    element:
        text: "Current Streak"
    direction: DOWN
- assertVisible: "Current Streak" 
# Note: We can't easily assert "0" without ID, but presence of the block confirms navigation.

================
File: src/app/(tabs)/_layout.tsx
================
import React from "react"
import { Tabs } from "expo-router"
import { useFonts } from "expo-font"
import LoadingIndicator from "../../components/loadingIndicator"
import ErrorMessage from "../../components/errorMessage"
import { FontAwesome } from "@expo/vector-icons"
import { useTheme } from "../../contexts/themeContext"

const TabLayout = () => {
  const { colors } = useTheme()

  const [fontsLoaded, fontError] = useFonts({
    "Arvo-Bold": require("../../../assets/fonts/Arvo-Bold.ttf"),
    "Arvo-Italic": require("../../../assets/fonts/Arvo-Italic.ttf"),
    "Arvo-Regular": require("../../../assets/fonts/Arvo-Regular.ttf"),
    ...FontAwesome.font,
  })

  if (!fontsLoaded) {
    return <LoadingIndicator />
  }

  if (fontError) {
    return <ErrorMessage message={fontError.message} />
  }

  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarActiveTintColor: colors.primary,
        tabBarInactiveTintColor: colors.textSecondary,
        tabBarActiveBackgroundColor: colors.surface,
        tabBarItemStyle: {
          marginVertical: 5,
          marginHorizontal: 10,
          borderRadius: 10,
          paddingVertical: 5,
          justifyContent: "center",
          alignItems: "center",
        },
        tabBarLabelStyle: {
          fontFamily: "Arvo-Bold",
          fontSize: 16,
          margin: 0,
          padding: 0,
        },
        tabBarIconStyle: {
          display: "none",
        },
        tabBarStyle: {
          paddingHorizontal: 20,
          backgroundColor: colors.background,
          borderTopWidth: 1,
          borderTopColor: colors.border,
        },
      }}
      initialRouteName="game"
    >
      <Tabs.Screen name="game" options={{ title: "Game" }} />
      <Tabs.Screen name="profile" options={{ title: "Profile" }} />
      {/* Hide the index route from the tab bar */}
      <Tabs.Screen
        name="index"
        options={{
          href: null,
        }}
      />
    </Tabs>
  )
}

export default TabLayout

================
File: src/app/(tabs)/game.tsx
================
import React, { lazy, Suspense } from "react"
import { ScrollView, View, ViewStyle } from "react-native"
import { LinearGradient } from "expo-linear-gradient"
import LoadingIndicator from "../../components/loadingIndicator"
import { useTheme } from "../../contexts/themeContext"
import { useGameStore } from "../../state/gameStore"
import TitleHeader from "../../components/titleHeader"
import { useStyles, Theme } from "../../utils/hooks/useStyles"
import { u } from "../../styles/utils"
import { GAME_MODE_CONFIG } from "../../config/difficulty"

const GameplayContainer = lazy(
  () => import("../../components/gameplayContainer")
)
const ConfettiCelebration = lazy(
  () => import("../../components/confettiCelebration")
)
const FlashMessages = lazy(() => import("../../components/flashMessages"))
const GameDifficultyToggle = lazy(
  () => import("../../components/gameDifficultyToggle")
)

const GameLayout = ({ children }: { children: React.ReactNode }) => {
  const gameMode = useGameStore((state) => state.gameMode)
  const styles = useStyles(themedStyles)
  return (
    <ScrollView
      contentContainerStyle={styles.scrollContentContainer}
      style={u.flex}
      showsVerticalScrollIndicator={false}
      keyboardShouldPersistTaps="handled"
    >
      <View style={styles.headerContainer}>
        <TitleHeader title={GAME_MODE_CONFIG[gameMode].title} />
        <Suspense fallback={null}>
          <GameDifficultyToggle />
        </Suspense>
      </View>
      {children}
    </ScrollView>
  )
}

const GameScreen = () => {
  const showConfetti = useGameStore((state) => state.showConfetti)
  const handleConfettiStop = useGameStore((state) => state.handleConfettiStop)
  const flashMessage = useGameStore((state) => state.flashMessage)
  const { colors } = useTheme()

  return (
    <LinearGradient
      colors={[colors.background, colors.backgroundLight]}
      style={u.flex}
    >
      <GameLayout>
        <Suspense fallback={<LoadingIndicator />}>
          <GameplayContainer />
        </Suspense>
      </GameLayout>
      <Suspense fallback={null}>
        <FlashMessages message={flashMessage} />
        <ConfettiCelebration
          startConfetti={showConfetti}
          onConfettiStop={handleConfettiStop}
        />
      </Suspense>
    </LinearGradient>
  )
}

interface GameScreenStyles {
  scrollContentContainer: ViewStyle
  headerContainer: ViewStyle
}

const themedStyles = (theme: Theme): GameScreenStyles => ({
  scrollContentContainer: {
    paddingTop: theme.spacing.large,
    paddingBottom: theme.spacing.extraLarge,
    alignItems: "center",
    flexGrow: 1,
  },
  headerContainer: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    width: "100%",
    paddingHorizontal: theme.spacing.small,
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.border,
    zIndex: 1,
  },
})

export default GameScreen

================
File: src/app/(tabs)/index.tsx
================
import { Redirect } from "expo-router"

export default function Index() {
  return <Redirect href="/game" />
}

================
File: src/app/(tabs)/profile.tsx
================
import React, { lazy, Suspense, useState, useCallback } from "react"
import { ScrollView, View, Text, ViewStyle, TextStyle } from "react-native"
import { LinearGradient } from "expo-linear-gradient"
import LoadingIndicator from "../../components/loadingIndicator"
import { useAuth } from "../../contexts/authContext"
import { GameHistoryEntry } from "../../models/gameHistory"
import { useGameStore } from "../../state/gameStore"
import { FontAwesome } from "@expo/vector-icons"
import ProfileSection from "../../components/profileSection"
import { useStyles, Theme } from "../../utils/hooks/useStyles"
import { useTheme } from "../../contexts/themeContext"
import { u } from "../../styles/utils"

const GoogleLogin = lazy(() => import("../../components/googleLogin"))
const PlayerStatsContainer = lazy(() => import("../../components/playerStats"))
const GameHistory = lazy(() => import("../../components/gameHistory"))
const ThemeSelector = lazy(() => import("../../components/themeSelector"))
const DifficultySelector = lazy(
  () => import("../../components/difficultySelector")
)
const HistoryDetailModal = lazy(
  () => import("../../components/historyDetailModal")
)

const ProfileScreen: React.FC = () => {
  const { player, user } = useAuth()
  const playerStats = useGameStore((state) => state.playerStats)
  const loading = useGameStore((state) => state.loading)
  const styles = useStyles(themedStyles)
  const { colors } = useTheme()

  const [selectedHistoryItem, setSelectedHistoryItem] =
    useState<GameHistoryEntry | null>(null)

  const handleHistoryItemPress = useCallback((item: GameHistoryEntry) => {
    setSelectedHistoryItem(item)
  }, [])

  const handleModalClose = useCallback(() => {
    setSelectedHistoryItem(null)
  }, [])

  const isGoogleSignedIn = player && user && !user.isAnonymous
  const isUserAuthenticated = player && user

  const displayName = player?.name || "Guest"

  if (!isUserAuthenticated || loading) {
    return (
      <LinearGradient
        colors={[colors.background, colors.backgroundLight]}
        style={u.flex}
      >
        <LoadingIndicator />
      </LinearGradient>
    )
  }

  return (
    <>
      <LinearGradient
        colors={[colors.background, colors.backgroundLight]}
        style={u.flex}
      >
        <ScrollView
          contentContainerStyle={styles.scrollContentContainer}
          showsVerticalScrollIndicator={false}
        >
          <Suspense fallback={<LoadingIndicator />}>
            <View style={styles.contentArea}>
              <View style={styles.header}>
                <Text style={styles.title}>Welcome, {displayName}!</Text>
              </View>

              {!isGoogleSignedIn && (
                <View style={styles.signInPromptContainer}>
                  <FontAwesome
                    name="google"
                    size={styles.signInPromptIcon.fontSize}
                    color={styles.signInPromptIcon.color}
                    style={u.mbMd}
                  />
                  <Text style={styles.signInPromptTitle}>
                    Save Your Progress
                  </Text>
                  <Text style={styles.signInPromptText}>
                    Sign in with Google below to secure your stats permanently
                    and join the leaderboards.
                  </Text>
                  <GoogleLogin />
                </View>
              )}

              {isGoogleSignedIn && (
                <ProfileSection title="Account" icon="user">
                  <GoogleLogin />
                </ProfileSection>
              )}

              <ProfileSection title="Settings" icon="cog">
                <DifficultySelector />
                <View style={styles.divider} />
                <ThemeSelector />
              </ProfileSection>

              <ProfileSection title="Statistics" icon="bar-chart">
                <PlayerStatsContainer
                  player={player}
                  playerStats={playerStats}
                />
              </ProfileSection>

              <ProfileSection title="Game History" icon="history">
                <GameHistory onHistoryItemPress={handleHistoryItemPress} />
              </ProfileSection>
            </View>
          </Suspense>
        </ScrollView>
      </LinearGradient>
      <Suspense fallback={null}>
        <HistoryDetailModal
          historyItem={selectedHistoryItem}
          onClose={handleModalClose}
        />
      </Suspense>
    </>
  )
}

interface ProfileScreenStyles {
  scrollContentContainer: ViewStyle
  contentArea: ViewStyle
  header: ViewStyle
  title: TextStyle
  divider: ViewStyle
  signInPromptContainer: ViewStyle
  signInPromptIcon: TextStyle
  signInPromptTitle: TextStyle
  signInPromptText: TextStyle
}

const themedStyles = (theme: Theme): ProfileScreenStyles => ({
  scrollContentContainer: {
    padding: theme.spacing.medium,
    paddingTop:
      theme.responsive.platform === "ios"
        ? theme.responsive.scale(60)
        : theme.responsive.scale(30),
    alignItems: "center",
    paddingBottom: theme.spacing.extraLarge,
  },
  contentArea: {
    width: "100%",
    maxWidth: theme.responsive.scale(500),
    alignSelf: "center",
  },
  header: {
    alignItems: "center",
    marginBottom: theme.spacing.medium,
    paddingBottom: theme.spacing.small,
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.border,
    width: "100%",
  },
  title: {
    ...theme.typography.heading2,
    color: theme.colors.textPrimary,
  },
  divider: {
    height: 1,
    backgroundColor: theme.colors.border,
    marginVertical: theme.spacing.medium,
  },
  signInPromptContainer: {
    alignItems: "center",
    justifyContent: "center",
    padding: theme.spacing.large,
    backgroundColor: theme.colors.surface,
    borderRadius: theme.responsive.scale(12),
    width: "100%",
    maxWidth: theme.responsive.scale(500),
    marginBottom: theme.spacing.large,
  },
  signInPromptIcon: {
    fontSize: theme.responsive.scale(30),
    color: theme.colors.primary,
  },
  signInPromptTitle: {
    ...theme.typography.heading2,
    color: theme.colors.primary,
    marginTop: theme.spacing.medium,
    marginBottom: theme.spacing.small,
    textAlign: "center",
  },
  signInPromptText: {
    ...theme.typography.bodyText,
    textAlign: "center",
    marginBottom: theme.spacing.small,
  },
})

export default ProfileScreen

================
File: src/app/_layout.tsx
================
import React, { useCallback, useEffect, useState } from "react"
import { Slot } from "expo-router"
import { View, LogBox, ViewStyle, TextStyle } from "react-native"
import ErrorBoundary from "../components/errorBoundary"
import { NetworkProvider, useNetwork } from "../contexts/networkContext"
import { AuthProvider, useAuth } from "../contexts/authContext"
import { ThemeProvider } from "../contexts/themeContext"
import LoadingIndicator from "../components/loadingIndicator"
import ErrorMessage from "../components/errorMessage"
import { useGameStore } from "../state/gameStore"
import { useStyles, Theme } from "../utils/hooks/useStyles"

// --- LOGBOX SUPPRESSION ---
// We ignore specific warnings to prevent the Yellow Box from blocking
// E2E test interactions (like the bottom tab bar).
LogBox.ignoreLogs([
  "Warning: VictoryPie",
  "Warning: Slice",
  "Warning: VictoryLabel",
  "Linking requires a build-time setting",
  "(ADVICE)",
  "shadow set but cannot calculate",
  "Victory Native components failed to load",
])

function RootLayoutNav() {
  const { isNetworkConnected } = useNetwork()
  const styles = useStyles(themedStyles)
  const [retryKey, setRetryKey] = useState(0)

  const { player, loading: authLoading, error: authError } = useAuth()

  const initializeGame = useGameStore((state) => state.initializeGame)
  const gameLoading = useGameStore((state) => state.loading)
  const gameError = useGameStore((state) => state.error)

  useEffect(() => {
    if (player && isNetworkConnected && !authError) {
      initializeGame(player)
    }
  }, [player, isNetworkConnected, retryKey, authError, initializeGame])

  const handleRetry = useCallback(() => {
    setRetryKey((prevKey) => prevKey + 1)
  }, [])

  if (isNetworkConnected === null) {
    return <LoadingIndicator message="Checking network connection..." />
  }

  if (!isNetworkConnected) {
    return (
      <View style={styles.container}>
        <ErrorMessage
          message="No Network Connection. Please check your internet and try again."
          onRetry={handleRetry}
        />
      </View>
    )
  }

  if (authLoading) {
    return <LoadingIndicator message="Authenticating user session..." />
  }

  if (gameLoading) {
    return <LoadingIndicator message="Loading daily movie and user data..." />
  }

  const criticalError = authError || gameError
  if (criticalError) {
    let displayMessage = `Critical Setup Error: ${criticalError}. Please try restarting the app.`

    if (authError?.includes("Missing or insufficient permissions")) {
      displayMessage =
        "Critical Error: Cannot access user data (Firebase permissions failure). This usually indicates an issue with your account setup or backend configuration. Please restart the app or contact support."
    }

    return (
      <View style={styles.container}>
        <ErrorMessage message={displayMessage} onRetry={handleRetry} />
      </View>
    )
  }

  return <Slot key={retryKey} />
}

export default function RootLayout() {
  return (
    <ErrorBoundary>
      <ThemeProvider>
        <NetworkProvider>
          <AuthProvider>
            <RootLayoutNav />
          </AuthProvider>
        </NetworkProvider>
      </ThemeProvider>
    </ErrorBoundary>
  )
}

interface RootLayoutStyles {
  container: ViewStyle
  errorText: TextStyle
}

// Colocate the styles directly within the layout file
const themedStyles = (theme: Theme): RootLayoutStyles => ({
  container: {
    backgroundColor: theme.colors.background,
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: theme.responsive.scale(10),
  },
  errorText: {
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(18),
    color: theme.colors.error,
    textAlign: "center",
    width: "80%",
  },
})

================
File: src/components/gameOver/fullPlotSection.tsx
================
import React from "react"
import { View, ViewStyle, TextStyle } from "react-native"
import { useStyles, Theme } from "../../utils/hooks/useStyles"
import { Typography } from "../ui/typography"
import { useGameStore } from "../../state/gameStore"
import { GAME_MODE_CONFIG } from "../../config/difficulty"

interface FullPlotSectionProps {
  overview: string
}

const FullPlotSection: React.FC<FullPlotSectionProps> = ({ overview }) => {
  const gameMode = useGameStore((state) => state.gameMode)
  const styles = useStyles(themedStyles)

  return (
    <View style={styles.container}>
      <Typography variant="body" style={styles.title}>
        {GAME_MODE_CONFIG[gameMode].fullDescriptionTitle}
      </Typography>
      <Typography variant="body" style={styles.text}>
        {overview}
      </Typography>
    </View>
  )
}

interface FullPlotStyles {
  container: ViewStyle
  title: TextStyle
  text: TextStyle
}

const themedStyles = (theme: Theme): FullPlotStyles => ({
  container: {
    width: "100%",
    marginTop: theme.spacing.extraLarge,
    padding: theme.spacing.medium,
    backgroundColor: theme.colors.background,
    borderRadius: theme.responsive.scale(8),
  },
  title: {
    fontFamily: "Arvo-Bold",
    color: theme.colors.textSecondary,
    textAlign: "center",
    marginBottom: theme.spacing.small,
  },
  text: {
    color: theme.colors.textPrimary,
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(14),
    lineHeight: theme.responsive.responsiveFontSize(20),
  },
})

export default FullPlotSection

================
File: src/components/gameOver/shareResultButton.tsx
================
import React, { useState } from "react"
import { View, Alert, ViewStyle } from "react-native"
import { PlayerGame } from "../../models/game"
import { shareGameResult } from "../../utils/shareUtils"
import { Button } from "../ui/button"
import { useStyles, Theme } from "../../utils/hooks/useStyles"
import { u } from "../../styles/utils"

interface ShareResultButtonProps {
  playerGame: PlayerGame
}

const ShareResultButton: React.FC<ShareResultButtonProps> = ({
  playerGame,
}) => {
  const styles = useStyles(themedStyles)
  const [isSharing, setIsSharing] = useState(false)

  const handleShare = async () => {
    if (isSharing) return
    setIsSharing(true)
    try {
      await shareGameResult(playerGame)
    } catch (error) {
      console.error("Error during sharing process:", error)
      Alert.alert(
        "Sharing Failed",
        "An error occurred while trying to share your results."
      )
    } finally {
      setIsSharing(false)
    }
  }

  return (
    <View style={[u.wFull, u.alignCenter, styles.container]}>
      <Button
        title="Share Your Result"
        onPress={handleShare}
        isLoading={isSharing}
        variant="tertiary"
        style={styles.button}
      />
    </View>
  )
}

interface ShareButtonStyles {
  container: ViewStyle
  button: ViewStyle
}

const themedStyles = (theme: Theme): ShareButtonStyles => ({
  container: {
    paddingVertical: theme.spacing.medium,
  },
  button: {
    width: "80%",
  },
})

export default ShareResultButton

================
File: src/components/guess/emptyGuessTile.tsx
================
import React from "react"
import { View, Text, ViewStyle, TextStyle } from "react-native"
import { useStyles, Theme } from "../../utils/hooks/useStyles"

interface EmptyGuessTileProps {
  index: number
  testID?: string
}

export const EmptyGuessTile = ({ index, testID }: EmptyGuessTileProps) => {
  const styles = useStyles(themedStyles)
  return (
    <View style={styles.emptyGuessTile} testID={testID}>
      <Text style={styles.guessNumber}>{index + 1}</Text>
    </View>
  )
}

interface EmptyGuessTileStyles {
  emptyGuessTile: ViewStyle
  guessNumber: TextStyle
}

const themedStyles = (theme: Theme): EmptyGuessTileStyles => ({
  emptyGuessTile: {
    flexDirection: "row",
    alignItems: "center",
    borderRadius: theme.responsive.scale(8),
    paddingHorizontal: theme.spacing.medium,
    minHeight: theme.responsive.scale(44),
    marginBottom: theme.spacing.small,
    borderWidth: 2,
    borderColor: theme.colors.border,
    borderStyle: "dashed",
  },
  guessNumber: {
    color: theme.colors.textSecondary,
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(14),
    marginRight: theme.spacing.small,
  },
})

================
File: src/components/guess/guessRow.tsx
================
import React, { memo } from "react"
import { Text, View, ViewStyle, TextStyle, StyleSheet } from "react-native"
import Animated from "react-native-reanimated"
import Ionicons from "@expo/vector-icons/Ionicons"
import { BasicTriviaItem } from "../../models/trivia"
import { Guess, HintInfo } from "../../models/game"
import { useStyles, Theme, useThemeTokens } from "../../utils/hooks/useStyles"
import { useGuessAnimation } from "../../utils/hooks/useGuessAnimation"
import { u } from "../../styles/utils"

type GuessResult = {
  itemId: number | string
  correct: boolean
  feedback?: string | null
  hintInfo?: HintInfo[] | null
} | null

interface GuessRowProps {
  index: number
  guess: Guess
  basicItems: readonly BasicTriviaItem[]
  isLastGuess: boolean
  lastGuessResult: GuessResult
  correctItemId: number | string
}

export const GuessRow = memo(
  ({
    index,
    guess,
    basicItems,
    isLastGuess,
    lastGuessResult,
    correctItemId,
  }: GuessRowProps) => {
    const theme = useThemeTokens()
    const styles = useStyles(themedStyles)

    const { animatedTileStyle, animatedContentStyle, animatedFeedbackStyle } =
      useGuessAnimation({
        isCorrect: guess.itemId === correctItemId,
        isLastGuess,
        lastGuessResult,
        theme,
      })

    const guessItem = basicItems.find(
      (item: BasicTriviaItem) => item.id === guess.itemId
    )
    const guessTitle = guessItem?.title || "Unknown Item"
    const releaseYear = guessItem?.releaseDate
      ? ` (${new Date(guessItem.releaseDate).getFullYear()})`
      : ""
    const isCorrect = guess.itemId === correctItemId
    const feedbackMessage =
      isLastGuess && !isCorrect ? lastGuessResult?.feedback : null
    const hintInfoList = guess.hintInfo

    const getIconNameForHint = (
      hintType: string
    ): keyof typeof Ionicons.glyphMap => {
      const iconMap: Record<string, keyof typeof Ionicons.glyphMap> = {
        decade: "calendar-outline",
        director: "film-outline",
        developer: "game-controller-outline",
        actor: "person-outline",
        actors: "people-outline",
        genre: "folder-open-outline",
      }
      return iconMap[hintType] || "information-circle-outline"
    }

    const getHintDisplayValue = (hint: HintInfo): string => {
      if (
        hint.type === "actors" &&
        Array.isArray(hint.value) &&
        hint.value.length > 0
      ) {
        return hint.value[0].name
      }
      return String(hint.value)
    }

    return (
      <Animated.View style={[styles.guessTile, animatedTileStyle]}>
        {feedbackMessage && (
          <Animated.View
            style={[styles.feedbackOverlay, animatedFeedbackStyle]}
          >
            <Text style={styles.feedbackText}>{feedbackMessage}</Text>
          </Animated.View>
        )}
        <Animated.View style={[styles.contentContainer, animatedContentStyle]}>
          <Text style={styles.guessNumber}>{index + 1}</Text>
          <Ionicons
            name={isCorrect ? "checkmark-circle" : "close-circle"}
            style={isCorrect ? styles.iconSuccess : styles.iconError}
          />
          <View style={styles.guessTextContainer}>
            <Text
              numberOfLines={1}
              ellipsizeMode="tail"
              style={styles.guessText}
            >
              {`${guessTitle}${releaseYear}`}
            </Text>
            {hintInfoList && hintInfoList.length > 0 && (
              <View style={styles.hintsWrapper}>
                {hintInfoList.map((hint, idx) => (
                  <View key={idx} style={styles.guessHintContainer}>
                    <Ionicons
                      name={getIconNameForHint(hint.type)}
                      style={styles.guessHintIcon}
                    />
                    <Text style={styles.guessHintText} numberOfLines={1}>
                      {getHintDisplayValue(hint)}
                    </Text>
                  </View>
                ))}
              </View>
            )}
          </View>
        </Animated.View>
      </Animated.View>
    )
  }
)

interface GuessRowStyles {
  guessTile: ViewStyle
  feedbackOverlay: ViewStyle
  feedbackText: TextStyle
  contentContainer: ViewStyle
  guessNumber: TextStyle
  iconSuccess: TextStyle
  iconError: TextStyle
  guessTextContainer: ViewStyle
  guessText: TextStyle
  hintsWrapper: ViewStyle
  guessHintContainer: ViewStyle
  guessHintIcon: TextStyle
  guessHintText: TextStyle
}

const themedStyles = (theme: Theme): GuessRowStyles => ({
  guessTile: {
    ...u.flexRow,
    ...u.alignCenter,
    backgroundColor: theme.colors.surface,
    borderRadius: theme.responsive.scale(8),
    paddingHorizontal: theme.spacing.medium,
    minHeight: theme.responsive.scale(44),
    marginBottom: theme.spacing.small,
    paddingVertical: theme.spacing.small,
    position: "relative",
    overflow: "hidden",
    ...theme.shadows.light,
  },
  feedbackOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: theme.colors.tertiary,
    justifyContent: "center",
    alignItems: "center",
    padding: theme.spacing.small,
    zIndex: 1,
  },
  feedbackText: {
    color: theme.colors.background,
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(14),
    textAlign: "center",
  },
  contentContainer: {
    ...u.flexRow,
    ...u.alignCenter,
    ...u.wFull,
  },
  guessNumber: {
    color: theme.colors.textSecondary,
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(14),
    marginRight: theme.spacing.small,
  },
  iconSuccess: {
    marginRight: theme.spacing.medium,
    fontSize: theme.responsive.responsiveFontSize(22),
    color: theme.colors.success,
  },
  iconError: {
    marginRight: theme.spacing.medium,
    fontSize: theme.responsive.responsiveFontSize(22),
    color: theme.colors.error,
  },
  guessTextContainer: {
    flex: 1,
    justifyContent: "center",
  },
  guessText: {
    ...theme.typography.bodyText,
    color: theme.colors.textPrimary,
    fontSize: theme.responsive.responsiveFontSize(14),
    lineHeight: theme.responsive.responsiveFontSize(18),
  },
  hintsWrapper: {
    ...u.flexRow,
    flexWrap: "wrap",
    marginTop: theme.spacing.extraSmall,
  },
  guessHintContainer: {
    ...u.flexRow,
    ...u.alignCenter,
    marginRight: theme.spacing.medium,
  },
  guessHintIcon: {
    marginRight: theme.spacing.extraSmall,
    fontSize: theme.responsive.responsiveFontSize(12),
    color: theme.colors.primary,
    opacity: 0.8,
  },
  guessHintText: {
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(11),
    color: theme.colors.primary,
  },
})

================
File: src/components/guess/skeletonRow.tsx
================
import React, { memo } from "react"
import { View, Text, ViewStyle, TextStyle } from "react-native"
import Animated from "react-native-reanimated"
import { useSkeletonAnimation } from "../../utils/hooks/useSkeletonAnimation"
import { useStyles, Theme } from "../../utils/hooks/useStyles"

export const SkeletonRow = ({ index }: { index: number }) => {
  const styles = useStyles(themedStyles)
  const animatedStyle = useSkeletonAnimation()

  return (
    <Animated.View style={[styles.skeletonRow, animatedStyle]}>
      <Text style={styles.guessNumber}>{index + 1}</Text>
      <View style={styles.skeletonTextContainer}>
        <View style={styles.skeletonText} />
      </View>
    </Animated.View>
  )
}

interface SkeletonRowStyles {
  skeletonRow: ViewStyle
  guessNumber: TextStyle
  skeletonTextContainer: ViewStyle
  skeletonText: ViewStyle
}

const themedStyles = (theme: Theme): SkeletonRowStyles => ({
  skeletonRow: {
    flexDirection: "row",
    alignItems: "center",
    borderRadius: theme.responsive.scale(8),
    paddingHorizontal: theme.spacing.medium,
    minHeight: theme.responsive.scale(44),
    marginBottom: theme.spacing.small,
    backgroundColor: theme.colors.surface,
    paddingVertical: theme.spacing.small,
  },
  guessNumber: {
    color: theme.colors.textSecondary,
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(14),
    marginRight: theme.spacing.small,
  },
  skeletonTextContainer: {
    backgroundColor: theme.colors.border,
    flex: 1,
    borderRadius: theme.responsive.scale(4),
    overflow: "hidden",
  },
  skeletonText: {
    height: theme.responsive.scale(16),
    width: "100%",
  },
})

================
File: src/components/ui/button.tsx
================
import React, { useMemo } from "react"
import {
  Pressable,
  Text,
  StyleSheet,
  PressableProps,
  ViewStyle,
  TextStyle,
  ActivityIndicator,
  StyleProp,
} from "react-native"
import { useTheme } from "../../contexts/themeContext"
import { getButtonStyles } from "../../styles/global"

type ButtonVariant = "primary" | "secondary" | "error" | "tertiary"
type ButtonSize = "sm" | "md" | "lg"

interface ButtonProps extends PressableProps {
  title: string
  variant?: ButtonVariant
  size?: ButtonSize
  isLoading?: boolean
  style?: StyleProp<ViewStyle>
}

export const Button: React.FC<ButtonProps> = ({
  title,
  variant = "primary",
  size = "md",
  isLoading = false,
  disabled,
  style,
  ...props
}) => {
  const { colors } = useTheme()
  const baseStyles = useMemo(() => getButtonStyles(colors), [colors])
  const variantStyles = useMemo(
    () => getVariantStyles(colors, variant),
    [colors, variant]
  )
  const sizeStyles = useMemo(() => getSizeStyles(size), [size])

  const isDisabled = disabled || isLoading

  return (
    <Pressable
      style={({ pressed }) => [
        baseStyles.base,
        sizeStyles.button,
        variantStyles.button,
        pressed && !isDisabled && baseStyles.pressed,
        isDisabled && baseStyles.disabled,
        style,
      ]}
      disabled={isDisabled}
      accessibilityRole="button"
      accessibilityLabel={title}
      {...props}
    >
      {isLoading ? (
        <ActivityIndicator
          testID="activity-indicator"
          color={variantStyles.text.color as string}
        />
      ) : (
        <Text style={[baseStyles.text, sizeStyles.text, variantStyles.text]}>
          {title}
        </Text>
      )}
    </Pressable>
  )
}

const getVariantStyles = (
  colors: any,
  variant: ButtonVariant
): { button: ViewStyle; text: TextStyle } => {
  switch (variant) {
    case "secondary":
      return {
        button: {
          backgroundColor: "transparent",
          borderWidth: 2,
          borderColor: colors.primary,
        },
        text: {
          color: colors.primary,
        },
      }
    case "error":
      return {
        button: {
          backgroundColor: colors.error,
        },
        text: {
          color: colors.background,
        },
      }
    case "tertiary":
      return {
        button: {
          backgroundColor: colors.tertiary,
        },
        text: {
          color: colors.background,
        },
      }
    case "primary":
    default:
      return {
        button: {
          backgroundColor: colors.primary,
        },
        text: {
          color: colors.background,
        },
      }
  }
}

const getSizeStyles = (
  size: ButtonSize
): { button: ViewStyle; text: TextStyle } => {
  switch (size) {
    case "sm":
      return StyleSheet.create({
        button: { paddingVertical: 8 },
        text: { fontSize: 14 },
      })
    case "lg":
      return StyleSheet.create({
        button: { paddingVertical: 16 },
        text: { fontSize: 18 },
      })
    case "md":
    default:
      return StyleSheet.create({ button: {}, text: {} })
  }
}

================
File: src/components/ui/card.tsx
================
import React, { useMemo } from "react"
import { View, ViewProps, StyleSheet, Platform } from "react-native"
import { useTheme } from "../../contexts/themeContext"
import { responsive, shadows } from "../../styles/global"

interface CardProps extends ViewProps {}

export const Card: React.FC<CardProps> = ({ style, ...props }) => {
  const { colors } = useTheme()
  const cardStyles = useMemo(
    () =>
      StyleSheet.create({
        card: {
          backgroundColor: colors.surface,
          borderRadius: responsive.scale(12),
          ...shadows.light,
          ...Platform.select({
            android: {
              borderWidth: 1,
              borderColor: colors.border,
            },
          }),
        },
      }),
    [colors]
  )

  return <View style={[cardStyles.card, style]} {...props} />
}

================
File: src/components/ui/typography.tsx
================
import React, { useMemo } from "react"
import { Text, TextProps } from "react-native"
import { useTheme } from "../../contexts/themeContext"
import { getTypography } from "../../styles/global"

type TypographyVariant = "h1" | "h2" | "body" | "caption" | "button" | "error"

interface TypographyProps extends TextProps {
  variant?: TypographyVariant
}

export const Typography: React.FC<TypographyProps> = ({
  variant = "body",
  style,
  ...props
}) => {
  const { colors } = useTheme()
  const typographyStyles = useMemo(() => getTypography(colors), [colors])

  const getStyleForVariant = () => {
    switch (variant) {
      case "h1":
        return typographyStyles.heading1
      case "h2":
        return typographyStyles.heading2
      case "button":
        return typographyStyles.button
      case "caption":
        return typographyStyles.caption
      case "error":
        return { ...typographyStyles.bodyText, color: colors.error }
      case "body":
      default:
        return typographyStyles.bodyText
    }
  }

  const variantStyle = getStyleForVariant()

  return <Text style={[variantStyle, style]} {...props} />
}

================
File: src/components/actors.tsx
================
import React, { memo } from "react"
import {
  Text,
  Pressable,
  View,
  StyleProp,
  ViewStyle,
  TextStyle,
  ImageStyle,
} from "react-native"
import { Image } from "expo-image"
import { API_CONFIG } from "../config/constants"
import { useStyles, Theme } from "../utils/hooks/useStyles"

type ImageSource = { uri: string } | number

interface ActorsProps {
  actors: any[]
  maxDisplay?: number
  containerStyle?: StyleProp<ViewStyle>
  onActorPress: (actor: any) => void
}

const defaultActorImage = require("../../assets/actor_default.png")

const ActorContainer = memo(
  ({ actor, onPress }: { actor: any; onPress: (actor: any) => void }) => {
    const styles = useStyles(themedStyles)
    const imageURI = API_CONFIG.TMDB_IMAGE_BASE_URL_W185

    const actorImageSource: ImageSource = actor.profile_path
      ? { uri: `${imageURI}${actor.profile_path}` }
      : defaultActorImage

    const splitName = (name: string): string[] => {
      const parts = name.trim().split(" ")
      return parts.length > 1
        ? [parts[0], parts.slice(1).join(" ")]
        : [name, ""]
    }

    const [firstName, lastName] = splitName(actor.name)

    return (
      <View style={styles.actorContainer}>
        <Pressable
          testID={`actor-pressable-${actor.id}`}
          onPress={() => onPress(actor)}
          style={({ pressed }) => [
            styles.actorPressable,
            { opacity: pressed ? 0.6 : 1.0, pointerEvents: "auto" },
          ]}
          role="button"
          accessibilityLabel={`Actor: ${actor.name}. View details`}
        >
          <Image
            source={actorImageSource}
            style={styles.actorImage}
            contentFit="cover"
            placeholder={defaultActorImage}
          />
          <View style={styles.actorTextContainer}>
            <View style={styles.actorTextBackground}>
              <Text style={styles.actorText}>
                {firstName}
                {lastName ? (
                  <Text>
                    {"\n"}
                    {lastName}
                  </Text>
                ) : null}
              </Text>
            </View>
          </View>
        </Pressable>
      </View>
    )
  }
)

const Actors: React.FC<ActorsProps> = memo(
  ({ actors, maxDisplay = 3, containerStyle, onActorPress }) => {
    const styles = useStyles(themedStyles)
    if (!actors || actors.length === 0) return null

    return (
      <View style={[styles.actorsContainer, containerStyle]}>
        {actors.slice(0, maxDisplay).map((actor) => (
          <ActorContainer
            key={`${actor.id}-${actor.name}`}
            actor={actor}
            onPress={onActorPress}
          />
        ))}
      </View>
    )
  }
)

interface ActorsStyles {
  actorsContainer: ViewStyle
  actorContainer: ViewStyle
  actorPressable: ViewStyle
  actorImage: ImageStyle
  actorTextContainer: ViewStyle
  actorTextBackground: ViewStyle
  actorText: TextStyle
}

const themedStyles = (theme: Theme): ActorsStyles => ({
  actorsContainer: {
    flexDirection: "row",
    justifyContent: "space-around",
    paddingVertical: theme.responsive.scale(2),
    width: "100%",
  },
  actorContainer: {
    alignItems: "center",
    flex: 1,
    marginHorizontal: theme.spacing.extraSmall,
    minHeight: theme.responsive.scale(180),
    position: "relative",
  },
  actorPressable: {
    alignItems: "center",
    justifyContent: "center",
    borderRadius: theme.responsive.scale(4),
    padding: theme.responsive.scale(2),
    width: "100%",
    backgroundColor: theme.colors.background,
  },
  actorImage: {
    height: theme.responsive.scale(120),
    width: "100%",
    aspectRatio: 1 / 1.5,
    borderRadius: theme.responsive.scale(4),
  },
  actorTextContainer: {
    position: "absolute",
    bottom: 0,
    width: "100%",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "row",
    minHeight: theme.responsive.scale(40),
    flexWrap: "wrap",
  },
  actorTextBackground: {
    backgroundColor: "rgba(0, 0, 0, 0.6)",
    paddingHorizontal: theme.responsive.scale(2),
    marginTop: theme.responsive.scale(10),
    width: "100%",
  },
  actorText: {
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(8),
    color: theme.colors.secondary,
    textAlign: "center",
    lineHeight: theme.responsive.responsiveFontSize(10),
    paddingVertical: theme.responsive.scale(2),
  },
})

export default Actors

================
File: src/components/clues.tsx
================
import React, {
  useEffect,
  useRef,
  useState,
  useMemo,
  memo,
  useCallback,
} from "react"
import {
  Text,
  View,
  ScrollView,
  Pressable,
  ViewStyle,
  TextStyle,
} from "react-native"
import Animated, {
  useSharedValue,
  withTiming,
  useAnimatedStyle,
  runOnJS,
  withSequence,
  withDelay,
  interpolateColor,
  useAnimatedReaction,
  cancelAnimation,
  Easing,
} from "react-native-reanimated"
import { hapticsService } from "../utils/hapticsService"
import { ANIMATION_CONSTANTS } from "../config/constants"
import { useGameStore } from "../state/gameStore"
import { useShallow } from "zustand/react/shallow"
import { DIFFICULTY_MODES } from "../config/difficulty"
import { useStyles, useThemeTokens, Theme } from "../utils/hooks/useStyles"
import { useSkeletonAnimation } from "../utils/hooks/useSkeletonAnimation"

const CluesSkeleton = memo(() => {
  const styles = useStyles(themedStyles)
  const animatedStyle = useSkeletonAnimation()
  return (
    <Animated.View
      style={[styles.skeletonContainer, animatedStyle]}
      testID="clues-skeleton"
    >
      <View style={styles.skeletonLine} />
      <View style={styles.skeletonLine} />
      <View style={[styles.skeletonLine, styles.skeletonLineShort]} />
    </Animated.View>
  )
})

const splitSummary = (summary: string, splits: number = 5): string[] => {
  if (!summary) return Array(splits).fill("")
  const words = summary.trim().split(/\s+/)
  if (words.length === 0) return Array(splits).fill("")
  const avgLength = Math.max(1, Math.ceil(words.length / splits))
  return Array.from({ length: splits }, (_, i) =>
    words.slice(i * avgLength, (i + 1) * avgLength).join(" ")
  ).filter((chunk) => chunk.length > 0)
}

const CountContainer = memo(
  ({
    currentWordLength,
    totalWordLength,
  }: {
    currentWordLength: number
    totalWordLength: number
  }) => {
    const styles = useStyles(themedStyles)
    return (
      <View style={styles.countContainer}>
        <Text style={styles.wordCountText}>
          {currentWordLength}/{totalWordLength} words revealed
        </Text>
      </View>
    )
  }
)

const CluesContainer = memo(() => {
  const styles = useStyles(themedStyles)
  const theme = useThemeTokens()

  const {
    correctAnswer,
    guesses,
    itemDescription,
    isInteractionsDisabled,
    difficulty,
    loading,
  } = useGameStore(
    useShallow((state) => ({
      correctAnswer: state.playerGame.correctAnswer,
      guesses: state.playerGame.guesses,
      itemDescription: state.playerGame.triviaItem?.description,
      isInteractionsDisabled: state.isInteractionsDisabled,
      difficulty: state.difficulty,
      loading: state.loading,
    }))
  )

  const clues = useMemo(
    () => splitSummary(itemDescription || ""),
    [itemDescription]
  )
  const [revealedClues, setRevealedClues] = useState<string[]>([])
  const [typewriterText, setTypewriterText] = useState("")
  const fullClueShared = useSharedValue("")

  const highlightProgress = useSharedValue(0)
  const typewriterProgress = useSharedValue(0)
  const scrollViewRef = useRef<ScrollView>(null)
  const oldCluesText = revealedClues.slice(0, -1).join(" ")

  const handleSkipAnimation = useCallback(() => {
    cancelAnimation(typewriterProgress)
    setTypewriterText(fullClueShared.value)
    hapticsService.light()
  }, [typewriterProgress, fullClueShared])

  useAnimatedReaction(
    () => Math.floor(typewriterProgress.value),
    (currentValue, previousValue) => {
      if (currentValue !== previousValue) {
        const text = fullClueShared.value.substring(0, currentValue)
        runOnJS(setTypewriterText)(text)
      }
    },
    [typewriterProgress, fullClueShared]
  )

  useEffect(() => {
    if (loading) return

    let numCluesToReveal
    const hintStrategy = DIFFICULTY_MODES[difficulty]?.hintStrategy
    const currentGuessCount = guesses.length

    if (correctAnswer || isInteractionsDisabled) {
      numCluesToReveal = clues.length
    } else if (
      hintStrategy === "ALL_REVEALED" ||
      hintStrategy === "HINTS_ONLY_REVEALED"
    ) {
      numCluesToReveal = Math.min(currentGuessCount + 1, clues.length)
    } else {
      numCluesToReveal = Math.min(currentGuessCount + 1, clues.length)
    }

    if (numCluesToReveal > revealedClues.length) {
      hapticsService.light()
      const newRevealedClues = clues.slice(0, numCluesToReveal)
      const lastClue = newRevealedClues[newRevealedClues.length - 1] || ""

      fullClueShared.value = lastClue

      highlightProgress.value = 0
      typewriterProgress.value = 0
      setTypewriterText("")

      const typewriterDuration =
        lastClue.length * ANIMATION_CONSTANTS.TYPEWRITER_CHAR_DURATION
      highlightProgress.value = withSequence(
        withTiming(1, { duration: 400 }),
        withDelay(typewriterDuration + 200, withTiming(0, { duration: 500 }))
      )
      typewriterProgress.value = withDelay(
        200,
        withTiming(lastClue.length, {
          duration: typewriterDuration,
          easing: Easing.linear,
        })
      )
      setRevealedClues(newRevealedClues)
      setTimeout(
        () => scrollViewRef.current?.scrollToEnd({ animated: true }),
        100
      )
    } else if (numCluesToReveal < revealedClues.length) {
      setRevealedClues(clues.slice(0, numCluesToReveal))
      const lastClue = clues[numCluesToReveal - 1] || ""
      setTypewriterText(lastClue)
      fullClueShared.value = lastClue
    }

    return () => {
      cancelAnimation(typewriterProgress)
      cancelAnimation(highlightProgress)
    }
  }, [
    loading,
    correctAnswer,
    isInteractionsDisabled,
    guesses.length,
    clues,
    difficulty,
    fullClueShared,
  ])

  const animatedHighlightStyle = useAnimatedStyle(() => {
    const backgroundColor = interpolateColor(
      highlightProgress.value,
      [0, 1],
      ["transparent", theme.colors.primary]
    )
    const color = interpolateColor(
      highlightProgress.value,
      [0, 1],
      [theme.colors.textPrimary, theme.colors.background]
    )
    return { backgroundColor, color }
  })

  const isGameOver = correctAnswer || isInteractionsDisabled

  return (
    <View style={styles.container}>
      {loading ? (
        <CluesSkeleton />
      ) : (
        <>
          <ScrollView
            ref={scrollViewRef}
            style={styles.scrollView}
            contentContainerStyle={styles.scrollViewContent}
            showsVerticalScrollIndicator={false}
          >
            <Pressable
              onPress={isGameOver ? undefined : handleSkipAnimation}
              accessible={!isGameOver}
              accessibilityRole="button"
              accessibilityLabel={
                !isGameOver ? "Tap to reveal the full clue immediately" : ""
              }
            >
              <View style={styles.cluesBox}>
                <Text style={styles.text}>
                  {oldCluesText}
                  {oldCluesText ? " " : ""}
                  {isGameOver ? (
                    <Text>
                      {clues.slice(revealedClues.length - 1).join(" ")}
                    </Text>
                  ) : (
                    <Animated.Text style={animatedHighlightStyle}>
                      {typewriterText}
                    </Animated.Text>
                  )}
                </Text>
              </View>
            </Pressable>
          </ScrollView>
          <CountContainer
            currentWordLength={
              revealedClues.join(" ").split(" ").filter(Boolean).length
            }
            totalWordLength={clues.join(" ").split(" ").filter(Boolean).length}
          />
        </>
      )}
    </View>
  )
})

interface CluesStyles {
  container: ViewStyle
  countContainer: ViewStyle
  scrollView: ViewStyle
  scrollViewContent: ViewStyle
  skeletonContainer: ViewStyle
  skeletonLine: ViewStyle
  skeletonLineShort: ViewStyle
  cluesBox: ViewStyle
  text: TextStyle
  wordCountText: TextStyle
}

const themedStyles = (theme: Theme): CluesStyles => ({
  container: {
    flex: 1,
    justifyContent: "flex-start",
    marginVertical: theme.spacing.extraSmall,
    minHeight: theme.responsive.scale(160),
    paddingHorizontal: theme.spacing.small,
    width: "100%",
    alignSelf: "stretch",
  },
  countContainer: {
    alignSelf: "flex-end",
    marginBottom: theme.responsive.scale(4),
    marginRight: theme.spacing.large,
    marginTop: theme.spacing.small,
  },
  scrollView: {
    flexGrow: 1,
    width: "100%",
    alignSelf: "stretch",
  },
  scrollViewContent: {
    paddingBottom: theme.spacing.extraSmall,
  },
  skeletonContainer: {
    paddingHorizontal: theme.spacing.small,
    paddingVertical: theme.spacing.small,
    width: "100%",
    height: "100%",
    justifyContent: "center",
  },
  skeletonLine: {
    backgroundColor: theme.colors.surface,
    borderRadius: theme.responsive.scale(4),
    height: theme.responsive.responsiveFontSize(16),
    marginBottom: theme.spacing.medium,
    width: "100%",
  },
  skeletonLineShort: {
    width: "70%",
  },
  cluesBox: {
    paddingHorizontal: theme.spacing.medium,
    paddingVertical: theme.spacing.medium,
    width: "100%",
  },
  text: {
    ...theme.typography.bodyText,
    fontSize: theme.responsive.responsiveFontSize(14),
    lineHeight: theme.responsive.responsiveFontSize(20),
    color: theme.colors.textPrimary,
  },
  wordCountText: {
    ...theme.typography.caption,
    fontSize: theme.responsive.responsiveFontSize(11),
    color: theme.colors.primary,
    textAlign: "right",
  },
})

export default CluesContainer

================
File: src/components/confettiCelebration.tsx
================
import React, { useRef, useEffect, useCallback, useMemo } from "react"
import ConfettiCannon from "react-native-confetti-cannon"
import { useTheme } from "../contexts/themeContext"

interface ConfettiCelebrationProps {
  startConfetti: boolean
  onConfettiStop?: () => void
}
const ConfettiCelebration: React.FC<ConfettiCelebrationProps> = ({
  startConfetti,
  onConfettiStop,
}) => {
  const { colors } = useTheme()
  const confettiRef = useRef<any>(null)

  const start = useCallback(() => confettiRef.current?.start(), [])
  const stop = useCallback(() => onConfettiStop?.(), [onConfettiStop])

  useEffect(() => {
    if (startConfetti) start()
  }, [startConfetti, start])

  const confettiColors = useMemo(
    () => [
      colors.primary,
      colors.secondary,
      colors.tertiary,
      colors.quinary,
      colors.success,
    ],
    [colors]
  )

  return startConfetti ? (
    <ConfettiCannon
      testID="confetti-cannon"
      count={250}
      origin={{ x: -100, y: 0 }}
      colors={confettiColors}
      fallSpeed={2000}
      fadeOut={true}
      explosionSpeed={500}
      ref={confettiRef}
      onAnimationEnd={stop}
    />
  ) : null
}

export default ConfettiCelebration

================
File: src/components/confirmationModal.tsx
================
import React, { memo } from "react"
import { Modal, View, ViewStyle, TextStyle } from "react-native"
import { hapticsService } from "../utils/hapticsService"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Button } from "./ui/button"
import { Typography } from "./ui/typography"

interface ConfirmationModalProps {
  isVisible: boolean
  title: string
  message: string
  confirmText: string
  cancelText: string
  onConfirm: () => void
  onCancel: () => void
}

const ConfirmationModal = memo(
  ({
    isVisible,
    title,
    message,
    confirmText,
    cancelText,
    onConfirm,
    onCancel,
  }: ConfirmationModalProps) => {
    const styles = useStyles(themedStyles)

    const handleConfirm = () => {
      hapticsService.heavy()
      onConfirm()
    }
    const handleCancel = () => {
      hapticsService.light()
      onCancel()
    }

    return (
      <Modal
        animationType="fade"
        transparent={true}
        visible={isVisible}
        onRequestClose={handleCancel}
      >
        {isVisible && (
          <View
            style={styles.centeredView}
            testID="confirmation-modal-container"
          >
            <View style={styles.modalView}>
              <Typography variant="h2" style={styles.title}>
                {title}
              </Typography>

              <Typography variant="body" style={styles.message}>
                {message}
              </Typography>

              <View style={styles.buttonContainer}>
                <Button
                  title={cancelText}
                  variant="secondary"
                  onPress={handleCancel}
                  style={styles.button}
                />
                <Button
                  title={confirmText}
                  variant="primary"
                  onPress={handleConfirm}
                  style={styles.button}
                />
              </View>
            </View>
          </View>
        )}
      </Modal>
    )
  }
)

interface ModalStyles {
  centeredView: ViewStyle
  modalView: ViewStyle
  title: TextStyle
  message: TextStyle
  buttonContainer: ViewStyle
  button: ViewStyle
}

const themedStyles = (theme: Theme): ModalStyles => ({
  centeredView: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "rgba(0, 0, 0, 0.5)",
  },
  modalView: {
    backgroundColor: theme.colors.background,
    borderRadius: theme.responsive.scale(10),
    padding: theme.responsive.scale(20),
    width: "80%",
    maxWidth: theme.responsive.scale(400),
    ...theme.shadows.medium,
  },
  title: {
    fontSize: theme.responsive.responsiveFontSize(20),
    marginBottom: theme.spacing.small,
    textAlign: "center",
  },
  message: {
    marginBottom: theme.spacing.large,
    textAlign: "center",
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-around",
  },
  button: {
    flex: 1,
    marginHorizontal: theme.spacing.small,
  },
})

export default ConfirmationModal

================
File: src/components/countdownTimer.tsx
================
import React, { useState, useEffect, useCallback, memo } from "react"
import { View, TextStyle, ViewStyle } from "react-native"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"

const CountdownTimer: React.FC = () => {
  const styles = useStyles(themedStyles)

  const calculateTimeLeft = useCallback(() => {
    const now = new Date()
    const tomorrow = new Date(now)
    tomorrow.setDate(now.getDate() + 1)
    tomorrow.setHours(0, 0, 0, 0)

    const difference = tomorrow.getTime() - now.getTime()

    let timeLeft = {
      hours: "00",
      minutes: "00",
      seconds: "00",
    }

    if (difference > 0) {
      const pad = (num: number) => num.toString().padStart(2, "0")
      timeLeft = {
        hours: pad(Math.floor((difference / (1000 * 60 * 60)) % 24)),
        minutes: pad(Math.floor((difference / 1000 / 60) % 60)),
        seconds: pad(Math.floor((difference / 1000) % 60)),
      }
    }

    return timeLeft
  }, [])

  const [timeLeft, setTimeLeft] = useState(calculateTimeLeft())

  useEffect(() => {
    const timer = setInterval(() => {
      setTimeLeft(calculateTimeLeft())
    }, 1000)

    // Clear interval on component unmount
    return () => clearInterval(timer)
  }, [calculateTimeLeft])

  return (
    <View style={styles.container}>
      <Typography style={styles.text}>
        Next game in {timeLeft.hours}:{timeLeft.minutes}:{timeLeft.seconds}
      </Typography>
    </View>
  )
}

interface CountdownStyles {
  container: ViewStyle
  text: TextStyle
}

const themedStyles = (theme: Theme): CountdownStyles => ({
  container: {
    marginTop: theme.spacing.large,
    padding: theme.spacing.small,
    backgroundColor: theme.colors.surface,
    borderRadius: theme.responsive.scale(8),
  },
  text: {
    ...theme.typography.caption,
    fontFamily: "Arvo-Bold",
    color: theme.colors.textSecondary,
    fontSize: theme.responsive.responsiveFontSize(14),
  },
})

export default memo(CountdownTimer)

================
File: src/components/customLoadingIndicator.tsx
================
import React, { useEffect } from "react"
import { View, ActivityIndicator, Platform, ViewStyle } from "react-native"
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  Easing,
} from "react-native-reanimated"
import { Svg, Circle } from "react-native-svg"
import { useStyles, Theme, useThemeTokens } from "../utils/hooks/useStyles"

interface CustomLoadingIndicatorProps {
  isLowEndDevice?: boolean
}

const CustomLoadingIndicator: React.FC<CustomLoadingIndicatorProps> = ({
  isLowEndDevice = false,
}) => {
  const styles = useStyles(themedStyles)
  const theme = useThemeTokens()
  const { colors, responsive } = theme

  if (isLowEndDevice || Platform.OS === "web") {
    return (
      <ActivityIndicator
        size="large"
        color={colors.primary}
        testID="standard-activity-indicator"
      />
    )
  }

  const progress = useSharedValue(0)
  const size = responsive.scale(50)
  const strokeWidth = responsive.scale(4)
  const center = size / 2
  const radius = center - strokeWidth / 2
  const circumference = 2 * Math.PI * radius

  useEffect(() => {
    progress.value = withRepeat(
      withTiming(1, { duration: 1500, easing: Easing.linear }),
      -1,
      false
    )
  }, [progress])

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ rotate: `${progress.value * 360}deg` }],
    }
  })

  return (
    <View
      style={styles.rotateContainer}
      testID="activity-indicator"
      accessibilityLabel="Loading content"
      accessibilityRole="progressbar"
    >
      <Animated.View style={[styles.rotateContainer, animatedStyle]}>
        <Svg width={size} height={size}>
          <Circle
            cx={center}
            cy={center}
            r={radius}
            stroke={colors.primary}
            strokeWidth={strokeWidth}
            fill="transparent"
            strokeDasharray={circumference}
            strokeDashoffset={circumference * 0.25}
            strokeLinecap="round"
          />
          <Circle
            cx={center}
            cy={center}
            r={radius}
            stroke={colors.tertiary}
            strokeWidth={strokeWidth}
            fill="transparent"
            strokeDasharray={circumference}
            strokeDashoffset={circumference * 0.75}
            strokeLinecap="round"
          />
        </Svg>
      </Animated.View>
    </View>
  )
}

interface CustomLoadingIndicatorStyles {
  rotateContainer: ViewStyle
}

const themedStyles = (theme: Theme): CustomLoadingIndicatorStyles => ({
  rotateContainer: {
    alignItems: "center",
    justifyContent: "center",
  },
})

export default CustomLoadingIndicator

================
File: src/components/detailModal.tsx
================
import React, { memo, useEffect, ReactNode } from "react"
import { Modal, Pressable, View, Share, Alert, ViewStyle } from "react-native"
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  Easing,
} from "react-native-reanimated"
import { PlayerGame } from "../models/game"
import { generateShareMessage } from "../utils/shareUtils"
import { analyticsService } from "../utils/analyticsService"
import { hapticsService } from "../utils/hapticsService"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Button } from "./ui/button"

interface DetailModalProps {
  playerGame?: PlayerGame | null
  show: boolean
  toggleModal: (show: boolean) => void
  children: ReactNode
}

const DetailModal: React.FC<DetailModalProps> = memo(
  ({ playerGame, show, toggleModal, children }) => {
    const styles = useStyles(themedStyles)
    const animatedValue = useSharedValue(0)

    const animatedModalContentStyle = useAnimatedStyle(() => {
      return {
        opacity: animatedValue.value,
        transform: [{ scale: animatedValue.value }],
      }
    })

    useEffect(() => {
      animatedValue.value = withTiming(show ? 1 : 0, {
        duration: 300,
        easing: Easing.out(Easing.exp),
      })
    }, [show, animatedValue])

    const handleShare = async () => {
      if (!playerGame) return
      hapticsService.medium()
      try {
        let outcome: "win" | "lose" | "give_up" = "lose"
        if (playerGame.correctAnswer) {
          outcome = "win"
        } else if (playerGame.gaveUp) {
          outcome = "give_up"
        }

        analyticsService.trackShareResults(outcome)

        const message = generateShareMessage(playerGame)
        await Share.share(
          {
            message,
            title: "Talkie Trivia Results",
          },
          {
            dialogTitle: "Share your Talkie Trivia results!", // Android only
          }
        )
      } catch (error: any) {
        Alert.alert("Share Error", error.message)
      }
    }

    const handleClose = () => {
      hapticsService.light()
      toggleModal(false)
    }

    const renderContent = () => {
      return (
        <Animated.View style={[styles.modalView, animatedModalContentStyle]}>
          {children}
          <View style={styles.buttonContainer}>
            <Button
              title="Close"
              variant="secondary"
              onPress={handleClose}
              style={styles.button}
            />
            {playerGame && (
              <Button
                title="Share"
                variant="primary"
                onPress={handleShare}
                style={styles.button}
              />
            )}
          </View>
        </Animated.View>
      )
    }

    return (
      <Modal
        animationType="none"
        transparent={true}
        visible={show}
        onRequestClose={handleClose}
        hardwareAccelerated
        statusBarTranslucent
      >
        <Pressable
          style={styles.centeredView}
          onPress={handleClose}
          accessible={true}
          accessibilityLabel="Close modal by tapping outside"
        >
          {/* Prevent touch events from propagating to the background Pressable */}
          <Pressable onPress={(e) => e.stopPropagation()} accessible={false}>
            {renderContent()}
          </Pressable>
        </Pressable>
      </Modal>
    )
  }
)

interface ModalStyles {
  centeredView: ViewStyle
  modalView: ViewStyle
  buttonContainer: ViewStyle
  button: ViewStyle
}

const themedStyles = (theme: Theme): ModalStyles => ({
  centeredView: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "rgba(0, 0, 0, 0.7)",
  },
  modalView: {
    width: "90%",
    maxHeight: "80%",
    maxWidth: theme.responsive.scale(500),
    alignSelf: "center",
    backgroundColor: theme.colors.background,
    borderRadius: theme.responsive.scale(15),
    padding: theme.spacing.large,
    ...theme.shadows.medium,
  },
  buttonContainer: {
    flexDirection: "row",
    justifyContent: "space-evenly",
    width: "100%",
    marginTop: theme.spacing.medium,
  },
  button: {
    flex: 1,
    marginHorizontal: theme.spacing.small,
  },
})

export default DetailModal

================
File: src/components/difficultySelector.tsx
================
import React, { useCallback, useMemo, useState, useEffect } from "react"
import { View, Pressable, ViewStyle, TextStyle } from "react-native"
import Animated, {
  useSharedValue,
  withTiming,
  useAnimatedStyle,
  Easing,
  runOnJS,
} from "react-native-reanimated"
import { hapticsService } from "../utils/hapticsService"
import { useGameStore } from "../state/gameStore"
import { useAuth } from "../contexts/authContext"
import { FontAwesome } from "@expo/vector-icons"
import {
  DifficultyLevel,
  DIFFICULTY_MODES,
  DifficultyMode,
} from "../config/difficulty"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"

type Option = DifficultyMode & { value: DifficultyLevel }

const options: Option[] = (
  Object.keys(DIFFICULTY_MODES) as DifficultyLevel[]
).map((key) => ({
  value: key,
  ...DIFFICULTY_MODES[key],
}))

const DifficultySelector = () => {
  const { player } = useAuth()
  const difficulty = useGameStore((state) => state.difficulty)
  const setDifficulty = useGameStore((state) => state.setDifficulty)
  const styles = useStyles(themedStyles)

  const [hoveredDifficulty, setHoveredDifficulty] =
    useState<DifficultyLevel | null>(null)

  const handleSelect = useCallback(
    (newDifficulty: DifficultyLevel) => {
      if (player) {
        hapticsService.medium()
        setDifficulty(newDifficulty)
      }
    },
    [setDifficulty, player]
  )

  const descriptionToDisplay = useMemo(() => {
    const key = hoveredDifficulty || difficulty
    return options.find((o) => o.value === key)?.description || ""
  }, [hoveredDifficulty, difficulty])

  const [currentDescription, setCurrentDescription] =
    useState(descriptionToDisplay)
  const descriptionOpacity = useSharedValue(1)

  useEffect(() => {
    descriptionOpacity.value = withTiming(
      0,
      { duration: 150, easing: Easing.ease },
      (finished) => {
        if (finished) {
          runOnJS(setCurrentDescription)(descriptionToDisplay)
        }
      }
    )
  }, [descriptionToDisplay])

  useEffect(() => {
    descriptionOpacity.value = withTiming(1, {
      duration: 150,
      easing: Easing.ease,
    })
  }, [currentDescription])

  const animatedDescriptionStyle = useAnimatedStyle(() => ({
    opacity: descriptionOpacity.value,
  }))

  const handleLongPress = (value: DifficultyLevel) => {
    hapticsService.light()
    setHoveredDifficulty(value)
  }

  const selectedOptionLabel =
    options.find((o) => o.value === difficulty)?.label || "Medium"

  return (
    <View style={styles.container}>
      <View style={styles.row}>
        <View style={styles.labelContainer}>
          <FontAwesome
            name="gamepad"
            size={styles.icon.fontSize}
            color={styles.icon.color}
          />
          <Typography style={styles.title}>Difficulty</Typography>
        </View>
        <View style={styles.selectedOptionDisplay}>
          <Typography style={styles.selectedOptionTextDisplay}>
            {selectedOptionLabel}
          </Typography>
        </View>
      </View>

      <View style={styles.optionsContainer}>
        {options.map((option) => (
          <Pressable
            key={option.value}
            onPress={() => handleSelect(option.value)}
            onLongPress={() => handleLongPress(option.value)}
            onPressOut={() => setHoveredDifficulty(null)}
            delayLongPress={200}
            style={({ pressed }) => [
              styles.option,
              difficulty === option.value && styles.selectedOption,
              pressed && { opacity: 0.7 },
            ]}
            accessibilityRole="button"
            accessibilityState={{ selected: difficulty === option.value }}
            accessibilityLabel={`Set difficulty to ${option.label}. ${option.description}`}
          >
            <Typography
              style={[
                styles.optionText,
                difficulty === option.value && styles.selectedOptionText,
              ]}
            >
              {option.label}
            </Typography>
          </Pressable>
        ))}
      </View>
      <Animated.View
        style={[styles.descriptionContainer, animatedDescriptionStyle]}
      >
        <Typography style={styles.descriptionText}>
          {currentDescription}
        </Typography>
      </Animated.View>
    </View>
  )
}

interface DifficultySelectorStyles {
  container: ViewStyle
  row: ViewStyle
  labelContainer: ViewStyle
  icon: TextStyle
  title: TextStyle
  selectedOptionDisplay: ViewStyle
  selectedOptionTextDisplay: TextStyle
  optionsContainer: ViewStyle
  option: ViewStyle
  selectedOption: ViewStyle
  optionText: TextStyle
  selectedOptionText: TextStyle
  descriptionContainer: ViewStyle
  descriptionText: TextStyle
}

const themedStyles = (theme: Theme): DifficultySelectorStyles => ({
  container: {
    width: "100%",
    alignItems: "center",
  },
  row: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    width: "100%",
  },
  labelContainer: {
    flexDirection: "row",
    alignItems: "center",
  },
  icon: {
    fontSize: theme.responsive.responsiveFontSize(16),
    color: theme.colors.textSecondary,
  },
  title: {
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(16),
    color: theme.colors.textPrimary,
    marginLeft: theme.spacing.small,
  },
  selectedOptionDisplay: {
    backgroundColor: theme.colors.background,
    paddingVertical: theme.spacing.extraSmall,
    paddingHorizontal: theme.spacing.small,
    borderRadius: theme.responsive.scale(6),
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  selectedOptionTextDisplay: {
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(14),
    color: theme.colors.textSecondary,
  },
  optionsContainer: {
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "center",
    backgroundColor: theme.colors.background,
    borderRadius: theme.responsive.scale(6),
    marginTop: theme.spacing.extraSmall,
    padding: theme.spacing.extraSmall,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  option: {
    paddingVertical: theme.spacing.extraSmall,
    paddingHorizontal: theme.spacing.extraSmall,
    borderRadius: theme.responsive.scale(6),
    margin: theme.spacing.extraSmall,
    backgroundColor: theme.colors.surface,
  },
  selectedOption: {
    backgroundColor: theme.colors.primary,
  },
  optionText: {
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(14),
    color: theme.colors.textPrimary,
  },
  selectedOptionText: {
    fontFamily: "Arvo-Bold",
    color: theme.colors.background,
  },
  descriptionContainer: {
    marginTop: theme.spacing.extraSmall,
    minHeight: theme.responsive.scale(60),
    paddingHorizontal: theme.spacing.extraSmall,
    justifyContent: "center",
  },
  descriptionText: {
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(12),
    color: theme.colors.textSecondary,
    textAlign: "center",
    lineHeight: theme.responsive.responsiveFontSize(16),
  },
})

export default DifficultySelector

================
File: src/components/errorBoundary.tsx
================
import React, { Component, ErrorInfo, ReactNode } from "react"
import { View, Text, Button, StyleSheet, Platform, Alert } from "react-native"
import * as Updates from "expo-updates"
import { analyticsService } from "../utils/analyticsService"

const safeStyles = StyleSheet.create({
  errorContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#121212", // Safe dark background
    padding: 20,
  },
  titleText: {
    fontSize: 22,
    fontWeight: "bold",
    color: "#FFFFFF", // Safe white text
    textAlign: "center",
    marginBottom: 20,
  },
  messageText: {
    fontSize: 16,
    color: "#A0A0A0", // Safe gray text
    textAlign: "center",
    marginBottom: 30,
  },
  errorDetails: {
    marginTop: 30,
    fontSize: 12,
    color: "#757575",
    fontFamily: Platform.OS === "ios" ? "Courier New" : "monospace",
    paddingHorizontal: 10,
  },
})

const ErrorDisplay = ({
  error,
  onReload,
}: {
  error: Error | null
  onReload: () => void
}) => {
  return (
    <View style={safeStyles.errorContainer}>
      <Text style={safeStyles.titleText}>Oops! Something went wrong.</Text>
      <Text style={safeStyles.messageText}>
        An unexpected error occurred. Please try reloading the app.
      </Text>
      <Button
        title="Reload App"
        onPress={onReload}
        color="#FFC107" // Safe primary color
        testID="reload-button"
      />
      {__DEV__ && (
        <Text style={safeStyles.errorDetails}>
          {error?.message}
          {"\n\n"}
          {error?.stack}
        </Text>
      )}
    </View>
  )
}

interface Props {
  children: ReactNode
}

interface State {
  hasError: boolean
  error: Error | null
  errorInfo: ErrorInfo | null
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
    errorInfo: null,
  }

  public static getDerivedStateFromError(
    error: Error
  ): Pick<State, "hasError" | "error"> {
    console.error("ErrorBoundary caught an error:", error)
    analyticsService.trackErrorBoundary(error.message)
    return { hasError: true, error }
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("ErrorBoundary details:", error, errorInfo)
    this.setState({ errorInfo })
  }

  private handleReload = async () => {
    try {
      if (Platform.OS === "web") {
        window.location.reload()
        return
      }

      if (__DEV__) {
        console.log("Attempting to reload app via Updates API...")
      }
      await Updates.reloadAsync()
    } catch (e) {
      console.error("Failed to reload the app:", e)
      Alert.alert(
        "Reload Failed",
        "Could not automatically reload the app. Please close and restart it manually."
      )
    }
  }

  public render() {
    if (this.state.hasError) {
      return (
        <ErrorDisplay error={this.state.error} onReload={this.handleReload} />
      )
    }

    return this.props.children
  }
}

export default ErrorBoundary

================
File: src/components/errorMessage.tsx
================
import React, { memo } from "react"
import { View, ViewStyle, TextStyle } from "react-native"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Button } from "./ui/button"
import { Typography } from "./ui/typography"
import { u } from "../styles/utils"

interface ErrorMessageProps {
  message: string
  onRetry?: () => void
}

const ErrorMessage: React.FC<ErrorMessageProps> = memo(
  ({ message, onRetry }) => {
    const styles = useStyles(themedStyles)

    return (
      <View style={styles.errorContainer}>
        <Typography variant="error" style={styles.errorText}>
          {message}
        </Typography>
        {onRetry && (
          <Button
            testID="retry"
            title="Retry"
            onPress={onRetry}
            variant="secondary"
            style={u.mtMd}
          />
        )}
      </View>
    )
  }
)

interface ErrorMessageStyles {
  errorContainer: ViewStyle
  errorText: TextStyle
}

const themedStyles = (theme: Theme): ErrorMessageStyles => ({
  errorContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: theme.colors.background,
    padding: theme.spacing.large,
  },
  errorText: {
    ...theme.typography.bodyText,
    color: theme.colors.error,
    fontSize: theme.responsive.responsiveFontSize(18),
    textAlign: "center",
    width: "90%",
  },
})

export default ErrorMessage

================
File: src/components/facts.tsx
================
import React, { useCallback, memo } from "react"
import {
  Pressable,
  View,
  ActivityIndicator,
  ScrollView,
  ViewStyle,
  TextStyle,
  ImageStyle,
} from "react-native"
import { Image } from "expo-image"
import { FontAwesome } from "@expo/vector-icons"
import { TriviaItem, Hint } from "../models/trivia"
import { analyticsService } from "../utils/analyticsService"
import { useExternalLink } from "../utils/hooks/useExternalLink"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { u } from "../styles/utils"
import { Typography } from "./ui/typography"
import Actors from "./actors"
import { API_CONFIG } from "../config/constants"

type ImageSource = { uri: string } | number
const defaultItemImage = require("../../assets/movie_default.png")

const ItemHeader = memo(
  ({
    title,
    onPress,
    isLinkable,
  }: {
    title: string
    onPress: () => void
    isLinkable: boolean
  }) => {
    const styles = useStyles(themedStyles)
    return (
      <Pressable
        onPress={onPress}
        style={({ pressed }) => [
          styles.headerPressable,
          { opacity: pressed ? 0.7 : 1 },
        ]}
        disabled={!isLinkable}
        accessible={isLinkable}
        accessibilityLabel={`Open external page for ${title}`}
        role="link"
      >
        <View style={styles.headerContainer}>
          <Typography
            variant="h1"
            style={[styles.header, isLinkable && styles.linkText]}
          >
            {title}
          </Typography>
          {isLinkable && (
            <FontAwesome
              name="external-link-square"
              size={styles.imdbIcon.fontSize}
              color={styles.imdbIcon.color}
              style={styles.imdbIcon}
            />
          )}
        </View>
      </Pressable>
    )
  }
)

const ItemPoster = memo(({ posterPath }: { posterPath: string }) => {
  const styles = useStyles(themedStyles)
  const imageSource: ImageSource = posterPath
    ? { uri: `https://image.tmdb.org/t/p/w500${posterPath}` }
    : defaultItemImage

  return (
    <Image
      source={imageSource}
      style={styles.posterImage}
      placeholder={defaultItemImage}
      contentFit="cover"
    />
  )
})

const HintsRenderer = memo(({ item }: { item: TriviaItem }) => {
  const { openLink } = useExternalLink()
  const styles = useStyles(themedStyles)

  const handleActorPress = useCallback(
    (actor: any) => {
      if (actor.imdb_id) {
        analyticsService.trackActorLinkTapped(actor.name)
        openLink(`${API_CONFIG.IMDB_BASE_URL_NAME}${actor.imdb_id}`)
      }
    },
    [openLink]
  )

  const renderHint = (hint: Hint) => {
    switch (hint.type) {
      case "director":
        return (
          <Typography key={hint.type} variant="caption" style={styles.director}>
            {hint.label}: {String(hint.value)}
          </Typography>
        )
      case "actors":
        if (Array.isArray(hint.value)) {
          return (
            <Actors
              key={hint.type}
              actors={hint.value}
              onActorPress={handleActorPress}
            />
          )
        }
        return null
      default:
        return null
    }
  }

  return <>{item.hints.map(renderHint)}</>
})

interface FactsProps {
  item: TriviaItem
  isLoading?: boolean
  error?: string
  isScrollEnabled?: boolean
}

const Facts = memo(
  ({ item, isLoading = false, error, isScrollEnabled = true }: FactsProps) => {
    const styles = useStyles(themedStyles)
    const { openLink } = useExternalLink()

    const handleItemPress = useCallback(() => {
      const imdbId = item.metadata.imdb_id
      if (imdbId) {
        analyticsService.trackImdbLinkTapped(item.title)
        openLink(`${API_CONFIG.IMDB_BASE_URL_TITLE}${imdbId}`)
      }
    }, [openLink, item.title, item.metadata.imdb_id])

    if (isLoading) {
      return (
        <ActivityIndicator
          testID="activity-indicator"
          size="large"
          color={styles.loadingIndicator.color}
        />
      )
    }

    if (error) {
      return (
        <View style={[u.flex, u.justifyCenter, u.alignCenter, u.pMd]}>
          <Typography variant="error">{error}</Typography>
        </View>
      )
    }

    return (
      <View style={styles.container}>
        <ItemHeader
          title={item.title}
          onPress={handleItemPress}
          isLinkable={!!item.metadata.imdb_id}
        />
        {item.metadata.tagline && (
          <Typography variant="caption" style={styles.tagline}>
            {item.metadata.tagline}
          </Typography>
        )}
        <ScrollView
          scrollEnabled={isScrollEnabled}
          contentContainerStyle={styles.scrollContainer}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >
          <ItemPoster posterPath={item.posterPath} />
          <HintsRenderer item={item} />
        </ScrollView>
      </View>
    )
  }
)

interface FactsStyles {
  container: ViewStyle
  headerContainer: ViewStyle
  header: TextStyle
  imdbIcon: TextStyle & { fontSize: number }
  tagline: TextStyle
  director: TextStyle
  scrollContainer: ViewStyle
  posterImage: ImageStyle
  headerPressable: ViewStyle
  loadingIndicator: { color: string }
  linkText: TextStyle
}

const themedStyles = (theme: Theme): FactsStyles => ({
  container: {
    alignItems: "center",
    flex: 1,
    width: "100%",
  },
  headerContainer: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    flexWrap: "wrap",
  },
  header: {
    ...theme.typography.heading1,
    fontSize: theme.responsive.responsiveFontSize(24),
    paddingBottom: theme.spacing.medium,
    textAlign: "center",
  },
  linkText: {
    textDecorationLine: "underline",
  },
  imdbIcon: {
    marginLeft: theme.spacing.small,
    paddingBottom: theme.spacing.small,
    fontSize: theme.responsive.scale(22),
    color: theme.colors.primary,
  },
  tagline: {
    fontFamily: "Arvo-Italic",
    fontSize: theme.responsive.responsiveFontSize(14),
    textAlign: "center",
    width: "90%",
    marginBottom: theme.spacing.small,
    color: theme.colors.primary,
    fontStyle: "italic",
    lineHeight: theme.responsive.responsiveFontSize(16),
  },
  director: {
    fontFamily: "Arvo-Italic",
    fontSize: theme.responsive.responsiveFontSize(14),
    textAlign: "center",
    width: "90%",
    marginBottom: theme.spacing.small,
    color: theme.colors.textSecondary,
    fontStyle: "italic",
  },
  scrollContainer: {
    flexGrow: 1,
    alignItems: "center",
    paddingVertical: theme.spacing.medium,
    paddingBottom: theme.spacing.large,
    width: "100%",
  },
  posterImage: {
    width: "100%",
    height: undefined,
    aspectRatio: 2 / 3,
    marginBottom: theme.spacing.medium,
    borderRadius: theme.responsive.scale(8),
  },
  headerPressable: {
    width: "100%",
    alignItems: "center",
    paddingVertical: theme.spacing.small,
    backgroundColor: "transparent",
  },
  loadingIndicator: {
    color: theme.colors.primary,
  },
})

export default Facts

================
File: src/components/flashMessages.tsx
================
import React, { useEffect } from "react"
import { Text, View, ViewStyle, TextStyle } from "react-native"
import Animated, {
  useSharedValue,
  withTiming,
  Easing,
  useAnimatedStyle,
} from "react-native-reanimated"
import { useStyles, Theme } from "../utils/hooks/useStyles"

interface FlashMessageProps {
  message: string | null
  duration?: number
}

const FlashMessages: React.FC<FlashMessageProps> = ({
  message,
  duration = 3000,
}) => {
  const styles = useStyles(themedStyles)
  const opacity = useSharedValue(0)

  useEffect(() => {
    if (message) {
      opacity.value = withTiming(1, { duration: 300, easing: Easing.ease })
      const timer = setTimeout(() => {
        opacity.value = withTiming(0, { duration: 300, easing: Easing.ease })
      }, duration)
      return () => clearTimeout(timer)
    }
  }, [message, duration, opacity])

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
  }))

  if (!message) return null

  return (
    <Animated.View style={[styles.container, animatedStyle]}>
      <View style={styles.shadowWrapper}>
        <Text style={styles.messageText}>{message}</Text>
      </View>
    </Animated.View>
  )
}

interface FlashMessageStyles {
  container: ViewStyle
  shadowWrapper: ViewStyle
  messageText: TextStyle
}

const themedStyles = (theme: Theme): FlashMessageStyles => ({
  container: {
    position: "absolute",
    top: theme.responsive.scale(30),
    left: 0,
    right: 0,
    zIndex: 1000,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: theme.spacing.large,
  },
  shadowWrapper: {
    backgroundColor: theme.colors.tertiary,
    borderRadius: theme.responsive.scale(8),
    ...theme.shadows.medium,
  },
  messageText: {
    color: theme.colors.background,
    fontSize: theme.responsive.responsiveFontSize(16),
    fontFamily: "Arvo-Bold",
    textAlign: "center",
    paddingVertical: theme.spacing.small,
    paddingHorizontal: theme.spacing.medium,
  },
})

export default FlashMessages

================
File: src/components/gameDifficultyToggle.tsx
================
import React, { useCallback, useState, useEffect } from "react"
import { View, Text, Pressable, ViewStyle, TextStyle } from "react-native"
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  Easing,
} from "react-native-reanimated"
import { FontAwesome } from "@expo/vector-icons"
import { hapticsService } from "../utils/hapticsService"
import { useGameStore } from "../state/gameStore"
import { DifficultyLevel, DIFFICULTY_MODES } from "../config/difficulty"
import { useStyles, Theme, useThemeTokens } from "../utils/hooks/useStyles"

const options = (Object.keys(DIFFICULTY_MODES) as DifficultyLevel[]).map(
  (key) => ({
    value: key,
    label: DIFFICULTY_MODES[key].label,
  })
)

const DROPDOWN_HEIGHT = options.length * 44

const GameDifficultyToggle = () => {
  const styles = useStyles(themedStyles)
  const theme = useThemeTokens()
  const { colors } = theme

  const difficulty = useGameStore((state) => state.difficulty)
  const setDifficulty = useGameStore((state) => state.setDifficulty)
  const guesses = useGameStore((state) => state.playerGame.guesses)
  const isInteractionsDisabled = useGameStore(
    (state) => state.isInteractionsDisabled
  )

  const [isExpanded, setIsExpanded] = useState(false)
  const animation = useSharedValue(0)

  useEffect(() => {
    animation.value = withTiming(isExpanded ? 1 : 0, {
      duration: 250,
      easing: Easing.inOut(Easing.ease),
    })
  }, [isExpanded, animation])

  const animatedDropdownStyle = useAnimatedStyle(() => {
    return {
      height: animation.value * DROPDOWN_HEIGHT,
      opacity: animation.value,
    }
  })

  const handleToggle = () => {
    if (isInteractionsDisabled) return
    hapticsService.light()
    setIsExpanded(!isExpanded)
  }

  const handleSelect = useCallback(
    (newDifficulty: DifficultyLevel) => {
      hapticsService.medium()
      setDifficulty(newDifficulty)
      setIsExpanded(false)
    },
    [setDifficulty]
  )

  const currentLabel =
    options.find((o) => o.value === difficulty)?.label || "Select"

  return (
    <View style={styles.container}>
      <Pressable
        onPress={handleToggle}
        style={styles.toggleButton}
        disabled={isInteractionsDisabled}
        accessibilityRole="button"
        accessibilityLabel={currentLabel}
        accessibilityState={{
          disabled: isInteractionsDisabled,
          expanded: isExpanded,
        }}
      >
        <Text style={styles.toggleButtonText}>{currentLabel}</Text>
        <FontAwesome
          name={isExpanded ? "chevron-up" : "chevron-down"}
          size={16}
          color={colors.textSecondary}
        />
      </Pressable>

      <Animated.View style={[styles.dropdownContainer, animatedDropdownStyle]}>
        {options.map((option) => {
          const isDisabled =
            DIFFICULTY_MODES[option.value].guessesMax < guesses.length
          return (
            <Pressable
              key={option.value}
              onPress={() => handleSelect(option.value)}
              style={[styles.optionButton, isDisabled && styles.disabledOption]}
              disabled={isDisabled}
              accessibilityRole="button"
              accessibilityState={{ disabled: isDisabled }}
            >
              <Text
                style={[
                  styles.optionText,
                  difficulty === option.value && styles.selectedOptionText,
                  isDisabled && styles.disabledText,
                ]}
              >
                {option.label}
              </Text>
            </Pressable>
          )
        })}
      </Animated.View>
    </View>
  )
}

interface GameDifficultyToggleStyles {
  container: ViewStyle
  toggleButton: ViewStyle
  toggleButtonText: TextStyle
  dropdownContainer: ViewStyle
  optionButton: ViewStyle
  optionText: TextStyle
  selectedOptionText: TextStyle
  disabledOption: ViewStyle
  disabledText: TextStyle
}

const themedStyles = (theme: Theme): GameDifficultyToggleStyles => ({
  container: {
    alignItems: "center",
    marginVertical: theme.spacing.small,
    zIndex: 10,
  },
  toggleButton: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: theme.colors.surface,
    paddingVertical: theme.spacing.extraSmall,
    paddingHorizontal: theme.spacing.small,
    borderRadius: theme.responsive.scale(8),
    ...theme.shadows.light,
  },
  toggleButtonText: {
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(14),
    color: theme.colors.textPrimary,
    marginRight: theme.spacing.small,
  },
  dropdownContainer: {
    position: "absolute",
    top: "100%",
    width: theme.responsive.scale(120),
    backgroundColor: theme.colors.backgroundLight,
    borderRadius: theme.responsive.scale(8),
    marginTop: theme.spacing.extraSmall,
    ...theme.shadows.medium,
    overflow: "hidden",
  },
  optionButton: {
    padding: theme.spacing.small,
    alignItems: "center",
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.border,
  },
  optionText: {
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(16),
    color: theme.colors.textPrimary,
  },
  selectedOptionText: {
    fontFamily: "Arvo-Bold",
    color: theme.colors.primary,
  },
  disabledOption: {
    backgroundColor: theme.colors.backgroundLight,
  },
  disabledText: {
    color: theme.colors.textDisabled,
  },
})

export default GameDifficultyToggle

================
File: src/components/gameHistory.tsx
================
import React, { useState, useEffect, memo, useCallback } from "react"
import { View, Pressable } from "react-native"
import { Image } from "expo-image"
import { FlashList } from "@shopify/flash-list"
import Animated from "react-native-reanimated"
import { useAuth } from "../contexts/authContext"
import { GameHistoryEntry } from "../models/gameHistory"
import { hapticsService } from "../utils/hapticsService"
import { API_CONFIG } from "../config/constants"
import { DIFFICULTY_MODES } from "../config/difficulty"
import { gameService } from "../services/gameService"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"
import { useSkeletonAnimation } from "../utils/hooks/useSkeletonAnimation"

const GameHistorySkeletonItem = memo(() => {
  const styles = useStyles(themedStyles)
  const animatedStyle = useSkeletonAnimation()

  return (
    <Animated.View
      style={[styles.itemContainer, animatedStyle]}
      testID="skeleton-item"
    >
      <View style={styles.skeletonPoster} />
      <View style={styles.infoContainer}>
        <View style={[styles.skeletonText, { width: "80%", height: 20 }]} />
        <View style={[styles.skeletonText, { width: "60%", marginTop: 8 }]} />
        <View style={[styles.skeletonText, { width: "40%", marginTop: 4 }]} />
      </View>
    </Animated.View>
  )
})

interface GameHistoryItemProps {
  item: GameHistoryEntry
  onPress: (item: GameHistoryEntry) => void
}

const GameHistoryItem = memo(({ item, onPress }: GameHistoryItemProps) => {
  const styles = useStyles(themedStyles)
  const posterUri = `${API_CONFIG.TMDB_IMAGE_BASE_URL_W185}${item.posterPath}`
  const difficultyLabel = DIFFICULTY_MODES[item.difficulty]?.label || "Unknown"
  const date = new Date(item.dateId)
  const formattedDate = date.toLocaleDateString("en-US", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
  })

  const handlePress = () => {
    hapticsService.light()
    onPress(item)
  }

  const getResultText = () => {
    if (item.wasCorrect) {
      return (
        <Typography style={[styles.resultText, styles.winText]}>
          Correct in {item.guessCount}/{item.guessesMax} guesses!
        </Typography>
      )
    }
    return (
      <Typography style={[styles.resultText, styles.lossText]}>
        {item.gaveUp ? "Gave up" : "Incorrect"}
      </Typography>
    )
  }

  return (
    <Pressable
      onPress={handlePress}
      style={({ pressed }) => [
        styles.itemContainer,
        pressed && styles.itemPressed,
      ]}
    >
      <Image source={{ uri: posterUri }} style={styles.posterImage} />
      <View style={styles.infoContainer}>
        <Typography style={styles.itemTitle} numberOfLines={2}>
          {item.itemTitle}
        </Typography>
        <Typography style={styles.dateText}>{formattedDate}</Typography>
        <Typography style={styles.difficultyText}>
          Difficulty: {difficultyLabel}
        </Typography>
        {getResultText()}
      </View>
      <View style={styles.scoreContainer}>
        <Typography style={styles.scoreText}>{item.score}</Typography>
        <Typography style={styles.scoreLabel}>PTS</Typography>
      </View>
    </Pressable>
  )
})

interface GameHistoryProps {
  onHistoryItemPress: (item: GameHistoryEntry) => void
}

const GameHistory = ({ onHistoryItemPress }: GameHistoryProps) => {
  const { player } = useAuth()
  const styles = useStyles(themedStyles)
  const [history, setHistory] = useState<GameHistoryEntry[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchHistory = async () => {
      if (!player) {
        setLoading(false)
        return
      }

      try {
        const fetchedHistory = await gameService.fetchGameHistory(player.id)
        setHistory(fetchedHistory)
      } catch (err: any) {
        console.error("Failed to fetch game history:", err)
        setError("Could not load game history.")
      } finally {
        setLoading(false)
      }
    }

    fetchHistory()
  }, [player])

  const renderItem = useCallback(
    ({ item }: { item: GameHistoryEntry }) => (
      <GameHistoryItem item={item} onPress={onHistoryItemPress} />
    ),
    [onHistoryItemPress]
  )

  if (loading) {
    return (
      <View style={styles.container}>
        {Array(5)
          .fill(0)
          .map((_, index) => (
            <GameHistorySkeletonItem key={`skeleton-${index}`} />
          ))}
      </View>
    )
  }

  if (error) {
    return (
      <View style={styles.emptyContainer}>
        <Typography style={styles.emptyText}>{error}</Typography>
      </View>
    )
  }

  return (
    <View style={styles.container}>
      <FlashList
        data={history}
        renderItem={renderItem}
        keyExtractor={(item) => `${item.dateId}-${item.itemId}`}
        contentContainerStyle={styles.listContainer}
        estimatedItemSize={107}
        ListEmptyComponent={() => (
          <View style={styles.emptyContainer}>
            <Typography style={styles.emptyText}>
              Play a game to see your history here!
            </Typography>
          </View>
        )}
      />
    </View>
  )
}

const themedStyles = (theme: Theme): any => ({
  container: {
    flex: 1,
    width: "100%",
    minHeight: 200,
  },
  listContainer: {
    paddingBottom: theme.spacing.large,
  },
  itemContainer: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: theme.colors.background,
    borderRadius: theme.responsive.scale(8),
    marginBottom: theme.spacing.small,
    padding: theme.spacing.small,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  itemPressed: {
    backgroundColor: theme.colors.surface,
  },
  posterImage: {
    width: theme.responsive.scale(60),
    height: theme.responsive.scale(90),
    borderRadius: theme.responsive.scale(4),
  },
  infoContainer: {
    flex: 1,
    marginLeft: theme.spacing.medium,
  },
  itemTitle: {
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(16),
    color: theme.colors.textPrimary,
    marginBottom: theme.spacing.extraSmall,
  },
  dateText: {
    ...theme.typography.caption,
    marginBottom: theme.spacing.extraSmall,
  },
  difficultyText: {
    fontFamily: "Arvo-Italic",
    fontSize: theme.responsive.responsiveFontSize(12),
    color: theme.colors.primary,
    marginBottom: theme.spacing.extraSmall,
  },
  resultText: {
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(14),
  },
  winText: {
    color: theme.colors.success,
  },
  lossText: {
    color: theme.colors.error,
  },
  scoreContainer: {
    alignItems: "center",
    justifyContent: "center",
    paddingLeft: theme.spacing.small,
  },
  scoreText: {
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(20),
    color: theme.colors.tertiary,
  },
  scoreLabel: {
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(10),
    color: theme.colors.textSecondary,
    marginTop: -theme.spacing.extraSmall,
  },
  emptyContainer: {
    alignItems: "center",
    justifyContent: "center",
    padding: theme.spacing.large,
  },
  emptyText: {
    fontFamily: "Arvo-Italic",
    fontSize: theme.responsive.responsiveFontSize(16),
    color: theme.colors.textSecondary,
    textAlign: "center",
  },
  skeletonPoster: {
    width: theme.responsive.scale(60),
    height: theme.responsive.scale(90),
    borderRadius: theme.responsive.scale(4),
    backgroundColor: theme.colors.surface,
  },
  skeletonText: {
    backgroundColor: theme.colors.surface,
    height: 16,
    borderRadius: 4,
    marginBottom: 4,
  },
})

export default GameHistory

================
File: src/components/gameOverView.tsx
================
import React, { useEffect } from "react"
import { ScrollView, TextStyle, ViewStyle } from "react-native"
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  Easing,
} from "react-native-reanimated"
import CountdownTimer from "./countdownTimer"
import Facts from "./facts"
import PersonalizedStatsMessage from "./personalizedStatsMessage"
import { PlayerGame } from "../models/game"
import GuessesContainer from "./guesses"
import FullPlotSection from "./gameOver/fullPlotSection"
import ShareResultButton from "./gameOver/shareResultButton"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Card } from "./ui/card"
import { Typography } from "./ui/typography"

interface GameOverViewProps {
  playerGame: PlayerGame
  lastGuessResult: { itemId: number | string; correct: boolean } | null
}

const GameOverView: React.FC<GameOverViewProps> = ({
  playerGame,
  lastGuessResult,
}) => {
  const styles = useStyles(themedStyles)
  const fadeAnimation = useSharedValue(0)

  useEffect(() => {
    fadeAnimation.value = withTiming(1, {
      duration: 600,
      easing: Easing.out(Easing.ease),
    })
  }, [fadeAnimation])

  const animatedContainerStyle = useAnimatedStyle(() => {
    return {
      opacity: fadeAnimation.value,
    }
  })

  const resultTitle = playerGame.correctAnswer ? "You Got It!" : "So Close!"
  const resultMessage = playerGame.correctAnswer
    ? `You guessed it in ${playerGame.guesses.length} guess${
        playerGame.guesses.length > 1 ? "es" : ""
      }!`
    : playerGame.gaveUp
    ? "Sometimes you just know when to fold 'em."
    : "Better luck next time."

  return (
    <Animated.View style={[{ width: "100%" }, animatedContainerStyle]}>
      <Card style={styles.card}>
        <ScrollView
          style={styles.scrollView}
          contentContainerStyle={styles.scrollContentContainer}
        >
          <Typography variant="h2" style={styles.resultTitle}>
            {resultTitle}
          </Typography>
          <Typography variant="body" style={styles.subText}>
            {resultMessage}
          </Typography>

          <Facts item={playerGame.triviaItem} isScrollEnabled={false} />

          <FullPlotSection overview={playerGame.triviaItem.description} />
        </ScrollView>
      </Card>

      <GuessesContainer lastGuessResult={lastGuessResult} />
      <ShareResultButton playerGame={playerGame} />
      <PersonalizedStatsMessage />
      <CountdownTimer />
    </Animated.View>
  )
}

interface GameOverStyles {
  card: ViewStyle
  scrollView: ViewStyle
  scrollContentContainer: ViewStyle
  resultTitle: TextStyle
  subText: TextStyle
}

const themedStyles = (theme: Theme): GameOverStyles => ({
  card: {
    width: "100%",
    marginVertical: theme.spacing.medium,
    overflow: "hidden",
    backfaceVisibility: "hidden",
  },
  scrollView: {
    maxHeight: theme.responsive.screenHeight * 0.5,
  },
  scrollContentContainer: {
    padding: theme.spacing.large,
    alignItems: "center",
  },
  resultTitle: {
    color: theme.colors.primary,
    textAlign: "center",
    marginBottom: theme.spacing.extraSmall,
  },
  subText: {
    fontFamily: "Arvo-Italic",
    textAlign: "center",
    marginBottom: theme.spacing.large,
  },
})

export default GameOverView

================
File: src/components/gameplayContainer.tsx
================
import React from "react"
import { View, ViewStyle } from "react-native"
import CluesContainer from "./clues"
import GameplayView from "./gameplayView"
import GameOverView from "./gameOverView"
import GuessesContainer from "./guesses"
import { useGameStore } from "../state/gameStore"
import RevealSequence from "./revealSequence"
import { useStyles, Theme } from "../utils/hooks/useStyles"

const GameplayContainer: React.FC = () => {
  const playerGame = useGameStore((state) => state.playerGame)
  const lastGuessResult = useGameStore((state) => state.lastGuessResult)
  const gameStatus = useGameStore((state) => state.gameStatus)
  const completeRevealSequence = useGameStore(
    (state) => state.completeRevealSequence
  )
  const styles = useStyles(themedStyles)

  const showGameOverView = gameStatus === "gameOver"

  return (
    <View style={styles.container}>
      {showGameOverView ? (
        <GameOverView
          playerGame={playerGame}
          lastGuessResult={lastGuessResult}
        />
      ) : (
        <>
          <CluesContainer />
          <GameplayView />
          <GuessesContainer lastGuessResult={lastGuessResult} />
        </>
      )}

      {gameStatus === "revealing" && (
        <RevealSequence onAnimationComplete={completeRevealSequence} />
      )}
    </View>
  )
}

interface GameplayContainerStyles {
  container: ViewStyle
}

const themedStyles = (theme: Theme): GameplayContainerStyles => ({
  container: {
    alignItems: "center",
    flexGrow: 1,
    width: "100%",
    maxWidth: theme.responsive.scale(600),
    alignSelf: "center",
    marginBottom: theme.spacing.extraLarge,
    paddingHorizontal: theme.spacing.small,
  },
})

export default GameplayContainer

================
File: src/components/gameplayView.tsx
================
import React, { useState, useCallback } from "react"
import { View, ViewStyle, StyleProp } from "react-native"
import PickerContainer from "./picker"
import HintContainer from "./hint"
import ConfirmationModal from "./confirmationModal"
import { hapticsService } from "../utils/hapticsService"
import { useGameStore } from "../state/gameStore"
import { useShallow } from "zustand/react/shallow"
import { Button } from "./ui/button"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { u } from "../styles/utils"
import { GAME_MODE_CONFIG } from "../config/difficulty"

const GameplayView: React.FC = () => {
  const { giveUp, isInteractionsDisabled, gameMode } = useGameStore(
    useShallow((state) => ({
      giveUp: state.giveUp,
      isInteractionsDisabled: state.isInteractionsDisabled,
      gameMode: state.gameMode,
    }))
  )
  const styles = useStyles(themedStyles)

  const [showGiveUpConfirmation, setShowGiveUpConfirmation] = useState(false)
  const [isGivingUp, setIsGivingUp] = useState(false)

  const handleGiveUpPress = useCallback(() => {
    hapticsService.warning()
    setShowGiveUpConfirmation(true)
  }, [])

  const cancelGiveUp = useCallback(() => setShowGiveUpConfirmation(false), [])

  const confirmGiveUp = useCallback(() => {
    setShowGiveUpConfirmation(false)
    setIsGivingUp(true)
    giveUp()
  }, [giveUp])

  return (
    <>
      <HintContainer />
      <PickerContainer />

      <Button
        title="Give Up?"
        onPress={handleGiveUpPress}
        isLoading={isGivingUp}
        disabled={isInteractionsDisabled}
        variant="error"
        style={[u.wFull, styles.giveUpButton] as StyleProp<ViewStyle>}
        testID="give-up-button"
      />

      <ConfirmationModal
        isVisible={showGiveUpConfirmation}
        title="Give Up?"
        message={GAME_MODE_CONFIG[gameMode].giveUpConfirmation}
        confirmText="Give Up"
        cancelText="Cancel"
        onConfirm={confirmGiveUp}
        onCancel={cancelGiveUp}
      />
    </>
  )
}

interface GameplayViewStyles {
  giveUpButton: ViewStyle
}

const themedStyles = (theme: Theme): GameplayViewStyles => ({
  giveUpButton: {
    backgroundColor: theme.colors.error,
  },
})

export default GameplayView

================
File: src/components/genres.tsx
================
import React, { memo } from "react"
import { View, ViewStyle, TextStyle } from "react-native"
import { Genre } from "../models/trivia"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"

interface GenreProps {
  genre: Genre
}

const GenreContainer = memo(({ genre }: GenreProps) => {
  const styles = useStyles(themedStyles)
  return (
    <View style={styles.genreContainer}>
      <Typography
        style={styles.genreText}
        numberOfLines={1}
        ellipsizeMode="tail"
      >
        {genre.name}
      </Typography>
    </View>
  )
})

interface GenresProps {
  genres: Genre[] | null
  maxGenres?: number
}

const Genres = memo(({ genres, maxGenres = 5 }: GenresProps) => {
  const styles = useStyles(themedStyles)

  if (!genres || genres.length === 0) {
    return (
      <View style={styles.genresContainer}>
        <Typography style={styles.noGenresText}>No genres available</Typography>
      </View>
    )
  }

  const displayedGenres = genres.slice(0, maxGenres)

  return (
    <View style={styles.genresContainer}>
      {displayedGenres.map((genre) => (
        <GenreContainer key={genre.id} genre={genre} />
      ))}
      {genres.length > maxGenres && (
        <Typography style={styles.noGenresText}>
          +{genres.length - maxGenres} more
        </Typography>
      )}
    </View>
  )
})

interface GenresStyles {
  genresContainer: ViewStyle
  genreContainer: ViewStyle
  genreText: TextStyle
  noGenresText: TextStyle
}

const themedStyles = (theme: Theme): GenresStyles => ({
  genresContainer: {
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "center",
    marginVertical: theme.spacing.medium,
    paddingHorizontal: theme.spacing.small,
  },
  genreContainer: {
    alignItems: "center",
    backgroundColor: "transparent",
    borderWidth: 2,
    borderColor: theme.colors.quinary,
    borderRadius: theme.responsive.scale(10),
    margin: theme.spacing.extraSmall,
    padding: theme.spacing.small,
    flexBasis: "auto",
    flexGrow: 1,
    flexShrink: 1,
    minHeight: theme.responsive.scale(30),
  },
  genreText: {
    color: theme.colors.textPrimary,
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(14),
    textAlign: "center",
  },
  noGenresText: {
    color: theme.colors.tertiary,
    fontFamily: "Arvo-Italic",
    fontSize: theme.responsive.responsiveFontSize(12),
    textAlign: "center",
    marginVertical: theme.spacing.small,
  },
})

export default Genres

================
File: src/components/googleLogin.tsx
================
import React, { memo } from "react"
import { View, ViewStyle, TextStyle } from "react-native"
import { useAuth } from "../contexts/authContext"
import { hapticsService } from "../utils/hapticsService"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Button } from "./ui/button"
import { Typography } from "./ui/typography"

const GoogleLogin: React.FC = memo(() => {
  const { player, user, handleSignIn, handleSignOut, isSigningIn, error } =
    useAuth()
  const styles = useStyles(themedStyles)

  const isSignedIn = !!user && !user.isAnonymous
  const displayName = user?.displayName || player?.name || ""

  const buttonText = isSignedIn
    ? `Sign Out ${displayName}`.trim()
    : "Sign In with Google"
  const accessibilityLabel = isSignedIn
    ? `Sign out ${displayName}`.trim()
    : "Sign in with Google"
  const accessibilityHint = isSignedIn
    ? "Signs you out of the game"
    : "Signs you in with your Google account"

  const handlePress = () => {
    hapticsService.medium()
    if (isSignedIn) {
      handleSignOut()
    } else {
      handleSignIn()
    }
  }

  return (
    <View style={styles.container}>
      <Button
        title={buttonText}
        onPress={handlePress}
        isLoading={isSigningIn}
        variant="secondary"
        style={styles.button}
        accessibilityLabel={accessibilityLabel}
        accessibilityHint={accessibilityHint}
        accessibilityRole="button"
        accessibilityState={{ disabled: isSigningIn }}
      />
      {error && (
        <Typography variant="error" style={styles.errorText}>
          {error}
        </Typography>
      )}
    </View>
  )
})

interface GoogleLoginStyles {
  container: ViewStyle
  button: ViewStyle
  errorText: TextStyle
}

const themedStyles = (theme: Theme): GoogleLoginStyles => ({
  container: {
    alignItems: "center",
    justifyContent: "center",
    width: "100%",
    maxWidth: theme.responsive.scale(400),
    alignSelf: "center",
    paddingVertical: theme.spacing.small,
  },
  button: {
    width: "100%",
    maxWidth: theme.responsive.scale(280),
  },
  errorText: {
    marginTop: theme.spacing.small,
    textAlign: "center",
    fontSize: theme.responsive.responsiveFontSize(14),
  },
})

export default GoogleLogin

================
File: src/components/guesses.tsx
================
import React, { memo, useMemo, useCallback } from "react"
import { View, ViewStyle } from "react-native"
import { FlashList, ListRenderItemInfo } from "@shopify/flash-list"
import { BasicTriviaItem } from "../models/trivia"
import { useGameStore } from "../state/gameStore"
import { HintInfo, PlayerGame, Guess } from "../models/game"
import { useShallow } from "zustand/react/shallow"
import { GuessRow } from "./guess/guessRow"
import { EmptyGuessTile } from "./guess/emptyGuessTile"
import { SkeletonRow } from "./guess/skeletonRow"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { spacing, responsive } from "../styles/global"

type GuessResult = {
  itemId: number | string
  correct: boolean
  feedback?: string | null
  hintInfo?: HintInfo[] | null
} | null

interface GuessesContainerProps {
  lastGuessResult: GuessResult
  gameForDisplay?: PlayerGame
  allItemsForDisplay?: readonly BasicTriviaItem[]
}

type ListItem =
  | { type: "guess"; guess: Guess; index: number }
  | { type: "empty"; index: number }
  | { type: "skeleton"; index: number }

const ESTIMATED_ROW_HEIGHT = responsive.scale(44) + spacing.small

const GuessesContainer = memo(
  ({
    lastGuessResult,
    gameForDisplay,
    allItemsForDisplay,
  }: GuessesContainerProps) => {
    const { loading, playerGame, basicItems } = useGameStore(
      useShallow((state) => ({
        loading: state.loading,
        playerGame: state.playerGame,
        basicItems: state.basicItems,
      }))
    )
    const styles = useStyles(themedStyles)

    const isDataLoading = gameForDisplay ? false : loading
    const currentGame = gameForDisplay || playerGame
    const items = allItemsForDisplay || basicItems

    const { guesses, guessesMax, triviaItem } = currentGame
    const correctItemId = triviaItem?.id ?? 0

    const listData: ListItem[] = useMemo(() => {
      const max = guessesMax || 5
      if (isDataLoading) {
        return Array.from({ length: max }, (_, index) => ({
          type: "skeleton",
          index,
        }))
      }

      const listItems: ListItem[] = []
      for (let i = 0; i < max; i++) {
        if (guesses[i]) {
          listItems.push({ type: "guess", guess: guesses[i], index: i })
        } else {
          listItems.push({ type: "empty", index: i })
        }
      }
      return listItems
    }, [isDataLoading, guesses, guessesMax])

    const renderListItem = useCallback(
      ({ item }: ListRenderItemInfo<ListItem>) => {
        switch (item.type) {
          case "skeleton":
            return <SkeletonRow index={item.index} />
          case "empty":
            return <EmptyGuessTile index={item.index} />
          case "guess": {
            const isLastGuess =
              !!lastGuessResult &&
              item.index === guesses.length - 1 &&
              lastGuessResult.itemId === item.guess.itemId
            return (
              <GuessRow
                index={item.index}
                guess={item.guess}
                basicItems={items}
                isLastGuess={isLastGuess}
                lastGuessResult={lastGuessResult}
                correctItemId={correctItemId}
              />
            )
          }
          default:
            return null
        }
      },
      [lastGuessResult, guesses.length, items, correctItemId]
    )

    const keyExtractor = useCallback(
      (item: ListItem) => item.index.toString(),
      []
    )

    const listContainerHeight = (guessesMax || 5) * ESTIMATED_ROW_HEIGHT

    return (
      <View style={[styles.listWrapper, { height: listContainerHeight }]}>
        <FlashList
          data={listData}
          renderItem={renderListItem}
          keyExtractor={keyExtractor}
          estimatedItemSize={ESTIMATED_ROW_HEIGHT}
          contentContainerStyle={styles.container}
          scrollEnabled={false}
        />
      </View>
    )
  }
)

interface GuessesContainerStyles {
  listWrapper: ViewStyle
  container: ViewStyle
}

const themedStyles = (theme: Theme): GuessesContainerStyles => ({
  listWrapper: {
    width: "100%",
  },
  container: {
    paddingVertical: theme.spacing.small,
  },
})

export default GuessesContainer

================
File: src/components/hint.tsx
================
import React, { memo } from "react"
import { View, TextStyle, ViewStyle } from "react-native"
import Animated from "react-native-reanimated"
import { useHintLogic } from "../utils/hooks/useHintLogic"
import HintUI from "./hintUI"
import { useSkeletonAnimation } from "../utils/hooks/useSkeletonAnimation"
import { useGameStore } from "../state/gameStore"
import { HintType } from "../models/game"
import { DIFFICULTY_MODES } from "../config/difficulty"
import { useShallow } from "zustand/react/shallow"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"

const HintSkeleton = memo(() => {
  const styles = useStyles(themedStyles)
  const animatedStyle = useSkeletonAnimation()
  return (
    <View style={styles.container}>
      <Animated.View style={[styles.skeletonLabel, animatedStyle]} />
    </View>
  )
})

const BasicHints = memo(() => {
  const { getHintText } = useHintLogic()
  const styles = useStyles(themedStyles)

  const hintTypes: HintType[] = ["decade", "director", "actor", "genre"]

  return (
    <View style={styles.basicHintsContainer}>
      <Typography variant="h2" style={styles.basicHintsTitle}>
        All Hints Revealed
      </Typography>
      {hintTypes.map((type) => (
        <View key={type} style={styles.basicHintsRow}>
          <Typography style={styles.basicHintsLabel}>
            {type.charAt(0).toUpperCase() + type.slice(1)}:
          </Typography>
          <Typography style={styles.basicHintsValue}>
            {getHintText(type)}
          </Typography>
        </View>
      ))}
    </View>
  )
})

const MainHintComponent = () => {
  const { playerStats } = useGameStore(
    useShallow((state) => ({
      playerStats: state.playerStats,
    }))
  )

  const {
    showHintOptions,
    hintLabelText,
    isToggleDisabled,
    hintStatuses,
    highlightedHint,
    handleToggleHintOptions,
    handleHintSelection,
    displayedHintText,
    allHints,
  } = useHintLogic()
  const styles = useStyles(themedStyles)

  if (!hintLabelText) return null

  // Implicit Feedback mode only shows the label.
  if (
    DIFFICULTY_MODES[useGameStore.getState().difficulty].hintStrategy ===
      "IMPLICIT_FEEDBACK" &&
    !isToggleDisabled
  ) {
    return (
      <View style={styles.container}>
        <Typography variant="caption" style={styles.hintLabelDisabled}>
          {hintLabelText}
        </Typography>
      </View>
    )
  }

  return (
    <HintUI
      showHintOptions={showHintOptions}
      displayedHintText={displayedHintText}
      hintLabelText={hintLabelText}
      isToggleDisabled={isToggleDisabled}
      hintsAvailable={playerStats?.hintsAvailable ?? 0}
      hintStatuses={hintStatuses}
      highlightedHint={highlightedHint}
      handleToggleHintOptions={handleToggleHintOptions}
      handleHintSelection={handleHintSelection}
      allHints={allHints}
    />
  )
}

const HintContainer: React.FC = memo(() => {
  const { loading, isInteractionsDisabled, difficulty } = useGameStore(
    useShallow((state) => ({
      loading: state.loading,
      isInteractionsDisabled: state.isInteractionsDisabled,
      difficulty: state.difficulty,
    }))
  )

  if (loading) {
    return <HintSkeleton />
  }

  const currentStrategy = DIFFICULTY_MODES[difficulty]?.hintStrategy
  if (
    currentStrategy === "NONE_DISABLED" ||
    currentStrategy === "EXTREME_CHALLENGE"
  ) {
    return null
  }

  if (
    (currentStrategy === "ALL_REVEALED" ||
      currentStrategy === "HINTS_ONLY_REVEALED") &&
    !isInteractionsDisabled
  ) {
    return <BasicHints />
  }

  return <MainHintComponent />
})

interface HintStyles {
  container: ViewStyle
  skeletonLabel: ViewStyle
  hintLabelDisabled: TextStyle
  basicHintsContainer: ViewStyle
  basicHintsTitle: TextStyle
  basicHintsRow: ViewStyle
  basicHintsLabel: TextStyle
  basicHintsValue: TextStyle
}

const themedStyles = (theme: Theme): HintStyles => ({
  container: {
    alignItems: "center",
    justifyContent: "center",
    marginVertical: theme.responsive.scale(2),
    width: "100%",
  },
  skeletonLabel: {
    backgroundColor: theme.colors.surface,
    height: theme.responsive.scale(20),
    width: "50%",
    borderRadius: theme.responsive.scale(4),
    marginVertical: theme.spacing.small,
  },
  hintLabelDisabled: {
    ...theme.typography.caption,
    color: theme.colors.textDisabled,
    fontFamily: "Arvo-Italic",
    textAlign: "center",
    paddingVertical: theme.spacing.small,
  },
  basicHintsContainer: {
    width: "90%",
    backgroundColor: theme.colors.surface,
    borderRadius: theme.responsive.scale(8),
    padding: theme.spacing.medium,
    marginVertical: theme.spacing.small,
  },
  basicHintsTitle: {
    fontSize: theme.responsive.responsiveFontSize(16),
    color: theme.colors.primary,
    textAlign: "center",
    marginBottom: theme.spacing.medium,
  },
  basicHintsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingVertical: theme.spacing.extraSmall,
  },
  basicHintsLabel: {
    ...theme.typography.bodyText,
    fontFamily: "Arvo-Bold",
    color: theme.colors.textPrimary,
  },
  basicHintsValue: {
    ...theme.typography.bodyText,
    flex: 1,
    textAlign: "right",
    marginLeft: theme.spacing.small,
  },
})

export default HintContainer

================
File: src/components/hintButton.tsx
================
import React, { useEffect } from "react"
import { Pressable, Text, StyleProp, ViewStyle, TextStyle } from "react-native"
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from "react-native-reanimated"
import Ionicons from "@expo/vector-icons/Ionicons"
import { HintType } from "../models/game"
import { useStyles, Theme } from "../utils/hooks/useStyles"

type HintStatus = "available" | "used" | "disabled"

interface HintButtonProps {
  hintType: HintType
  iconName: keyof typeof Ionicons.glyphMap
  label: string
  onPress: (type: HintType) => void
  status: HintStatus
  accessibilityHintCount: number
  isHighlighted: boolean
}

const HintButton: React.FC<HintButtonProps> = ({
  hintType,
  iconName,
  label,
  onPress,
  status,
  accessibilityHintCount,
  isHighlighted,
}) => {
  const styles = useStyles(themedStyles)
  const highlightAnimation = useSharedValue(0)

  useEffect(() => {
    if (isHighlighted) {
      highlightAnimation.value = withRepeat(
        withSequence(
          withTiming(1, { duration: 500 }),
          withTiming(0, { duration: 800 })
        ),
        -1,
        true
      )
    } else {
      highlightAnimation.value = withTiming(0)
    }
  }, [isHighlighted, highlightAnimation])

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ scale: 1 + highlightAnimation.value * 0.05 }],
      borderColor: isHighlighted
        ? styles.highlightedHintButton.borderColor
        : styles.hintButton.borderColor,
    }
  })

  const buttonStyle: StyleProp<ViewStyle> = [styles.hintButton]
  const textStyle: StyleProp<TextStyle> = [styles.buttonTextSmall]
  let iconColor = styles.buttonTextSmall.color

  if (status === "disabled") {
    buttonStyle.push(styles.disabled)
    textStyle.push(styles.disabledText)
    iconColor = styles.disabledText.color
  } else if (status === "used") {
    buttonStyle.push(styles.usedHintButton)
    textStyle.push(styles.usedText)
    iconColor = styles.usedText.color
  }

  if (isHighlighted) {
    buttonStyle.push(styles.highlightedHintButton)
    textStyle.push(styles.highlightedText)
    iconColor = styles.highlightedText.color
  }

  const getAccessibilityLabel = () => {
    switch (status) {
      case "used":
        return `Re-view the ${label.toLowerCase()} hint.`
      case "disabled":
        return `${label} hint unavailable.`
      case "available":
      default:
        return `Get the movie's ${label.toLowerCase()} hint. ${accessibilityHintCount} hints available.`
    }
  }

  return (
    <Animated.View style={animatedStyle}>
      <Pressable
        style={buttonStyle}
        onPress={() => onPress(hintType)}
        disabled={status === "disabled"}
        accessible
        accessibilityRole="button"
        accessibilityState={{ disabled: status === "disabled" }}
        accessibilityLabel={getAccessibilityLabel()}
      >
        <Ionicons
          name={iconName}
          size={styles.icon.fontSize}
          color={iconColor}
        />
        <Text style={textStyle}>{label}</Text>
      </Pressable>
    </Animated.View>
  )
}

interface HintButtonStyles {
  hintButton: ViewStyle
  usedHintButton: ViewStyle
  highlightedHintButton: ViewStyle
  disabled: ViewStyle
  icon: TextStyle
  buttonTextSmall: TextStyle
  disabledText: TextStyle
  usedText: TextStyle
  highlightedText: TextStyle
}

const themedStyles = (theme: Theme): HintButtonStyles => ({
  hintButton: {
    borderRadius: theme.responsive.scale(4),
    padding: theme.responsive.scale(6),
    minWidth: "20%",
    alignItems: "center",
    justifyContent: "center",
    marginHorizontal: theme.responsive.scale(4),
    marginVertical: theme.responsive.scale(8),
    backgroundColor: "transparent",
    borderWidth: 1,
    borderColor: theme.colors.textSecondary,
  },
  usedHintButton: {
    borderColor: theme.colors.tertiary,
    opacity: 0.8,
  },
  highlightedHintButton: {
    borderColor: theme.colors.primary,
    borderWidth: 2,
    ...theme.shadows.medium,
    shadowColor: theme.colors.primary,
  },
  disabled: {
    opacity: 0.5,
  },
  icon: {
    fontSize: theme.responsive.scale(20),
  },
  buttonTextSmall: {
    ...theme.typography.caption,
    color: theme.colors.textSecondary,
    marginTop: theme.spacing.extraSmall,
  },
  disabledText: {
    color: theme.colors.textDisabled,
  },
  usedText: {
    color: theme.colors.tertiary,
  },
  highlightedText: {
    color: theme.colors.primary,
  },
})

export default HintButton

================
File: src/components/hintUI.tsx
================
import React, { memo, useEffect } from "react"
import { View, Pressable, ViewStyle, TextStyle } from "react-native"
import Ionicons from "@expo/vector-icons/Ionicons"
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
} from "react-native-reanimated"
import { HintType } from "../models/game"
import HintButton from "./hintButton"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"
import { Hint } from "../models/trivia"

type HintStatus = "available" | "used" | "disabled"

// A map to associate hint types with specific icons.
const ICON_MAP: Record<string, keyof typeof Ionicons.glyphMap> = {
  decade: "calendar-outline",
  director: "film-outline",
  actor: "person-outline",
  genre: "folder-open-outline",
  developer: "game-controller-outline",
  platform: "hardware-chip-outline",
  default: "information-circle-outline",
}

interface HintUIProps {
  showHintOptions: boolean
  displayedHintText: string | null
  hintLabelText: string
  isToggleDisabled: boolean
  hintsAvailable: number
  hintStatuses: Record<string, HintStatus>
  highlightedHint: string | null
  handleToggleHintOptions: () => void
  handleHintSelection: (type: HintType) => void
  allHints: Hint[]
}

const HINT_CONTAINER_HEIGHT = 80 // Adjusted for better spacing

const HintUI: React.FC<HintUIProps> = memo(
  ({
    showHintOptions,
    displayedHintText,
    hintLabelText,
    isToggleDisabled,
    hintsAvailable,
    hintStatuses,
    highlightedHint,
    handleToggleHintOptions,
    handleHintSelection,
    allHints,
  }) => {
    const styles = useStyles(themedStyles)
    const animatedHeight = useSharedValue(0)

    const animatedContainerStyle = useAnimatedStyle(() => {
      return {
        height: animatedHeight.value,
        opacity: withTiming(animatedHeight.value > 0 ? 1 : 0, {
          duration: 150,
        }),
      }
    })

    useEffect(() => {
      animatedHeight.value = withTiming(
        showHintOptions ? HINT_CONTAINER_HEIGHT : 0,
        {
          duration: 300,
        }
      )
    }, [showHintOptions, animatedHeight])

    return (
      <View style={styles.container}>
        <Pressable
          onPress={handleToggleHintOptions}
          disabled={isToggleDisabled}
          accessible={true}
          accessibilityRole="button"
          accessibilityState={{ disabled: isToggleDisabled }}
          accessibilityLabel={hintLabelText}
          style={isToggleDisabled ? styles.disabled : {}}
        >
          <Typography
            variant="body"
            style={[
              styles.hintLabel,
              isToggleDisabled && styles.hintLabelDisabled,
            ]}
          >
            {hintLabelText}
          </Typography>
        </Pressable>

        <Animated.View
          style={[styles.hintButtonsContainer, animatedContainerStyle]}
        >
          <View style={styles.hintButtonArea}>
            {allHints.map((hint) => (
              <HintButton
                key={hint.type}
                hintType={hint.type}
                iconName={ICON_MAP[hint.type] || ICON_MAP.default}
                label={hint.label}
                onPress={handleHintSelection}
                status={hintStatuses[hint.type]}
                accessibilityHintCount={hintsAvailable}
                isHighlighted={highlightedHint === hint.type}
              />
            ))}
          </View>
        </Animated.View>

        {displayedHintText && (
          <View style={styles.displayedHintContainer}>
            <View style={styles.displayedHintContent}>
              <Ionicons name="bulb-outline" style={styles.displayedHintIcon} />
              <Typography style={styles.hintText}>
                {displayedHintText}
              </Typography>
            </View>
          </View>
        )}
      </View>
    )
  }
)

interface HintUIStyles {
  container: ViewStyle
  disabled: ViewStyle
  hintLabel: TextStyle
  hintLabelDisabled: TextStyle
  hintButtonsContainer: ViewStyle
  hintButtonArea: ViewStyle
  displayedHintContainer: ViewStyle
  displayedHintContent: ViewStyle
  displayedHintIcon: TextStyle
  hintText: TextStyle
}

const themedStyles = (theme: Theme): HintUIStyles => ({
  container: {
    alignItems: "center",
    justifyContent: "center",
    marginVertical: theme.responsive.scale(2),
    width: "100%",
  },
  disabled: {
    opacity: 0.5,
  },
  hintLabel: {
    ...theme.typography.bodyText,
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(14),
    marginVertical: theme.responsive.scale(4),
    textAlign: "center",
    paddingVertical: theme.responsive.scale(4),
  },
  hintLabelDisabled: {
    color: theme.colors.textDisabled,
  },
  hintButtonsContainer: {
    flexDirection: "column",
    alignItems: "center",
    width: "100%",
    overflow: "hidden",
  },
  hintButtonArea: {
    flexDirection: "row",
    justifyContent: "center",
    flexWrap: "nowrap",
    width: "100%",
  },
  displayedHintContainer: {
    marginTop: theme.spacing.small,
    padding: theme.responsive.scale(2),
    backgroundColor: theme.colors.tertiary,
    borderRadius: theme.responsive.scale(10),
    width: "90%",
    alignSelf: "center",
  },
  displayedHintContent: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.surface,
    borderRadius: theme.responsive.scale(8),
    paddingVertical: theme.spacing.small,
    paddingHorizontal: theme.spacing.medium,
  },
  displayedHintIcon: {
    color: theme.colors.tertiary,
    fontSize: theme.responsive.responsiveFontSize(18),
    marginRight: theme.spacing.small,
  },
  hintText: {
    color: theme.colors.primary,
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(16),
    textAlign: "center",
  },
})

export default HintUI

================
File: src/components/historyDetailModal.tsx
================
import React, { useState, useEffect, Suspense, lazy } from "react"
import {
  View,
  ActivityIndicator,
  ScrollView,
  ViewStyle,
  TextStyle,
} from "react-native"
import { GameHistoryEntry } from "../models/gameHistory"
import { TriviaItem, BasicTriviaItem } from "../models/trivia"
import { PlayerGame } from "../models/game"
import { useAuth } from "../contexts/authContext"
import { gameService } from "../services/gameService"
import { getGameDataService } from "../services/gameServiceFactory"
import { useStyles, Theme, useThemeTokens } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"

const DetailModal = lazy(() => import("./detailModal"))
const Facts = lazy(() => import("./facts"))
const GuessesContainer = lazy(() => import("./guesses"))

interface HistoryDetailModalProps {
  historyItem: GameHistoryEntry | null
  onClose: () => void
}

const HistoryDetailModal: React.FC<HistoryDetailModalProps> = ({
  historyItem,
  onClose,
}) => {
  const { player } = useAuth()
  const styles = useStyles(themedStyles)
  const theme = useThemeTokens() // Use hook directly

  const [item, setItem] = useState<TriviaItem | null>(null)
  const [playerGame, setPlayerGame] = useState<PlayerGame | null>(null)
  const [allBasicItems, setAllBasicItems] = useState<
    readonly BasicTriviaItem[]
  >([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (!historyItem || !player) {
      setItem(null)
      setPlayerGame(null)
      return
    }

    const fetchData = async () => {
      setIsLoading(true)
      setError(null)
      try {
        const dataService = getGameDataService(historyItem.gameMode)
        const playerGameId = `${player.id}-${historyItem.dateId}`

        const [fetchedItem, fetchedPlayerGame, { basicItems }] =
          await Promise.all([
            dataService.getItemById(historyItem.itemId),
            gameService.fetchPlayerGameById(playerGameId),
            dataService.getDailyTriviaItemAndLists(),
          ])

        if (fetchedItem && fetchedPlayerGame) {
          setItem(fetchedItem)
          setPlayerGame(fetchedPlayerGame)
          setAllBasicItems(basicItems)
        } else {
          throw new Error("Could not find item or game history details.")
        }
      } catch (e: any) {
        console.error("Failed to fetch history details:", e)
        setError(e.message || "Failed to load history.")
      } finally {
        setIsLoading(false)
      }
    }

    fetchData()
  }, [historyItem, player])

  const renderModalContent = () => {
    if (isLoading) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      )
    }
    if (error) {
      return (
        <View style={styles.errorContainer}>
          <Typography variant="error">{error}</Typography>
        </View>
      )
    }
    if (item) {
      return (
        <ScrollView showsVerticalScrollIndicator={false}>
          <Facts item={item} isScrollEnabled={false} />
          {playerGame && (
            <View>
              <Typography variant="h2" style={styles.guessesTitle}>
                Your Guesses
              </Typography>
              <Suspense fallback={<ActivityIndicator />}>
                <GuessesContainer
                  gameForDisplay={playerGame}
                  allItemsForDisplay={allBasicItems}
                  lastGuessResult={null}
                />
              </Suspense>
            </View>
          )}
        </ScrollView>
      )
    }
    return null
  }

  return (
    <Suspense fallback={null}>
      <DetailModal show={!!historyItem} toggleModal={onClose}>
        <Suspense
          fallback={
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={theme.colors.primary} />
            </View>
          }
        >
          {renderModalContent()}
        </Suspense>
      </DetailModal>
    </Suspense>
  )
}

interface HistoryDetailModalStyles {
  loadingContainer: ViewStyle
  errorContainer: ViewStyle
  guessesTitle: TextStyle
}

const themedStyles = (theme: Theme): HistoryDetailModalStyles => ({
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    minHeight: theme.responsive.scale(300),
  },
  errorContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: theme.spacing.large,
    minHeight: theme.responsive.scale(300),
  },
  guessesTitle: {
    fontSize: theme.responsive.responsiveFontSize(20),
    textAlign: "center",
    marginTop: theme.spacing.large,
    marginBottom: theme.spacing.medium,
  },
})

export default HistoryDetailModal

================
File: src/components/loadingIndicator.tsx
================
import React, { memo, useMemo } from "react"
import { View, Platform, ViewStyle, TextStyle } from "react-native"
import CustomLoadingIndicator from "./customLoadingIndicator"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"
import Constants from "expo-constants"
import { DEVICE_CONFIG } from "../config/constants"

interface LoadingIndicatorProps {
  message?: string
}

const useDeviceCheck = () => {
  return useMemo(() => {
    if (Platform.OS === "web") return false

    const deviceYearClass = Constants.deviceYearClass
    const threshold = DEVICE_CONFIG.LOW_END_DEVICE_THRESHOLD_YEAR

    if (deviceYearClass === null || typeof deviceYearClass === "undefined")
      return false

    const requiredClass = threshold - 2011
    return deviceYearClass < requiredClass
  }, [])
}

const LoadingIndicator: React.FC<LoadingIndicatorProps> = memo(
  ({ message }) => {
    const styles = useStyles(themedStyles)
    const isLowEndDevice = useDeviceCheck()

    return (
      <View
        style={styles.loadingContainer}
        testID="loading-indicator-container"
      >
        <CustomLoadingIndicator isLowEndDevice={isLowEndDevice} />
        {message && (
          <Typography style={styles.messageText}>{message}</Typography>
        )}
      </View>
    )
  }
)

interface LoadingIndicatorStyles {
  loadingContainer: ViewStyle
  messageText: TextStyle
}

const themedStyles = (theme: Theme): LoadingIndicatorStyles => ({
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: theme.colors.background,
    width: "100%",
  },
  messageText: {
    marginTop: theme.spacing.large,
    fontSize: theme.responsive.responsiveFontSize(16),
    color: theme.colors.textSecondary,
    textAlign: "center",
  },
})

export default LoadingIndicator

================
File: src/components/network.tsx
================
import React, { memo } from "react"
import { View, ViewStyle, TextStyle } from "react-native"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"

interface NetworkContainerProps {
  isConnected: boolean
}

const NetworkContainer = memo(({ isConnected }: NetworkContainerProps) => {
  const styles = useStyles(themedStyles)

  if (isConnected) {
    return null // Don't render anything when connected
  }

  return (
    <View style={styles.containerNotConnected}>
      <Typography style={styles.notConnectedText}>
        Network is not connected
      </Typography>
    </View>
  )
})

interface NetworkStyles {
  containerNotConnected: ViewStyle
  notConnectedText: TextStyle
}

const themedStyles = (theme: Theme): NetworkStyles => ({
  containerNotConnected: {
    backgroundColor: theme.colors.error,
    paddingVertical: theme.spacing.small,
    paddingHorizontal: theme.spacing.medium,
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    top: theme.responsive.platform === "ios" ? 50 : 20,
    left: theme.spacing.medium,
    right: theme.spacing.medium,
    borderRadius: theme.responsive.scale(8),
    ...theme.shadows.medium,
    zIndex: 9999,
  },
  notConnectedText: {
    ...theme.typography.button,
    color: theme.colors.background,
    fontSize: theme.responsive.responsiveFontSize(14),
  },
})

export default NetworkContainer

================
File: src/components/personalizedStatsMessage.tsx
================
import React, { useState, useEffect, useMemo } from "react"
import { View, ViewStyle, TextStyle } from "react-native"
import { FontAwesome } from "@expo/vector-icons"
import { useAuth } from "../contexts/authContext"
import { gameService } from "../services/gameService"
import { GameHistoryEntry } from "../models/gameHistory"
import { useGameStore } from "../state/gameStore"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"
import { u } from "../styles/utils"

const PersonalizedStatsMessage: React.FC = () => {
  const { player } = useAuth()
  const playerStats = useGameStore((state) => state.playerStats)
  const playerGame = useGameStore((state) => state.playerGame)
  const styles = useStyles(themedStyles)

  const [history, setHistory] = useState<GameHistoryEntry[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const fetchHistory = async () => {
      if (!player) return
      try {
        const fetchedHistory = await gameService.fetchGameHistory(player.id)
        setHistory(fetchedHistory)
      } catch (err) {
        console.error("Failed to fetch game history for stats message:", err)
      } finally {
        setLoading(false)
      }
    }
    fetchHistory()
  }, [player])

  const message = useMemo(() => {
    if (loading || !playerStats || !playerGame) return null

    if (playerGame.correctAnswer) {
      if (
        playerStats.currentStreak > 1 &&
        playerStats.currentStreak === playerStats.maxStreak
      ) {
        return {
          text: `New high streak: ${playerStats.currentStreak} wins in a row! `,
          icon: "rocket",
        }
      }
      if (playerStats.currentStreak >= 3) {
        return {
          text: `You're on a ${playerStats.currentStreak}-day winning streak!`,
          icon: "fire",
        }
      }
      if (playerGame.guesses.length === 1) {
        return {
          text: "A perfect score! Guessed on the first try!",
          icon: "star",
        }
      }
    }

    if (!playerGame.correctAnswer && playerStats.currentStreak > 3) {
      return {
        text: `You had an amazing ${playerStats.currentStreak}-day streak. New one starts tomorrow!`,
        icon: "calendar-check-o",
      }
    }

    if (history.length > 5) {
      const recentWins = history.slice(0, 7).filter((h) => h.wasCorrect).length
      const winRate = Math.round((recentWins / 7) * 100)
      return {
        text: `Your win rate over the last 7 days is ${winRate}%.`,
        icon: "line-chart",
      }
    }

    return { text: "Come back tomorrow for another movie!", icon: "film" }
  }, [playerStats, playerGame, history, loading])

  if (!message) return null

  return (
    <View style={styles.container}>
      <FontAwesome
        name={message.icon as any}
        size={styles.icon.fontSize}
        color={styles.icon.color}
      />
      <Typography style={styles.text}>{message.text}</Typography>
    </View>
  )
}

interface MessageStyles {
  container: ViewStyle
  icon: TextStyle
  text: TextStyle
}

const themedStyles = (theme: Theme): MessageStyles => ({
  container: {
    ...u.flexRow,
    ...u.alignCenter,
    ...u.justifyCenter,
    paddingHorizontal: theme.spacing.medium,
    paddingVertical: theme.spacing.small,
    marginTop: theme.spacing.medium,
  },
  icon: {
    fontSize: theme.responsive.scale(16),
    color: theme.colors.tertiary,
  },
  text: {
    ...theme.typography.caption,
    color: theme.colors.tertiary,
    fontFamily: "Arvo-Bold",
    marginLeft: theme.spacing.small,
    textAlign: "center",
  },
})

export default PersonalizedStatsMessage

================
File: src/components/picker.tsx
================
import React, {
  FC,
  memo,
  useCallback,
  useEffect,
  useRef,
  useState,
} from "react"
import { View, Platform, UIManager } from "react-native"
import { ListRenderItemInfo } from "@shopify/flash-list"
import {
  useAnimatedStyle,
  useSharedValue,
  withRepeat,
  withSequence,
  withTiming,
} from "react-native-reanimated"
import { search } from "fast-fuzzy"
import { BasicTriviaItem, TriviaItem } from "../models/trivia"
import { PickerUI } from "./pickerUI"
import PickerSkeleton from "./pickerSkeleton"
import PickerItem from "./pickerItem"
import { hapticsService } from "../utils/hapticsService"
import { useGameStore } from "../state/gameStore"
import TutorialTooltip from "./tutorialTooltip"
import { useShallow } from "zustand/react/shallow"
import { normalizeSearchString } from "../utils/stringUtils"
import { GAME_MODE_CONFIG } from "../config/difficulty"

if (
  Platform.OS === "android" &&
  UIManager.setLayoutAnimationEnabledExperimental
) {
  UIManager.setLayoutAnimationEnabledExperimental(true)
}

const PickerContainer: FC = memo(() => {
  const {
    isInteractionsDisabled,
    basicItems,
    fullItems,
    makeGuess,
    loading,
    tutorialState,
    dismissGuessInputTip,
    dismissResultsTip,
    gameMode,
  } = useGameStore(
    useShallow((state) => ({
      isInteractionsDisabled: state.isInteractionsDisabled,
      basicItems: state.basicItems,
      fullItems: state.fullItems,
      makeGuess: state.makeGuess,
      loading: state.loading,
      tutorialState: state.tutorialState,
      dismissGuessInputTip: state.dismissGuessInputTip,
      dismissResultsTip: state.dismissResultsTip,
      gameMode: state.gameMode,
    }))
  )

  const [query, setQuery] = useState("")
  const [results, setResults] = useState<readonly BasicTriviaItem[]>([])
  const [isSearching, setIsSearching] = useState(false)
  const [expandedItemId, setExpandedItemId] = useState<number | string | null>(
    null
  )
  const [detailedItem, setDetailedItem] = useState<TriviaItem | null>(null)

  const searchTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const shakeAnimation = useSharedValue(0)

  const triggerShake = useCallback(() => {
    shakeAnimation.value = withSequence(
      withTiming(-10, { duration: 50 }),
      withRepeat(withTiming(10, { duration: 100 }), 3, true),
      withTiming(0, { duration: 50 })
    )
  }, [shakeAnimation])

  const filterItems = useCallback(
    (searchTerm: string): BasicTriviaItem[] => {
      const trimmedTerm = searchTerm.trim()
      if (trimmedTerm.length < 2) return []

      const normalizedSearchTerm = normalizeSearchString(trimmedTerm)

      return search(normalizedSearchTerm, [...basicItems], {
        keySelector: (item) => normalizeSearchString(item.title),
        threshold: 0.8,
      }) as BasicTriviaItem[]
    },
    [basicItems]
  )

  const handleInputChange = useCallback(
    (text: string) => {
      if (isInteractionsDisabled) return

      setQuery(text)
      setExpandedItemId(null)
      setDetailedItem(null)

      if (searchTimeoutRef.current) {
        clearTimeout(searchTimeoutRef.current)
      }

      const trimmedText = text.trim()
      if (trimmedText.length < 2) {
        setResults([])
        setIsSearching(false)
        return
      }

      setIsSearching(true)

      searchTimeoutRef.current = setTimeout(() => {
        const filtered = filterItems(trimmedText)

        if (filtered.length > 0) {
          hapticsService.light()
        } else if (trimmedText.length > 2) {
          triggerShake()
        }

        setResults(filtered)
        setIsSearching(false)
      }, 300)
    },
    [isInteractionsDisabled, filterItems, triggerShake]
  )

  useEffect(() => {
    return () => {
      if (searchTimeoutRef.current) {
        clearTimeout(searchTimeoutRef.current)
      }
    }
  }, [])

  const animatedInputStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: shakeAnimation.value }],
  }))

  const handleLongPressItem = useCallback(
    (item: BasicTriviaItem) => {
      hapticsService.medium()
      const newId = expandedItemId === item.id ? null : item.id
      setExpandedItemId(newId)

      if (newId) {
        const fullItem = fullItems.find((m) => m.id === newId)
        setDetailedItem(fullItem || null)
      } else {
        setDetailedItem(null)
      }
    },
    [expandedItemId, fullItems]
  )

  const handleSelectItem = useCallback(
    (item: BasicTriviaItem) => {
      setExpandedItemId(null)
      setDetailedItem(null)
      makeGuess(item)
      handleInputChange("")
    },
    [makeGuess, handleInputChange]
  )

  const renderItem = useCallback(
    ({ item }: ListRenderItemInfo<BasicTriviaItem>) => (
      <PickerItem
        item={item}
        detailedItem={detailedItem}
        isDisabled={isInteractionsDisabled}
        isExpanded={expandedItemId === item.id}
        onSelect={handleSelectItem}
        onLongPress={handleLongPressItem}
      />
    ),
    [
      isInteractionsDisabled,
      expandedItemId,
      detailedItem,
      handleSelectItem,
      handleLongPressItem,
    ]
  )

  const showResults = query.length >= 2 || isSearching
  const showResultsTip = results.length > 0 && tutorialState.showResultsTip

  if (loading) {
    return <PickerSkeleton />
  }

  return (
    <View style={{ width: "100%", zIndex: 10 }}>
      <PickerUI
        query={query}
        isSearching={isSearching}
        results={results}
        showResults={showResults}
        animatedInputStyle={animatedInputStyle}
        isInteractionsDisabled={isInteractionsDisabled}
        handleInputChange={handleInputChange}
        renderItem={renderItem}
        placeholder={GAME_MODE_CONFIG[gameMode].searchPlaceholder}
      />
      <TutorialTooltip
        isVisible={tutorialState.showGuessInputTip}
        text="Type here to search for the title you think it is."
        onDismiss={dismissGuessInputTip}
        style={{ top: -75 }}
      />
      <TutorialTooltip
        isVisible={showResultsTip}
        text="Pro Tip: Long-press any result to see a preview before you guess!"
        onDismiss={dismissResultsTip}
        style={{ top: 60 }}
      />
    </View>
  )
})

export default PickerContainer

================
File: src/components/pickerItem.tsx
================
import React, { memo, useEffect } from "react"
import {
  View,
  Text,
  Pressable,
  LayoutAnimation,
  Platform,
  UIManager,
  ViewStyle,
  TextStyle,
  ImageStyle,
} from "react-native"
import { Image } from "expo-image"
import { BasicTriviaItem, TriviaItem } from "../models/trivia"
import { API_CONFIG } from "../config/constants"
import { useStyles, Theme } from "../utils/hooks/useStyles"

if (
  Platform.OS === "android" &&
  UIManager.setLayoutAnimationEnabledExperimental
) {
  UIManager.setLayoutAnimationEnabledExperimental(true)
}

interface ItemProps {
  item: BasicTriviaItem
  detailedItem: TriviaItem | null
  isDisabled: boolean
  isExpanded: boolean
  onSelect: (item: BasicTriviaItem) => void
  onLongPress: (item: BasicTriviaItem) => void
}

const defaultPoster = require("../../assets/movie_default.png")

const PickerItem = memo<ItemProps>(
  ({ item, detailedItem, isDisabled, isExpanded, onSelect, onLongPress }) => {
    const styles = useStyles(themedStyles)

    useEffect(() => {
      if (Platform.OS !== "web") {
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut)
      }
    }, [isExpanded])

    const releaseYear = item.releaseDate
      ? ` (${item.releaseDate.toString().substring(0, 4)})`
      : ""
    const titleWithYear = `${item.title}${releaseYear}`

    const imageSource = item.posterPath
      ? { uri: `${API_CONFIG.TMDB_IMAGE_BASE_URL_W92}${item.posterPath}` }
      : defaultPoster
    const fullImageSource = item.posterPath
      ? { uri: `${API_CONFIG.TMDB_IMAGE_BASE_URL_W500}${item.posterPath}` }
      : defaultPoster

    return (
      <View style={styles.resultItemContainer}>
        <Pressable
          testID={`result-item-${item.title}`}
          accessible
          accessibilityRole="button"
          accessibilityLabel={`Select and guess: ${item.title}. Long press to preview.`}
          onPress={() => onSelect(item)}
          onLongPress={() => onLongPress(item)}
          delayLongPress={200}
          style={({ pressed }) => [
            styles.resultItem,
            pressed && styles.pressedItem,
          ]}
          android_ripple={{ color: styles.pressedItem.backgroundColor }}
          disabled={isDisabled}
        >
          <View style={styles.resultItemContent}>
            <View style={styles.imageWrapper}>
              <Image
                source={imageSource}
                placeholder={defaultPoster}
                style={styles.resultImage}
                contentFit="cover"
              />
            </View>
            <Text
              style={styles.unselected}
              numberOfLines={2}
              ellipsizeMode="tail"
            >
              {titleWithYear}
            </Text>
          </View>

          {isExpanded && detailedItem && (
            <View style={styles.expandedPreview}>
              <View style={styles.expandedImageWrapper}>
                <Image
                  source={fullImageSource}
                  placeholder={defaultPoster}
                  style={styles.expandedImage}
                  contentFit="cover"
                />
              </View>
              <View style={styles.expandedInfo}>
                <Text style={styles.expandedTitle} numberOfLines={3}>
                  {detailedItem.title}
                </Text>
                <Text style={styles.expandedYear}>
                  Release Year:{" "}
                  {new Date(detailedItem.releaseDate).getFullYear()}
                </Text>
                <Text style={styles.expandedHint}>
                  Tap this item to select.
                </Text>
              </View>
            </View>
          )}
        </Pressable>
      </View>
    )
  }
)

interface PickerItemStyles {
  resultItemContainer: ViewStyle
  resultItem: ViewStyle
  pressedItem: ViewStyle
  resultItemContent: ViewStyle
  imageWrapper: ViewStyle
  resultImage: ImageStyle
  unselected: TextStyle
  expandedPreview: ViewStyle
  expandedImageWrapper: ViewStyle
  expandedImage: ImageStyle
  expandedInfo: ViewStyle
  expandedTitle: TextStyle
  expandedYear: TextStyle
  expandedHint: TextStyle
}

const themedStyles = (theme: Theme): PickerItemStyles => ({
  resultItemContainer: {
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.border,
  },
  resultItem: {
    paddingVertical: theme.spacing.small,
    paddingHorizontal: theme.spacing.medium,
    overflow: "hidden",
  },
  pressedItem: {
    backgroundColor: theme.colors.surface,
  },
  resultItemContent: {
    flexDirection: "row",
    alignItems: "center",
  },
  imageWrapper: {
    width: theme.responsive.scale(30),
    height: theme.responsive.scale(45),
    borderRadius: theme.responsive.scale(4),
    marginRight: theme.spacing.medium,
    backgroundColor: theme.colors.surface,
    overflow: "hidden",
  },
  resultImage: {
    width: "100%",
    height: "100%",
  },
  unselected: {
    ...theme.typography.bodyText,
    fontSize: theme.responsive.responsiveFontSize(14),
    flex: 1,
  },
  expandedPreview: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: theme.spacing.medium,
    padding: theme.spacing.small,
    backgroundColor: theme.colors.surface,
    borderRadius: theme.responsive.scale(8),
  },
  expandedImageWrapper: {
    width: theme.responsive.scale(80),
    height: theme.responsive.scale(120),
    borderRadius: theme.responsive.scale(6),
    marginRight: theme.spacing.medium,
    backgroundColor: theme.colors.surface,
    overflow: "hidden",
  },
  expandedImage: {
    width: "100%",
    height: "100%",
  },
  expandedInfo: {
    flex: 1,
    height: "100%",
    justifyContent: "center",
  },
  expandedTitle: {
    ...theme.typography.bodyText,
    color: theme.colors.textPrimary,
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(16),
    marginBottom: theme.spacing.extraSmall,
  },
  expandedYear: {
    ...theme.typography.caption,
    color: theme.colors.textSecondary,
    marginBottom: theme.spacing.small,
  },
  expandedHint: {
    ...theme.typography.caption,
    color: theme.colors.primary,
    fontFamily: "Arvo-Italic",
  },
})

export default PickerItem

================
File: src/components/pickerSkeleton.tsx
================
import React from "react"
import { View, ViewStyle } from "react-native"
import Animated from "react-native-reanimated"
import { useSkeletonAnimation } from "../utils/hooks/useSkeletonAnimation"
import { useStyles, Theme } from "../utils/hooks/useStyles"

const PickerSkeleton = () => {
  const styles = useStyles(themedStyles)
  const animatedStyle = useSkeletonAnimation()

  return (
    <Animated.View style={[styles.container, animatedStyle]}>
      <View style={styles.inputContainer}>
        <View style={styles.input} />
      </View>
    </Animated.View>
  )
}

interface SkeletonStyles {
  container: ViewStyle
  inputContainer: ViewStyle
  input: ViewStyle
}

const themedStyles = (theme: Theme): SkeletonStyles => ({
  container: {
    width: "100%",
    marginTop: theme.spacing.medium,
    marginBottom: theme.spacing.medium,
  },
  inputContainer: {
    flexDirection: "row",
    position: "relative",
    width: "100%",
  },
  input: {
    flex: 1,
    height: 50, // Approximate height of the TextInput
    borderRadius: theme.responsive.scale(8),
    backgroundColor: theme.colors.surface,
  },
})

export default PickerSkeleton

================
File: src/components/pickerUI.tsx
================
import React, { memo } from "react"
import {
  ActivityIndicator,
  Text,
  TextInput,
  View,
  StyleProp,
  ViewStyle,
  TextStyle,
} from "react-native"
import { FlashList, ListRenderItem } from "@shopify/flash-list"
import Animated from "react-native-reanimated"
import { BasicTriviaItem } from "../models/trivia"
import { useStyles, Theme } from "../utils/hooks/useStyles"

interface PickerUIProps {
  query: string
  isSearching: boolean
  results: readonly BasicTriviaItem[]
  showResults: boolean
  animatedInputStyle: StyleProp<ViewStyle>
  isInteractionsDisabled: boolean
  handleInputChange: (text: string) => void
  renderItem: ListRenderItem<BasicTriviaItem>
  placeholder: string
}

export const PickerUI: React.FC<PickerUIProps> = memo(
  ({
    query,
    isSearching,
    results,
    showResults,
    animatedInputStyle,
    isInteractionsDisabled,
    handleInputChange,
    renderItem,
    placeholder,
  }) => {
    const styles = useStyles(themedStyles)

    return (
      <View style={styles.container}>
        <Animated.View style={animatedInputStyle}>
          <View style={styles.inputContainer}>
            <TextInput
              testID="search-input"
              accessible
              accessibilityRole="search"
              aria-label="Search for a title to make a guess"
              maxLength={100}
              onChangeText={handleInputChange}
              placeholder={placeholder}
              placeholderTextColor={styles.input.placeholderTextColor}
              style={[
                styles.input,
                isInteractionsDisabled && styles.disabledInput,
              ]}
              value={query}
              editable={!isInteractionsDisabled}
            />
            {isSearching && (
              <ActivityIndicator
                size="small"
                color={styles.activityIndicator.color}
                style={styles.activityIndicator}
              />
            )}
          </View>
        </Animated.View>

        {showResults && (
          <View style={styles.resultsContainer}>
            {isSearching ? (
              <Text style={styles.noResultsText}>Searching...</Text>
            ) : results.length > 0 ? (
              <>
                <FlashList
                  data={results}
                  renderItem={renderItem}
                  keyExtractor={(item) => item.id.toString()}
                  estimatedItemSize={62}
                  keyboardShouldPersistTaps="handled"
                />
                <View style={styles.previewHintContainer}>
                  <Text style={styles.previewHintText}>
                     Hold any result to preview
                  </Text>
                </View>
              </>
            ) : query.length >= 2 ? (
              <Text style={styles.noResultsText}>
                No titles found for "{query}"
              </Text>
            ) : null}
          </View>
        )}
      </View>
    )
  }
)

interface PickerUIStyles {
  container: ViewStyle
  inputContainer: ViewStyle
  input: TextStyle & { placeholderTextColor: string }
  disabledInput: TextStyle
  activityIndicator: ViewStyle & { color: string }
  resultsContainer: ViewStyle
  noResultsText: TextStyle
  previewHintContainer: ViewStyle
  previewHintText: TextStyle
}

const themedStyles = (theme: Theme): PickerUIStyles => ({
  container: {
    width: "100%",
    marginTop: theme.spacing.medium,
    marginBottom: theme.spacing.medium,
  },
  inputContainer: {
    flexDirection: "row",
    position: "relative",
    width: "100%",
  },
  input: {
    flex: 1,
    borderColor: theme.colors.border,
    borderRadius: theme.responsive.scale(8),
    borderWidth: 2,
    backgroundColor: theme.colors.surface,
    color: theme.colors.textPrimary,
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(14),
    paddingHorizontal: theme.spacing.medium,
    paddingVertical: theme.responsive.scale(12),
    textAlign: "left",
    paddingRight: theme.responsive.scale(40),
    placeholderTextColor: theme.colors.textSecondary,
  },
  disabledInput: {
    backgroundColor: theme.colors.border,
  },
  activityIndicator: {
    position: "absolute",
    right: theme.spacing.small,
    top: theme.responsive.scale(12),
    color: theme.colors.primary,
  },
  resultsContainer: {
    position: "absolute",
    top: theme.responsive.scale(55),
    left: 0,
    right: 0,
    maxHeight: theme.responsive.scale(200),
    backgroundColor: theme.colors.backgroundLight,
    borderColor: theme.colors.border,
    borderWidth: 1,
    borderRadius: theme.responsive.scale(8),
    ...theme.shadows.medium,
    zIndex: 10,
  },
  noResultsText: {
    ...theme.typography.bodyText,
    fontSize: theme.responsive.responsiveFontSize(14),
    padding: theme.spacing.medium,
    textAlign: "center",
  },
  previewHintContainer: {
    position: "absolute",
    bottom: theme.spacing.small,
    right: theme.spacing.small,
    backgroundColor: theme.colors.tertiary,
    borderRadius: theme.responsive.scale(12),
    paddingVertical: theme.responsive.scale(4),
    paddingHorizontal: theme.spacing.small,
    zIndex: 1,
    elevation: 1,
  },
  previewHintText: {
    fontFamily: "Arvo-Italic",
    fontSize: theme.responsive.responsiveFontSize(11),
    color: theme.colors.background,
  },
})

================
File: src/components/playerStats.tsx
================
import React, { memo } from "react"
import { View, TextStyle, ViewStyle } from "react-native"
import Player from "../models/player"
import PlayerStats from "../models/playerStats"
import WinChart from "./winChart"
import StatItem from "./statItem"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { u } from "../styles/utils"
import { Typography } from "./ui/typography"

export interface PlayerStatsContainerProps {
  player: Player | null
  playerStats: PlayerStats | null
}

const PlayerStatsContainer = memo(
  ({ player, playerStats }: PlayerStatsContainerProps) => {
    const styles = useStyles(themedStyles)

    if (!player || !playerStats) {
      return (
        <View style={[styles.container, u.justifyCenter, u.alignCenter]}>
          <Typography>No statistics available.</Typography>
        </View>
      )
    }

    return (
      <View
        style={styles.container}
        key={player.id}
        testID="player-stats-container" 
      >
        <WinChart wins={playerStats.wins} />
        <View style={styles.statsContainer}>
          <StatItem
            label="All-Time Score"
            value={playerStats.allTimeScore.toLocaleString()}
            valueStyle={styles.scoreText}
          />
          <StatItem label="Games Played" value={playerStats.games} />
          <StatItem
            label="Current Streak"
            value={playerStats.currentStreak}
            valueStyle={styles.streakText}
          />
          <StatItem
            label="Max Streak"
            value={playerStats.maxStreak}
            valueStyle={styles.streakText}
          />
          <StatItem
            label="Hints Available"
            value={playerStats.hintsAvailable}
          />
        </View>
      </View>
    )
  }
)

interface PlayerStatsStyles {
  container: ViewStyle
  statsContainer: ViewStyle
  scoreText: TextStyle
  streakText: TextStyle
}

const themedStyles = (theme: Theme): PlayerStatsStyles => ({
  container: {
    flex: 1,
    padding: theme.spacing.small,
    width: "100%",
  },
  statsContainer: {
    paddingTop: theme.spacing.medium,
    width: "100%",
  },
  scoreText: {
    color: theme.colors.tertiary,
  },
  streakText: {
    color: theme.colors.primary,
  },
})

export default PlayerStatsContainer

================
File: src/components/profileSection.tsx
================
import React from "react"
import { View, ViewStyle, TextStyle } from "react-native"
import { FontAwesome } from "@expo/vector-icons"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Card } from "./ui/card"
import { Typography } from "./ui/typography"

interface ProfileSectionProps {
  title: string
  icon: keyof typeof FontAwesome.glyphMap
  children: React.ReactNode
}

const ProfileSection: React.FC<ProfileSectionProps> = ({
  title,
  icon,
  children,
}) => {
  const styles = useStyles(themedStyles)

  return (
    <Card style={styles.card}>
      <View style={styles.header}>
        <FontAwesome
          name={icon}
          size={styles.icon.fontSize}
          color={styles.icon.color}
        />
        <Typography variant="h2" style={styles.title}>
          {title}
        </Typography>
      </View>
      <View style={styles.content}>{children}</View>
    </Card>
  )
}

interface ProfileSectionStyles {
  card: ViewStyle
  header: ViewStyle
  icon: TextStyle
  title: TextStyle
  content: ViewStyle
}

const themedStyles = (theme: Theme): ProfileSectionStyles => ({
  card: {
    width: "100%",
    maxWidth: theme.responsive.scale(500),
    marginBottom: theme.spacing.large,
    overflow: "hidden", // Ensures children conform to border radius
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    padding: theme.spacing.medium,
    backgroundColor:
      theme.colorScheme === "dark"
        ? "rgba(255,255,255,0.05)"
        : "rgba(0,0,0,0.02)",
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.border,
  },
  icon: {
    fontSize: theme.responsive.responsiveFontSize(16),
    color: theme.colors.primary,
  },
  title: {
    fontSize: theme.responsive.responsiveFontSize(18),
    color: theme.colors.primary,
    marginLeft: theme.spacing.small,
  },
  content: {
    padding: theme.spacing.medium,
  },
})

export default ProfileSection

================
File: src/components/revealSequence.tsx
================
import React, { useEffect } from "react"
import { StyleSheet, View } from "react-native"
import { Image } from "expo-image"
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withDelay,
  interpolate,
  runOnJS,
  Easing,
} from "react-native-reanimated"
import { useGameStore } from "../state/gameStore"
import { API_CONFIG } from "../config/constants"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { ViewStyle, ImageStyle, TextStyle } from "react-native"

const defaultItemImage = require("../../assets/movie_default.png")

interface RevealSequenceProps {
  onAnimationComplete: () => void
}

const RevealSequence: React.FC<RevealSequenceProps> = ({
  onAnimationComplete,
}) => {
  const triviaItem = useGameStore((state) => state.playerGame.triviaItem)
  const styles = useStyles(themedStyles)

  const containerOpacity = useSharedValue(0)
  const posterRotate = useSharedValue(0)
  const titleOpacity = useSharedValue(0)

  const handleComplete = () => {
    setTimeout(() => {
      onAnimationComplete()
    }, 1000)
  }

  useEffect(() => {
    containerOpacity.value = withTiming(1, { duration: 300 })
    posterRotate.value = withDelay(
      300,
      withTiming(1, { duration: 800, easing: Easing.out(Easing.poly(4)) })
    )
    titleOpacity.value = withDelay(
      1200,
      withTiming(1, { duration: 500 }, (finished) => {
        if (finished) {
          runOnJS(handleComplete)()
        }
      })
    )
  }, [containerOpacity, posterRotate, titleOpacity, onAnimationComplete])

  const containerStyle = useAnimatedStyle(() => ({
    opacity: containerOpacity.value,
  }))

  const posterStyle = useAnimatedStyle(() => {
    const rotateY = interpolate(posterRotate.value, [0, 1], [180, 360])
    return {
      transform: [{ perspective: 1000 }, { rotateY: `${rotateY}deg` }],
    }
  })

  const titleStyle = useAnimatedStyle(() => ({
    opacity: titleOpacity.value,
    transform: [
      { translateY: interpolate(titleOpacity.value, [0, 1], [20, 0]) },
    ],
  }))

  const imageSource = triviaItem?.posterPath
    ? { uri: `${API_CONFIG.TMDB_IMAGE_BASE_URL_W500}${triviaItem.posterPath}` }
    : defaultItemImage

  const title = triviaItem?.title || "Correct!"

  return (
    <Animated.View style={[styles.container, containerStyle]}>
      <Animated.View style={posterStyle}>
        <View style={styles.posterShadowWrapper}>
          <Image
            source={imageSource}
            style={styles.poster}
            contentFit="cover"
          />
        </View>
      </Animated.View>
      <Animated.Text style={[styles.title, titleStyle]}>{title}</Animated.Text>
    </Animated.View>
  )
}

interface RevealSequenceStyles {
  container: ViewStyle
  posterShadowWrapper: ViewStyle
  poster: ImageStyle
  title: TextStyle
}

const themedStyles = (theme: Theme): RevealSequenceStyles => ({
  container: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0,0,0,0.85)",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 100,
  },
  posterShadowWrapper: {
    width: theme.responsive.scale(180),
    height: theme.responsive.scale(270),
    borderRadius: theme.responsive.scale(10),
    backgroundColor: theme.colors.background,
    ...theme.shadows.medium,
  },
  poster: {
    width: "100%",
    height: "100%",
    borderRadius: theme.responsive.scale(10),
  },
  title: {
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(24),
    color: theme.colors.primary,
    textAlign: "center",
    marginTop: theme.spacing.large,
    paddingHorizontal: theme.spacing.small,
    textShadowColor: "rgba(0, 0, 0, 0.75)",
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
})

export default RevealSequence

================
File: src/components/statItem.tsx
================
import React from "react"
import { View, StyleProp, TextStyle, ViewStyle } from "react-native"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"
import { u } from "../styles/utils"

interface StatItemProps {
  label: string
  value: string | number
  valueStyle?: StyleProp<TextStyle>
}

const StatItem: React.FC<StatItemProps> = ({ label, value, valueStyle }) => {
  const styles = useStyles(themedStyles)

  return (
    <View
      style={
        [
          u.flexRow,
          u.justifyBetween,
          u.alignCenter,
          styles.container,
        ] as ViewStyle[]
      }
    >
      <Typography style={styles.label}>{label}</Typography>
      <Typography style={[styles.value, valueStyle]}>{value}</Typography>
    </View>
  )
}

interface StatItemStyles {
  container: ViewStyle
  label: TextStyle
  value: TextStyle
}

const themedStyles = (theme: Theme): StatItemStyles => ({
  container: {
    paddingVertical: theme.spacing.extraSmall,
    width: "100%",
  },
  label: {
    ...theme.typography.bodyText,
    fontFamily: "Arvo-Bold",
    color: theme.colors.textSecondary,
    fontSize: theme.responsive.responsiveFontSize(16),
  },
  value: {
    ...theme.typography.bodyText,
    fontFamily: "Arvo-Bold",
    color: theme.colors.quinary,
    fontSize: theme.responsive.responsiveFontSize(16),
  },
})

export default StatItem

================
File: src/components/themeSelector.tsx
================
import React from "react"
import { View, Pressable, ViewStyle, TextStyle } from "react-native"
import { useTheme, Theme as ThemeType } from "../contexts/themeContext"
import { FontAwesome } from "@expo/vector-icons"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"

const ThemeSelector = () => {
  const { theme, setTheme } = useTheme()
  const styles = useStyles(themedStyles)

  const options: { label: string; value: ThemeType }[] = [
    { label: "Light", value: "light" },
    { label: "Dark", value: "dark" },
    { label: "System", value: "system" },
  ]

  return (
    <View style={styles.container}>
      <View style={styles.labelContainer}>
        <FontAwesome
          name="paint-brush"
          size={styles.icon.fontSize}
          color={styles.icon.color}
        />
        <Typography style={styles.title}>Theme</Typography>
      </View>
      <View style={styles.optionsContainer}>
        {options.map((option) => (
          <Pressable
            key={option.value}
            onPress={() => setTheme(option.value)}
            style={[
              styles.option,
              theme === option.value && styles.selectedOption,
            ]}
            accessibilityRole="button"
            accessibilityState={{ selected: theme === option.value }}
            accessibilityLabel={`Set theme to ${option.label}`}
          >
            <Typography
              style={[
                styles.optionText,
                theme === option.value && styles.selectedOptionText,
              ]}
            >
              {option.label}
            </Typography>
          </Pressable>
        ))}
      </View>
    </View>
  )
}

interface ThemeSelectorStyles {
  container: ViewStyle
  labelContainer: ViewStyle
  icon: TextStyle
  title: TextStyle
  optionsContainer: ViewStyle
  option: ViewStyle
  selectedOption: ViewStyle
  optionText: TextStyle
  selectedOptionText: TextStyle
}

const themedStyles = (theme: Theme): ThemeSelectorStyles => ({
  container: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    width: "100%",
  },
  labelContainer: {
    flexDirection: "row",
    alignItems: "center",
  },
  icon: {
    fontSize: theme.responsive.responsiveFontSize(16),
    color: theme.colors.textSecondary,
  },
  title: {
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(16),
    color: theme.colors.textPrimary,
    marginLeft: theme.spacing.small,
  },
  optionsContainer: {
    flexDirection: "row",
    backgroundColor: theme.colors.background,
    borderRadius: theme.responsive.scale(8),
    padding: theme.spacing.extraSmall,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  option: {
    paddingVertical: theme.spacing.small,
    paddingHorizontal: theme.spacing.small,
    borderRadius: theme.responsive.scale(6),
  },
  selectedOption: {
    backgroundColor: theme.colors.primary,
  },
  optionText: {
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(14),
    color: theme.colors.textPrimary,
  },
  selectedOptionText: {
    fontFamily: "Arvo-Bold",
    color: theme.colors.background,
  },
})

export default ThemeSelector

================
File: src/components/titleHeader.tsx
================
import React, { memo } from "react"
import { View, ViewStyle, TextStyle } from "react-native"
import { Typography } from "./ui/typography"
import { useStyles, Theme } from "../utils/hooks/useStyles"

interface TitleHeaderProps {
  title: string
}

const TitleHeader: React.FC<TitleHeaderProps> = memo(({ title }) => {
  const styles = useStyles(themedStyles)

  return (
    <View style={styles.container}>
      <Typography variant="h2" style={styles.header}>
        {title}
      </Typography>
    </View>
  )
})

interface TitleHeaderStyles {
  container: ViewStyle
  header: TextStyle
}

const themedStyles = (theme: Theme): TitleHeaderStyles => ({
  container: {
    justifyContent: "center",
    alignItems: "flex-start",
    paddingVertical: theme.responsive.scale(4),
    flex: 1,
  },
  header: {
    fontSize: theme.responsive.responsiveFontSize(18),
    color: theme.colors.primary,
    textAlign: "left",
  },
})

export default TitleHeader

================
File: src/components/tutorialTooltip.tsx
================
import React, { useEffect } from "react"
import { View, ViewStyle, TextStyle } from "react-native"
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  Easing,
  interpolate,
} from "react-native-reanimated"
import { hapticsService } from "../utils/hapticsService"
import { useStyles, Theme } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"
import { Button } from "./ui/button"

interface TutorialTooltipProps {
  isVisible: boolean
  text: string
  onDismiss: () => void
  style?: object
}

const TutorialTooltip: React.FC<TutorialTooltipProps> = ({
  isVisible,
  text,
  onDismiss,
  style,
}) => {
  const styles = useStyles(themedStyles)
  const animation = useSharedValue(0)

  useEffect(() => {
    animation.value = withTiming(isVisible ? 1 : 0, {
      duration: 300,
      easing: Easing.out(Easing.ease),
    })
  }, [isVisible, animation])

  const animatedContainerStyle = useAnimatedStyle(() => ({
    opacity: animation.value,
    transform: [{ translateY: interpolate(animation.value, [0, 1], [10, 0]) }],
  }))

  const handleDismiss = () => {
    hapticsService.medium()
    onDismiss()
  }

  if (!isVisible) return null

  return (
    <Animated.View style={[styles.container, animatedContainerStyle, style]}>
      <View style={styles.tooltipBox}>
        <Typography style={styles.text}>{text}</Typography>
        <Button
          title="Got it"
          onPress={handleDismiss}
          size="sm"
          variant="secondary"
          style={{alignSelf: 'center', backgroundColor: 'white'}} 
        />
      </View>
      <View style={styles.pointer} />
    </Animated.View>
  )
}

interface TutorialTooltipStyles {
  container: ViewStyle
  tooltipBox: ViewStyle
  text: TextStyle
  pointer: ViewStyle
}

const themedStyles = (theme: Theme): TutorialTooltipStyles => ({
  container: {
    position: "absolute",
    zIndex: 100,
    alignItems: "center",
    width: "90%",
    alignSelf: "center",
    ...theme.shadows.medium,
  },
  tooltipBox: {
    backgroundColor: theme.colors.tertiary,
    borderRadius: theme.responsive.scale(8),
    padding: theme.spacing.medium,
    width: "100%",
  },
  text: {
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(15),
    color: theme.colors.background,
    lineHeight: theme.responsive.responsiveFontSize(21),
    textAlign: "center",
    marginBottom: theme.spacing.medium,
  },
  pointer: {
    width: 0,
    height: 0,
    backgroundColor: "transparent",
    borderStyle: "solid",
    borderLeftWidth: theme.responsive.scale(10),
    borderRightWidth: theme.responsive.scale(10),
    borderBottomWidth: theme.responsive.scale(10),
    borderLeftColor: "transparent",
    borderRightColor: "transparent",
    borderBottomColor: theme.colors.tertiary,
    transform: [{ rotate: "180deg" }],
  },
})

export default TutorialTooltip

================
File: src/components/utils.ts
================
import { StyleSheet } from "react-native"
import { spacing } from "../styles/global"

/**
 * Utility Stylesheet (Atomic/Tailwind-inspired)
 * Provides a set of common, reusable styles for layout and spacing to reduce
 * the need for creating trivial named styles in component-specific stylesheets.
 *
 * Naming convention:
 * - `p` for padding, `m` for margin.
 * - `t, b, l, r` for top, bottom, left, right.
 * - `x, y` for horizontal, vertical.
 * - `sm, md, lg, xl` for small, medium, large, extra-large sizes from spacing tokens.
 *
 * Example: `mtMd` = margin-top: medium
 */
export const u = StyleSheet.create({
  // Flexbox
  flex: { flex: 1 },
  flexRow: { flexDirection: "row" },
  flexCol: { flexDirection: "column" },
  alignCenter: { alignItems: "center" },
  justifyCenter: { justifyContent: "center" },
  justifyBetween: { justifyContent: "space-between" },

  // Sizing
  wFull: { width: "100%" },
  hFull: { height: "100%" },

  // Spacing - Margins
  mSm: { margin: spacing.small },
  mMd: { margin: spacing.medium },
  mLg: { margin: spacing.large },
  mxSm: { marginHorizontal: spacing.small },
  mxMd: { marginHorizontal: spacing.medium },
  mySm: { marginVertical: spacing.small },
  myMd: { marginVertical: spacing.medium },
  mtSm: { marginTop: spacing.small },
  mtMd: { marginTop: spacing.medium },
  mbSm: { marginBottom: spacing.small },
  mbMd: { marginBottom: spacing.medium },

  // Spacing - Paddings
  pSm: { padding: spacing.small },
  pMd: { padding: spacing.medium },
  pxSm: { paddingHorizontal: spacing.small },
  pxMd: { paddingHorizontal: spacing.medium },
  pySm: { paddingVertical: spacing.small },
  pyMd: { paddingVertical: spacing.medium },

  // Text
  textCenter: { textAlign: "center" },
  textRight: { textAlign: "right" },
  textLeft: { textAlign: "left" },
})

================
File: src/components/victory-charts.ts
================
export * from "victory-native"

================
File: src/components/victory-charts.web.ts
================
export * from "victory"

================
File: src/components/whereToWatch.tsx
================
import React from "react"
import { View, ViewStyle, TextStyle } from "react-native"
import { FontAwesome5 } from "@expo/vector-icons"
import { useStyles, Theme, useThemeTokens } from "../utils/hooks/useStyles"
import { Typography } from "./ui/typography"

const WhereToWatch: React.FC = () => {
  const styles = useStyles(themedStyles)
  const theme = useThemeTokens()

  const mockProviders = [
    { name: "Netflix", icon: "netflix", color: "#E50914" },
    { name: "Prime Video", icon: "amazon", color: "#00A8E1" },
    { name: "Disney+", icon: "plus", color: "#113CCF" },
    {
      name: "Rent",
      icon: "ticket-alt",
      color: theme.colors.tertiary,
    },
  ]

  return (
    <View style={styles.container}>
      <Typography style={styles.title}>Where to Watch</Typography>
      <View style={styles.providersContainer}>
        {mockProviders.map((provider) => (
          <View key={provider.name} style={styles.provider}>
            <FontAwesome5
              name={provider.icon as any}
              size={24}
              color={provider.color}
            />
            <Typography style={styles.providerText}>{provider.name}</Typography>
          </View>
        ))}
      </View>
      <Typography style={styles.disclaimer}>
        *Streaming availability is illustrative and may change.
      </Typography>
    </View>
  )
}

interface WhereToWatchStyles {
  container: ViewStyle
  title: TextStyle
  providersContainer: ViewStyle
  provider: ViewStyle
  providerText: TextStyle
  disclaimer: TextStyle
}

const themedStyles = (theme: Theme): WhereToWatchStyles => ({
  container: {
    width: "100%",
    padding: theme.spacing.medium,
    marginTop: theme.spacing.large,
    backgroundColor: theme.colors.background,
    borderRadius: theme.responsive.scale(8),
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  title: {
    fontFamily: "Arvo-Bold",
    fontSize: theme.responsive.responsiveFontSize(16),
    color: theme.colors.textPrimary,
    textAlign: "center",
    marginBottom: theme.spacing.medium,
  },
  providersContainer: {
    flexDirection: "row",
    justifyContent: "space-around",
    alignItems: "center",
    marginBottom: theme.spacing.small,
  },
  provider: {
    alignItems: "center",
  },
  providerText: {
    fontFamily: "Arvo-Regular",
    fontSize: theme.responsive.responsiveFontSize(10),
    color: theme.colors.textSecondary,
    marginTop: theme.spacing.extraSmall,
  },
  disclaimer: {
    fontFamily: "Arvo-Italic",
    fontSize: theme.responsive.responsiveFontSize(10),
    color: theme.colors.textDisabled,
    textAlign: "center",
    marginTop: theme.spacing.small,
  },
})

export default WhereToWatch

================
File: src/components/winChart.tsx
================
import React, { memo, useMemo } from "react"
import { View, ViewStyle, TextStyle } from "react-native"
import { Typography } from "./ui/typography"
import { useStyles, Theme, useThemeTokens } from "../utils/hooks/useStyles"
const { VictoryBar, VictoryChart, VictoryAxis } = require("victory-native")

export interface WinChartProps {
  wins: number[]
}

const WinChart = memo(({ wins }: WinChartProps) => {
  const styles = useStyles(themedStyles)
  const theme = useThemeTokens()
  const { colors, responsive } = theme
  const totalWins = wins.reduce((a, b) => a + b, 0)

  const accessibilityLabel = useMemo(() => {
    if (totalWins === 0) {
      return "Win distribution chart is empty. No wins recorded yet."
    }
    const descriptions = wins
      .map((count, index) =>
        count > 0
          ? `${count} ${count === 1 ? "win" : "wins"} with ${index + 1} ${
              index === 0 ? "guess" : "guesses"
            }`
          : ""
      )
      .filter(Boolean)
      .join(". ")
    return `Bar chart showing win distribution. ${descriptions}.`
  }, [wins, totalWins])

  if (totalWins === 0) {
    return (
      <View style={styles.emptyContainer}>
        <Typography style={styles.emptyText}>
          Your win distribution will appear here after your first win!
        </Typography>
      </View>
    )
  }

  const chartData = wins.map((winCount, index) => ({
    x: index + 1,
    y: winCount,
  }))

  if (!VictoryBar || !VictoryChart || !VictoryAxis) {
    console.warn("Victory Native components failed to load. Skipping chart.")
    return null
  }

  return (
    <View style={styles.container} accessibilityLabel={accessibilityLabel}>
      <VictoryChart
        domainPadding={{ x: responsive.scale(25) }}
        height={responsive.scale(220)}
        padding={{
          top: responsive.scale(30),
          bottom: responsive.scale(30),
          left: responsive.scale(50),
          right: responsive.scale(30),
        }}
      >
        <VictoryAxis
          style={{
            axis: { stroke: "transparent" },
            tickLabels: { fill: "transparent" },
            grid: { stroke: "transparent" },
          }}
        />
        <VictoryBar
          data={chartData}
          barWidth={responsive.scale(20)}
          style={{
            data: { fill: colors.primary, borderRadius: responsive.scale(4) },
            labels: {
              fill: colors.textSecondary,
              fontFamily: "Arvo-Bold",
              fontSize: responsive.responsiveFontSize(12),
            },
          }}
          labels={({ datum }: { datum: any }) =>
            datum.y > 0 ? datum.y.toString() : ""
          }
        />
        <VictoryAxis
          dependentAxis
          style={{
            axis: { stroke: "transparent" },
            tickLabels: { fill: "transparent" },
            grid: { stroke: colors.border, strokeDasharray: "4, 8" },
          }}
        />
        <VictoryAxis
          style={{
            axis: { stroke: colors.border },
            tickLabels: {
              fill: colors.textSecondary,
              fontFamily: "Arvo-Regular",
              fontSize: responsive.responsiveFontSize(10),
            },
            grid: { stroke: "transparent" },
          }}
        />
      </VictoryChart>
    </View>
  )
})

interface WinChartStyles {
  container: ViewStyle
  emptyContainer: ViewStyle
  emptyText: TextStyle
}

const themedStyles = (theme: Theme): WinChartStyles => ({
  container: {
    alignItems: "center",
    alignSelf: "center",
    flex: 1,
    flexDirection: "column",
    padding: theme.responsive.scale(15),
    width: "100%",
    backgroundColor: theme.colors.background,
  },
  emptyContainer: {
    padding: theme.spacing.large,
    alignItems: "center",
    justifyContent: "center",
  },
  emptyText: {
    fontFamily: "Arvo-Italic",
    textAlign: "center",
    color: theme.colors.textSecondary,
  },
})

export default WinChart

================
File: src/config/constants.ts
================
export const API_CONFIG = {
  TMDB_IMAGE_BASE_URL_W92: "https://image.tmdb.org/t/p/w92",
  TMDB_IMAGE_BASE_URL_W185: "https://image.tmdb.org/t/p/w185",
  TMDB_IMAGE_BASE_URL_W500: "https://image.tmdb.org/t/p/w500",
  IMDB_BASE_URL_NAME: "https://www.imdb.com/name/",
  IMDB_BASE_URL_TITLE: "https://www.imdb.com/title/",
}

export const FIRESTORE_COLLECTIONS = {
  MOVIES: "movies",
  DAILY_GAMES: "dailyGames",
  PLAYERS: "players",
  PLAYER_STATS: "playerStats",
  PLAYER_GAMES: "playerGames",
  GAME_HISTORY: "gameHistory",
}

export const ASYNC_STORAGE_KEYS = {
  THEME_PREFERENCE: "theme_preference",
  DIFFICULTY_SETTING: "difficulty_setting",
  ONBOARDING_STATUS: "hasSeenOnboarding",
  TUTORIAL_GUESS_INPUT_SEEN: "tutorial_guess_input_seen",
  TUTORIAL_RESULTS_SEEN: "tutorial_results_seen",
}

export const GAME_DEFAULTS = {
  MAX_GUESSES: 5,
  INITIAL_HINTS: 3,
}

export const ANIMATION_CONSTANTS = {
  TYPEWRITER_CHAR_DURATION: 40, // ms
  MODAL_ANIMATION_DURATION: 300, // ms
}

export const DEVICE_CONFIG = {
  LOW_END_DEVICE_THRESHOLD_YEAR: 2018,
}

================
File: src/config/difficulty.ts
================
import { GameMode } from "../models/trivia"

/**
 * Internal, machine-readable identifiers for difficulty levels.
 */
export type DifficultyLevel =
  | "LEVEL_1"
  | "LEVEL_2"
  | "LEVEL_3"
  | "LEVEL_4"
  | "LEVEL_5"

/**
 * Defines the core mechanism for how hints/clues are handled in this difficulty.
 */
export type HintStrategy =
  | "ALL_REVEALED"
  | "HINTS_ONLY_REVEALED"
  | "USER_SPEND"
  | "IMPLICIT_FEEDBACK"
  | "NONE_DISABLED"
  | "EXTREME_CHALLENGE"

export interface DifficultyMode {
  label: string
  description: string
  guessesMax: number
  hintStrategy: HintStrategy
  scoreMultiplier: number
  scoreRangePercentage: number
}

/**
 * Default difficulty used when the user has no preference stored.
 */
export const DEFAULT_DIFFICULTY: DifficultyLevel = "LEVEL_3"

/**
 * A numerical ranking for each difficulty level to easily compare them.
 * Lower numbers are easier.
 */
export const DIFFICULTY_RANKING: Record<DifficultyLevel, number> = {
  LEVEL_1: 1,
  LEVEL_2: 2,
  LEVEL_3: 3,
  LEVEL_4: 4,
  LEVEL_5: 5,
}

/**
 * Centralized mapping of internal difficulty levels to their configuration.
 */
export const DIFFICULTY_MODES: Record<DifficultyLevel, DifficultyMode> = {
  LEVEL_1: {
    label: "Basic",
    description:
      "All item hints (like Director and Decade) are revealed at the start. Clues are revealed gradually.",
    guessesMax: 5,
    hintStrategy: "HINTS_ONLY_REVEALED",
    scoreMultiplier: 0.4, // Max score: 400
    scoreRangePercentage: 0.75,
  },
  LEVEL_2: {
    label: "Easy",
    description:
      "Reveal clues gradually. You can use earned hint points to reveal specific hints.",
    guessesMax: 5,
    hintStrategy: "USER_SPEND",
    scoreMultiplier: 0.55, // Max score: 550
    scoreRangePercentage: 0.65,
  },
  LEVEL_3: {
    label: "Medium",
    description:
      "Hints are automatically revealed when you make a guess that shares a category (like actor or decade) with the correct item.",
    guessesMax: 5,
    hintStrategy: "IMPLICIT_FEEDBACK",
    scoreMultiplier: 0.7, // Max score: 700
    scoreRangePercentage: 0.6,
  },
  LEVEL_4: {
    label: "Hard",
    description:
      "A pure test of knowledge. No hints are available or revealed throughout the game.",
    guessesMax: 5,
    hintStrategy: "NONE_DISABLED",
    scoreMultiplier: 0.85, // Max score: 850
    scoreRangePercentage: 0.5,
  },
  LEVEL_5: {
    label: "Extreme",
    description:
      "The ultimate challenge. You only get 3 guesses, clues are revealed more slowly, and no hints are available.",
    guessesMax: 3,
    hintStrategy: "EXTREME_CHALLENGE",
    scoreMultiplier: 1.0, // Max score: 1000
    scoreRangePercentage: 0.4,
  },
}

export type Difficulty = DifficultyLevel

/**
 * Configuration for UI text and settings specific to each game mode.
 * This allows components to remain generic by pulling mode-specific content from this central location.
 */
export const GAME_MODE_CONFIG: Record<
  GameMode,
  {
    title: string
    searchPlaceholder: string
    giveUpConfirmation: string
    fullDescriptionTitle: string
    shareResultTitle: string
    shareResultBody: (didWin: boolean) => string
  }
> = {
  movies: {
    title: "Find the title!",
    searchPlaceholder: "Search for a movie title...",
    giveUpConfirmation: "Are you sure you want to give up on this movie?",
    fullDescriptionTitle: "The Full Plot",
    shareResultTitle: "Talkie Trivia ",
    shareResultBody: (didWin) =>
      didWin ? "I guessed today's movie!" : "I couldn't guess today's movie!",
  },
  videoGames: {
    title: "Name that game!",
    searchPlaceholder: "Search for a video game title...",
    giveUpConfirmation: "Are you sure you want to give up on this game?",
    fullDescriptionTitle: "The Full Description",
    shareResultTitle: "Talkie Trivia ",
    shareResultBody: (didWin) =>
      didWin ? "I guessed today's game!" : "I couldn't guess today's game!",
  },
  tvShows: {
    title: "Find the TV show!",
    searchPlaceholder: "Search for a TV show title...",
    giveUpConfirmation: "Are you sure you want to give up on this show?",
    fullDescriptionTitle: "The Full Synopsis",
    shareResultTitle: "Talkie Trivia ",
    shareResultBody: (didWin) =>
      didWin ? "I guessed today's show!" : "I couldn't guess today's show!",
  },
}

================
File: src/config/firebase.ts
================
import { getPerformance } from "firebase/performance"
import { getAnalytics, isSupported, Analytics } from "firebase/analytics"
import { app } from "../services/firebaseClient"
import { Platform } from "react-native"

let analytics: Analytics | undefined
let perf: any

;(async () => {
  try {
    const supported = await isSupported()
    if (supported) {
      analytics = getAnalytics(app)
    }
  } catch (error) {
  }
})()

if (Platform.OS === "web") {
  try {
    perf = getPerformance(app)
  } catch (e) {
    // Ignore
  }
}

export { perf, analytics }

================
File: src/contexts/authContext.tsx
================
import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  ReactNode,
  useCallback,
} from "react"
import {
  getAuth,
  onAuthStateChanged,
  User,
  signInAnonymously,
} from "firebase/auth"
import Player from "../models/player"
import { useGoogleAuth } from "../utils/hooks/useGoogleAuth"
import { analyticsService } from "../utils/analyticsService"
import { gameService } from "../services/gameService"

interface AuthState {
  player: Player | null
  user: User | null
  loading: boolean
  error: string | null
  handleSignIn: () => Promise<void>
  handleSignOut: () => Promise<void>
  isSigningIn: boolean
}

const AuthContext = createContext<AuthState | undefined>(undefined)

export const AuthProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const [user, setUser] = useState<User | null>(null)
  const [player, setPlayer] = useState<Player | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const onAuthStateChange = useCallback((newUser: User | null) => {
    setUser(newUser)
  }, [])

  const {
    isLoading: isSigningIn,
    authError: googleAuthError,
    handleSignIn,
    handleSignOut,
  } = useGoogleAuth(onAuthStateChange)

  useEffect(() => {
    const auth = getAuth()
    const unsubscribe = onAuthStateChanged(
      auth,
      async (firebaseUser) => {
        setLoading(true)
        setError(null)

        try {
          if (firebaseUser) {
            setUser(firebaseUser)
            const fetchedPlayer = await gameService.ensurePlayerExists(
              firebaseUser.uid,
              firebaseUser.displayName || "Guest"
            )
            setPlayer(fetchedPlayer)

            if (firebaseUser.isAnonymous) {
              analyticsService.trackAnonymousSignIn(firebaseUser.uid)
            } else {
              analyticsService.identifyUser(firebaseUser.uid, {
                name: firebaseUser.displayName,
                email: firebaseUser.email,
              })
            }
          } else {
            await signInAnonymously(auth)
          }
        } catch (e: any) {
          console.error(
            "AuthContext: Error during auth state change handling:",
            e
          )
          setError(`Authentication failed: ${e.message}`)
          setPlayer(null)
          setUser(null)
        } finally {
          setLoading(false)
        }
      },
      (e) => {
        console.error("AuthContext: onAuthStateChanged error:", e)
        setError(`Auth state listener error: ${e.message}`)
        setLoading(false)
      }
    )

    return () => unsubscribe()
  }, [])

  const value = {
    player,
    user,
    loading,
    error: error || googleAuthError,
    handleSignIn,
    handleSignOut,
    isSigningIn,
  }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider")
  }
  return context
}

================
File: src/contexts/networkContext.tsx
================
import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  ReactNode,
} from "react"
import * as Network from "expo-network"
import { analyticsService } from "../utils/analyticsService"

interface NetworkState {
  isNetworkConnected: boolean | null
}

const NetworkContext = createContext<NetworkState | undefined>(undefined)

export const NetworkProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const [isNetworkConnected, setIsNetworkConnected] = useState<boolean | null>(
    null
  )

  useEffect(() => {
    let mounted = true

    const checkNetwork = async () => {
      try {
        const state = await Network.getNetworkStateAsync()
        if (mounted) {
          const isConnected = state.isInternetReachable ?? false
          setIsNetworkConnected(isConnected)
          // Track initial status
          analyticsService.trackNetworkStatusChange(isConnected)
        }
      } catch (error) {
        console.error("NetworkContext: Failed to get network state.", error)
        if (mounted) {
          setIsNetworkConnected(false)
        }
      }
    }

    checkNetwork()

    const subscription = Network.addNetworkStateListener((state) => {
      if (mounted) {
        const isConnected = state.isInternetReachable ?? false
        setIsNetworkConnected((prev) => {
          if (prev !== isConnected) {
            analyticsService.trackNetworkStatusChange(isConnected)
          }
          return isConnected
        })
      }
    })

    return () => {
      mounted = false
      subscription.remove()
    }
  }, [])

  const value = { isNetworkConnected }

  return (
    <NetworkContext.Provider value={value}>{children}</NetworkContext.Provider>
  )
}

export const useNetwork = () => {
  const context = useContext(NetworkContext)
  if (context === undefined) {
    throw new Error("useNetwork must be used within a NetworkProvider")
  }
  return context
}

================
File: src/contexts/themeContext.tsx
================
import React, {
  createContext,
  useState,
  useEffect,
  useContext,
  ReactNode,
} from "react"
import {
  useColorScheme as useRNColorScheme,
  Appearance,
  Platform,
} from "react-native"
import AsyncStorage from "@react-native-async-storage/async-storage"
import { lightColors, darkColors } from "../styles/themes"
import { ASYNC_STORAGE_KEYS } from "../config/constants"

export type Theme = "light" | "dark" | "system"
export type AppColorScheme = "light" | "dark"
export type ThemeColors = typeof lightColors

interface ThemeContextType {
  theme: Theme
  setTheme: (theme: Theme) => void
  colors: ThemeColors
  colorScheme: AppColorScheme
}

const THEME_STORAGE_KEY = ASYNC_STORAGE_KEYS.THEME_PREFERENCE

export const ThemeContext = createContext<ThemeContextType | undefined>(
  undefined
)

export const ThemeProvider = ({ children }: { children: ReactNode }) => {
  const systemColorScheme = useRNColorScheme() ?? "light"
  const [theme, setThemeState] = useState<Theme>("system")

  const colorScheme: AppColorScheme =
    theme === "system" ? (systemColorScheme as AppColorScheme) : theme

  useEffect(() => {
    const loadTheme = async () => {
      try {
        const storedTheme = (await AsyncStorage.getItem(
          THEME_STORAGE_KEY
        )) as Theme | null
        if (storedTheme) {
          setThemeState(storedTheme)
        }
      } catch (e) {
        console.error("Failed to load theme from storage", e)
      }
    }
    loadTheme()
  }, [])

  const setTheme = async (newTheme: Theme) => {
    try {
      await AsyncStorage.setItem(THEME_STORAGE_KEY, newTheme)
      setThemeState(newTheme)

      if (Platform.OS !== "web") {
        if (newTheme === "system") {
          Appearance.setColorScheme(null)
        } else {
          Appearance.setColorScheme(newTheme)
        }
      }
    } catch (e) {
      console.error("Failed to save theme to storage", e)
    }
  }

  const colors: ThemeColors = colorScheme === "dark" ? darkColors : lightColors

  return (
    <ThemeContext.Provider value={{ theme, setTheme, colors, colorScheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeContext)
  if (context === undefined) {
    throw new Error("useTheme must be used within a ThemeProvider")
  }
  return context
}

================
File: src/models/default.ts
================
import { PlayerGame } from "../models/game"
import PlayerStats from "../models/playerStats"
import { TriviaItem } from "./trivia"
import { GAME_DEFAULTS } from "../config/constants"
import { DIFFICULTY_MODES, DEFAULT_DIFFICULTY } from "../config/difficulty"

export const defaultTriviaItem: TriviaItem = {
  id: 0,
  title: "",
  description: "",
  posterPath: "",
  releaseDate: "",
  metadata: {},
  hints: [],
}

export const defaultPlayerGame: PlayerGame = {
  id: "",
  playerID: "",
  triviaItem: defaultTriviaItem,
  guessesMax: DIFFICULTY_MODES[DEFAULT_DIFFICULTY].guessesMax,
  difficulty: DEFAULT_DIFFICULTY,
  guesses: [],
  correctAnswer: false,
  gaveUp: false,
  startDate: new Date(),
  endDate: new Date(),
  hintsUsed: {},
  statsProcessed: false,
}

export const defaultPlayerStats: PlayerStats = {
  id: "",
  currentStreak: 0,
  games: 0,
  maxStreak: 0,
  wins: Array(GAME_DEFAULTS.MAX_GUESSES).fill(0),
  hintsAvailable: GAME_DEFAULTS.INITIAL_HINTS,
  hintsUsedCount: 0,
  allTimeScore: 0,
}

export const generateDateId = (date: Date): string => {
  return date.toISOString().slice(0, 10)
}

================
File: src/models/game.ts
================
import { TriviaItem } from "./trivia"
import { DifficultyLevel } from "../config/difficulty"

export type Difficulty = DifficultyLevel
export type HintType = string

export interface HintInfo {
  type: string
  value: any
  label: string
}

export interface Guess {
  itemId: number | string
  hintInfo?: HintInfo[] | null
}

export interface PlayerGame {
  id: string
  playerID: string
  triviaItem: TriviaItem
  guessesMax: number
  difficulty: DifficultyLevel
  guesses: Guess[]
  correctAnswer: boolean
  gaveUp: boolean
  startDate: Date
  endDate: Date
  hintsUsed?: Partial<Record<string, boolean>>
  statsProcessed?: boolean
}

================
File: src/models/gameHistory.ts
================
import { DifficultyLevel } from "../config/difficulty"
import { GameMode } from "./trivia"

export interface GameHistoryEntry {
  dateId: string // YYYY-MM-DD
  itemId: number | string
  itemTitle: string
  posterPath: string
  wasCorrect: boolean
  gaveUp: boolean
  guessCount: number
  guessesMax: number
  difficulty: DifficultyLevel
  score: number
  gameMode: GameMode
}

================
File: src/models/player.ts
================
export default class Player {
  id: string
  name: string

  constructor(id: string, name: string) {
    this.id = id
    this.name = name
  }
}

================
File: src/models/playerStats.ts
================
export default interface PlayerStats {
  id: string
  currentStreak: number
  games: number
  maxStreak: number
  wins: number[]
  hintsAvailable: number
  hintsUsedCount: number
  lastStreakMessageDate?: string
  allTimeScore: number
}

================
File: src/models/trie.ts
================
export interface TrieNode {
  children: { [key: string]: TrieNode }
  isEndOfWord: boolean
  movieIds: number[]
}

================
File: src/models/trivia.ts
================
/**
 * Defines the available game modes in the application.
 */
export type GameMode = "movies" | "videoGames" | "tvShows"

export interface Genre {
  id: number
  name: string
}

/**
 * Represents a generic hint for any trivia item.
 */
export interface Hint {
  type: string // Machine-readable type, e.g., 'director', 'developer'
  label: string // UI-friendly label, e.g., 'Director', 'Developer'
  value: any // The actual hint data, e.g., a string or an array of objects
  isLinkable?: boolean // Optional: To indicate if the value can be linked externally (like IMDb)
  metadata?: { [key: string]: any } // Optional: For extra data like an actor's imdb_id
}

/**
 * A generic trivia item that can represent a movie, video game, book, etc.
 */
export interface TriviaItem {
  id: number | string
  title: string
  description: string // The main clue text (e.g., plot summary, gameplay description)
  posterPath: string
  releaseDate: string

  // A flexible object for all other non-hint metadata
  metadata: {
    [key: string]: any // e.g., { imdb_id: 'tt12345', metacritic_score: 95 }
  }
  hints: Hint[]
}

/**
 * A lightweight version of TriviaItem, used for the search picker.
 */
export interface BasicTriviaItem {
  id: number | string
  title: string
  releaseDate: string
  posterPath: string
}

================
File: src/services/firebaseClient.ts
================
import { initializeApp, getApps, getApp, FirebaseApp } from "firebase/app"
import {
  initializeFirestore,
  getFirestore,
  Firestore,
} from "firebase/firestore"
import { initializeAuth, getAuth, Auth } from "firebase/auth"
import * as FirebaseAuth from "firebase/auth"
import ReactNativeAsyncStorage from "@react-native-async-storage/async-storage"
import Constants from "expo-constants"
import { Platform } from "react-native"

const firebaseConfig = {
  apiKey: Constants?.expoConfig?.extra?.firebaseApiKey,
  authDomain: `${Constants?.expoConfig?.extra?.firebaseProjectId}.firebaseapp.com`,
  projectId: Constants?.expoConfig?.extra?.firebaseProjectId,
  storageBucket: `${Constants?.expoConfig?.extra?.firebaseProjectId}.appspot.com`,
  messagingSenderId: Constants?.expoConfig?.extra?.firebaseMessagingSenderId,
  appId: Constants?.expoConfig?.extra?.firebaseAppId,
  measurementId: Constants?.expoConfig?.extra?.firebaseMeasurementId,
}

const app: FirebaseApp = getApps().length
  ? getApp()
  : initializeApp(firebaseConfig)

let db: Firestore
let auth: Auth

// 1. Initialize Firestore
try {
  // Pass empty settings object to avoid web-specific cache warnings on native
  db = initializeFirestore(app, {})
} catch (e: any) {
  db = getFirestore(app)
}

// 2. Initialize Auth with Platform-Specific Persistence
// We check Platform.OS to avoid crashing on Web (where AsyncStorage isn't needed/supported this way)
if (Platform.OS === "web") {
  auth = getAuth(app)
} else {
  try {
    // We cast FirebaseAuth to 'any' to access getReactNativePersistence
    // This bypasses the TypeScript error if the environment resolves to Web types
    const { getReactNativePersistence } = FirebaseAuth as any

    if (getReactNativePersistence) {
      auth = initializeAuth(app, {
        persistence: getReactNativePersistence(ReactNativeAsyncStorage),
      })
    } else {
      // Fallback if the import fails for some reason
      auth = getAuth(app)
    }
  } catch (e: any) {
    // If auth is already initialized (hot reload), use existing instance
    auth = getAuth(app)
  }
}

export { app, db, auth }

================
File: src/services/gameService.ts
================
import {
  doc,
  getDoc,
  setDoc,
  writeBatch,
  collection,
  query,
  orderBy,
  limit,
  getDocs,
} from "firebase/firestore"
import { db } from "./firebaseClient"
import { playerConverter } from "../utils/firestore/converters/player"
import { playerGameConverter } from "../utils/firestore/converters/playerGame"
import { playerStatsConverter } from "../utils/firestore/converters/playerStats"
import { gameHistoryEntryConverter } from "../utils/firestore/converters/gameHistoryEntry"
import Player from "../models/player"
import PlayerStats from "../models/playerStats"
import { PlayerGame } from "../models/game"
import { TriviaItem } from "../models/trivia"
import { FIRESTORE_COLLECTIONS } from "../config/constants"
import { GameHistoryEntry } from "../models/gameHistory"
import { defaultPlayerGame } from "../models/default"
import { DEFAULT_DIFFICULTY } from "../config/difficulty"

export const gameService = {
  ensurePlayerExists: async (
    playerId: string,
    playerName: string
  ): Promise<Player> => {
    const playerRef = doc(
      db,
      FIRESTORE_COLLECTIONS.PLAYERS,
      playerId
    ).withConverter(playerConverter)
    const playerSnap = await getDoc(playerRef)
    if (playerSnap.exists()) {
      return playerSnap.data()
    } else {
      const newPlayer = new Player(playerId, playerName)
      await setDoc(playerRef, newPlayer)
      return newPlayer
    }
  },

  fetchOrCreatePlayerGame: async (
    playerId: string,
    dateId: string,
    dailyItem: TriviaItem,
    guessesMax: number
  ): Promise<PlayerGame> => {
    const playerGameRef = doc(
      db,
      FIRESTORE_COLLECTIONS.PLAYER_GAMES,
      `${playerId}-${dateId}`
    ).withConverter(playerGameConverter)
    const gameSnap = await getDoc(playerGameRef)

    if (gameSnap.exists()) {
      const existingGame = gameSnap.data()
      existingGame.guessesMax = guessesMax
      return existingGame
    } else {
      const newPlayerGame: PlayerGame = {
        ...defaultPlayerGame,
        id: `${playerId}-${dateId}`,
        playerID: playerId,
        triviaItem: dailyItem,
        startDate: new Date(),
        endDate: new Date(),
        guessesMax: guessesMax,
        difficulty: DEFAULT_DIFFICULTY,
        hintsUsed: {},
      }
      await setDoc(playerGameRef, newPlayerGame)
      return newPlayerGame
    }
  },

  fetchPlayerGameById: async (
    playerGameId: string
  ): Promise<PlayerGame | null> => {
    const playerGameRef = doc(
      db,
      FIRESTORE_COLLECTIONS.PLAYER_GAMES,
      playerGameId
    ).withConverter(playerGameConverter)
    const gameSnap = await getDoc(playerGameRef)
    return gameSnap.exists() ? gameSnap.data() : null
  },

  fetchOrCreatePlayerStats: async (playerId: string): Promise<PlayerStats> => {
    const statsRef = doc(
      db,
      FIRESTORE_COLLECTIONS.PLAYER_STATS,
      playerId
    ).withConverter(playerStatsConverter)
    const statsSnap = await getDoc(statsRef)
    if (statsSnap.exists()) {
      return statsSnap.data()
    } else {
      const newPlayerStats: PlayerStats = {
        id: playerId,
        currentStreak: 0,
        games: 0,
        maxStreak: 0,
        wins: [0, 0, 0, 0, 0],
        hintsAvailable: 3,
        hintsUsedCount: 0,
        allTimeScore: 0,
      }
      await setDoc(statsRef, newPlayerStats)
      return newPlayerStats
    }
  },

  savePlayerProgress: async (
    playerGame: PlayerGame,
    playerStats: PlayerStats,
    gameHistoryEntry: GameHistoryEntry | null = null
  ) => {
    if (!playerGame.playerID) {
      throw new Error("Player ID is missing. Cannot save game progress.")
    }

    const batch = writeBatch(db)

    const statsDocRef = doc(
      db,
      FIRESTORE_COLLECTIONS.PLAYER_STATS,
      playerGame.playerID
    ).withConverter(playerStatsConverter)
    batch.set(statsDocRef, playerStats, { merge: true })

    const gameDocRef = doc(
      db,
      FIRESTORE_COLLECTIONS.PLAYER_GAMES,
      playerGame.id
    ).withConverter(playerGameConverter)
    batch.set(gameDocRef, playerGame, { merge: true })

    if (gameHistoryEntry) {
      const historyDocRef = doc(
        db,
        `${FIRESTORE_COLLECTIONS.PLAYERS}/${playerGame.playerID}/${FIRESTORE_COLLECTIONS.GAME_HISTORY}`,
        gameHistoryEntry.dateId
      ).withConverter(gameHistoryEntryConverter)
      batch.set(historyDocRef, gameHistoryEntry)
    }

    await batch.commit()
  },

  fetchGameHistory: async (playerId: string): Promise<GameHistoryEntry[]> => {
    const historyRef = collection(
      db,
      `${FIRESTORE_COLLECTIONS.PLAYERS}/${playerId}/${FIRESTORE_COLLECTIONS.GAME_HISTORY}`
    ).withConverter(gameHistoryEntryConverter)
    const q = query(historyRef, orderBy("dateId", "desc"), limit(20))
    const querySnapshot = await getDocs(q)
    return querySnapshot.docs.map((doc) => doc.data())
  },
}

================
File: src/services/gameServiceFactory.ts
================
import { GameMode } from "../models/trivia"
import { IGameDataService } from "./iGameDataService"
import { MovieDataService } from "./movieDataService"
import { VideoGameService } from "./videoGameService"

// A map holding a single instance of each service
const serviceInstances: { [key in GameMode]?: IGameDataService } = {
  movies: new MovieDataService(),
  videoGames: new VideoGameService(),
  // tvShows: new TvShowDataService(),
}

export function getGameDataService(mode: GameMode): IGameDataService {
  const service = serviceInstances[mode]
  if (!service) {
    throw new Error(`No game data service found for mode: ${mode}`)
  }
  return service
}

================
File: src/services/iGameDataService.ts
================
import { BasicTriviaItem, TriviaItem, GameMode } from "../models/trivia"

export interface IGameDataService {
  mode: GameMode

  /**
   * Fetches the daily trivia item and the full lists of basic/full items for the game.
   */
  getDailyTriviaItemAndLists(): Promise<{
    dailyItem: TriviaItem
    fullItems: readonly TriviaItem[]
    basicItems: readonly BasicTriviaItem[]
  }>

  /**
   * Fetches a single trivia item by its ID.
   * @param id The ID of the item to fetch.
   */
  getItemById(id: number | string): Promise<TriviaItem | null>
}

================
File: src/services/movieDataService.ts
================
import { IGameDataService } from "./iGameDataService"
import { GameMode, TriviaItem, BasicTriviaItem, Hint } from "../models/trivia"
import Constants from "expo-constants"

import popularMoviesData from "../../data/popularMovies.json"

interface RawMovie {
  id: number
  title: string
  overview: string
  poster_path: string
  release_date: string
  tagline: string
  imdb_id: string
  popularity: number
  vote_average: number
  vote_count: number
  genres: { id: number; name: string }[]
  director: { id: number; name: string; imdb_id?: string }
  actors: { id: number; name: string; imdb_id?: string; order: number }[]
}

export class MovieDataService implements IGameDataService {
  public mode: GameMode = "movies"
  private allMovies: readonly RawMovie[] = popularMoviesData as RawMovie[]

  private _transformMovieToTriviaItem(movie: RawMovie): TriviaItem {
    const sanitizedActors = (movie.actors || []).map((actor) => ({
      ...actor,
      imdb_id: actor.imdb_id || null,
    }))

    return {
      id: movie.id,
      title: movie.title,
      description: movie.overview,
      posterPath: movie.poster_path,
      releaseDate: movie.release_date,
      metadata: {
        imdb_id: movie.imdb_id || null,
        tagline: movie.tagline || null,
        popularity: movie.popularity || 0,
        vote_average: movie.vote_average || 0,
        vote_count: movie.vote_count || 0,
        genres: movie.genres || [],
      },
      hints: [
        {
          type: "director",
          label: "Director",
          value: movie.director?.name || "N/A",
          isLinkable: !!movie.director?.imdb_id,
          metadata: { imdb_id: movie.director?.imdb_id || null },
        },
        {
          type: "actors",
          label: "Actors",
          value: sanitizedActors,
          isLinkable: true,
        },
        {
          type: "genre",
          label: "Genre",
          value: movie.genres?.[0]?.name || "N/A",
        },
        {
          type: "decade",
          label: "Decade",
          value: movie.release_date
            ? `${movie.release_date.substring(0, 3)}0s`
            : "N/A",
        },
      ],
    }
  }

  public async getDailyTriviaItemAndLists(): Promise<{
    dailyItem: TriviaItem
    fullItems: readonly TriviaItem[]
    basicItems: readonly BasicTriviaItem[]
  }> {
    // --- E2E TESTING OVERRIDE ---
    const isE2E =
      Constants.expoConfig?.extra?.isE2E === true ||
      process.env.EXPO_PUBLIC_IS_E2E === "true"

    if (isE2E) {
      const inception = this.allMovies.find((m) => m.title === "Inception")
      const selectedMovie = inception || this.allMovies[0]

      return {
        dailyItem: this._transformMovieToTriviaItem(selectedMovie),
        fullItems: this.allMovies.map((m) =>
          this._transformMovieToTriviaItem(m)
        ),
        basicItems: this.allMovies.map((movie) => ({
          id: movie.id,
          title: movie.title,
          releaseDate: movie.release_date,
          posterPath: movie.poster_path,
        })),
      }
    }

    if (!this.allMovies || this.allMovies.length === 0) {
      throw new Error("Local movie data is missing or empty.")
    }

    const today = new Date()
    const startOfYear = new Date(today.getFullYear(), 0, 0)
    const diff = today.getTime() - startOfYear.getTime()
    const oneDay = 1000 * 60 * 60 * 24
    const dayOfYear = Math.floor(diff / oneDay)

    const movieIndex = dayOfYear % this.allMovies.length
    const selectedMovie = this.allMovies[movieIndex]

    const fullItems = this.allMovies.map((m) =>
      this._transformMovieToTriviaItem(m)
    )
    const basicItems = this.allMovies.map((movie) => ({
      id: movie.id,
      title: movie.title,
      releaseDate: movie.release_date,
      posterPath: movie.poster_path,
    }))

    return {
      dailyItem: this._transformMovieToTriviaItem(selectedMovie),
      fullItems,
      basicItems,
    }
  }

  public async getItemById(id: number | string): Promise<TriviaItem | null> {
    const movie = this.allMovies.find((m) => m.id === Number(id))
    return movie ? this._transformMovieToTriviaItem(movie) : null
  }
}

================
File: src/services/videoGameService.ts
================
import { IGameDataService } from "./iGameDataService"
import { GameMode, TriviaItem, BasicTriviaItem } from "../models/trivia"

export class VideoGameService implements IGameDataService {
  public mode: GameMode = "videoGames"

  public async getDailyTriviaItemAndLists(): Promise<{
    dailyItem: TriviaItem
    fullItems: readonly TriviaItem[]
    basicItems: readonly BasicTriviaItem[]
  }> {
    // In the future, this will load from a videoGames.json file
    // For now, it's a placeholder.
    console.warn("VideoGameService is not yet implemented.")
    throw new Error("Video game mode is not available yet.")

    // Example of what it would return:
    // return {
    //   dailyItem: {} as TriviaItem,
    //   fullItems: [],
    //   basicItems: [],
    // };
  }

  public async getItemById(id: number | string): Promise<TriviaItem | null> {
    throw new Error("VideoGameService.getItemById is not yet implemented.")
  }
}

================
File: src/state/gameStore.ts
================
import { create } from "zustand"
import { produce } from "immer"
import AsyncStorage from "@react-native-async-storage/async-storage"
import { PlayerGame, Guess, HintInfo } from "../models/game"
import PlayerStats from "../models/playerStats"
import { BasicTriviaItem, GameMode, TriviaItem } from "../models/trivia"
import {
  defaultPlayerGame,
  defaultPlayerStats,
  generateDateId,
} from "../models/default"
import { GameHistoryEntry } from "../models/gameHistory"
import { gameService } from "../services/gameService"
import { getGameDataService } from "../services/gameServiceFactory"
import Player from "../models/player"
import { ASYNC_STORAGE_KEYS } from "../config/constants"
import { analyticsService } from "../utils/analyticsService"
import { calculateScore } from "../utils/scoreUtils"
import { generateImplicitHint } from "../utils/guessFeedbackUtils"
import {
  DifficultyLevel,
  DIFFICULTY_MODES,
  DEFAULT_DIFFICULTY,
  DIFFICULTY_RANKING,
} from "../config/difficulty"

export type GameStatus = "playing" | "revealing" | "gameOver"

export interface GameState {
  // Core State
  playerGame: PlayerGame
  playerStats: PlayerStats
  basicItems: readonly BasicTriviaItem[]
  fullItems: readonly TriviaItem[]

  // App Status
  loading: boolean
  error: string | null
  isInteractionsDisabled: boolean
  gameStatus: GameStatus

  // Settings & Mode
  gameMode: GameMode
  difficulty: DifficultyLevel
  tutorialState: {
    showGuessInputTip: boolean
    showResultsTip: boolean
  }

  // UI State
  showModal: boolean
  showConfetti: boolean
  flashMessage: string | null
  lastGuessResult: {
    itemId: number | string
    correct: boolean
    feedback?: string | null
    hintInfo?: HintInfo[] | null
  } | null

  // Actions
  initializeGame: (player: Player) => Promise<void>
  setGameMode: (mode: GameMode) => Promise<void>
  setDifficulty: (newDifficulty: DifficultyLevel) => void
  dismissGuessInputTip: () => void
  dismissResultsTip: () => void
  makeGuess: (selectedItem: BasicTriviaItem) => void
  useHint: (hintType: string) => void
  giveUp: () => void
  setShowModal: (show: boolean) => void
  handleConfettiStop: () => void
  _processGameOver: () => Promise<void>
  completeRevealSequence: () => void
}

export const useGameStore = create<GameState>((set, get) => ({
  // --- INITIAL STATE ---
  playerGame: defaultPlayerGame,
  playerStats: defaultPlayerStats,
  basicItems: [],
  fullItems: [],
  loading: true,
  error: null,
  isInteractionsDisabled: true,
  gameStatus: "playing",
  gameMode: "movies",
  difficulty: DEFAULT_DIFFICULTY,
  tutorialState: {
    showGuessInputTip: false,
    showResultsTip: false,
  },
  showModal: false,
  showConfetti: false,
  flashMessage: null,
  lastGuessResult: null,

  initializeGame: async (player) => {
    set({
      loading: true,
      error: null,
      isInteractionsDisabled: true,
      gameStatus: "playing",
    })
    try {
      const { gameMode } = get()
      const dataService = getGameDataService(gameMode)

      const [
        { dailyItem, fullItems, basicItems },
        storedDifficultyResult,
        hasSeenGuessInputTip,
        hasSeenResultsTip,
      ] = await Promise.all([
        dataService.getDailyTriviaItemAndLists(),
        AsyncStorage.getItem(ASYNC_STORAGE_KEYS.DIFFICULTY_SETTING),
        AsyncStorage.getItem(ASYNC_STORAGE_KEYS.TUTORIAL_GUESS_INPUT_SEEN),
        AsyncStorage.getItem(ASYNC_STORAGE_KEYS.TUTORIAL_RESULTS_SEEN),
      ])

      let difficulty =
        (storedDifficultyResult as DifficultyLevel) || DEFAULT_DIFFICULTY
      if (!DIFFICULTY_MODES[difficulty]) {
        difficulty = DEFAULT_DIFFICULTY
      }

      if (hasSeenGuessInputTip === null) {
        set(
          produce((state: GameState) => {
            state.tutorialState.showGuessInputTip = true
          })
        )
        analyticsService.trackOnboardingStarted()
      }
      if (hasSeenResultsTip === null) {
        set(
          produce((state: GameState) => {
            state.tutorialState.showResultsTip = true
          })
        )
      }

      const dateId = generateDateId(new Date())
      const guessesMax = DIFFICULTY_MODES[difficulty].guessesMax

      const [initialPlayerGame, initialPlayerStats] = await Promise.all([
        gameService.fetchOrCreatePlayerGame(
          player.id,
          dateId,
          dailyItem,
          guessesMax
        ),
        gameService.fetchOrCreatePlayerStats(player.id),
      ])

      initialPlayerGame.difficulty = difficulty
      const isGameOver =
        initialPlayerGame.correctAnswer ||
        initialPlayerGame.gaveUp ||
        initialPlayerGame.guesses.length >= initialPlayerGame.guessesMax

      set({
        difficulty,
        playerGame: initialPlayerGame,
        playerStats: initialPlayerStats,
        fullItems,
        basicItems,
        loading: false,
        isInteractionsDisabled: isGameOver,
        gameStatus: isGameOver ? "gameOver" : "playing",
      })
    } catch (e: any) {
      console.error("Zustand Store: Failed to initialize game:", e)
      set({
        error: `Failed to load game: ${e.message}`,
        loading: false,
        isInteractionsDisabled: true,
      })
    }
  },

  setGameMode: async (mode: GameMode) => {
    const { gameMode, playerGame } = get()
    if (mode === gameMode) return

    if (
      playerGame.guesses.length > 0 &&
      !playerGame.correctAnswer &&
      !playerGame.gaveUp
    ) {
      set({ flashMessage: "Finish the current game before switching modes!" })
      setTimeout(() => set({ flashMessage: null }), 3000)
      return
    }

    set({ gameMode: mode })
    const player = { id: get().playerGame.playerID, name: get().playerStats.id }
    await get().initializeGame(player)
  },

  setDifficulty: (newDifficulty: DifficultyLevel) => {
    AsyncStorage.setItem(ASYNC_STORAGE_KEYS.DIFFICULTY_SETTING, newDifficulty)

    set(
      produce((state: GameState) => {
        state.difficulty = newDifficulty
        state.playerGame.guessesMax = DIFFICULTY_MODES[newDifficulty].guessesMax

        const currentLowestRank =
          DIFFICULTY_RANKING[state.playerGame.difficulty]
        const newRank = DIFFICULTY_RANKING[newDifficulty]

        if (newRank < currentLowestRank) {
          state.playerGame.difficulty = newDifficulty
          state.flashMessage = `Score will be based on ${DIFFICULTY_MODES[newDifficulty].label} mode.`
        }
      })
    )
  },

  dismissGuessInputTip: () => {
    set(
      produce((state: GameState) => {
        state.tutorialState.showGuessInputTip = false
      })
    )
    AsyncStorage.setItem(ASYNC_STORAGE_KEYS.TUTORIAL_GUESS_INPUT_SEEN, "true")
  },

  dismissResultsTip: () => {
    set(
      produce((state: GameState) => {
        state.tutorialState.showResultsTip = false
      })
    )
    analyticsService.trackOnboardingCompleted()
    AsyncStorage.setItem(ASYNC_STORAGE_KEYS.TUTORIAL_RESULTS_SEEN, "true")
  },

  makeGuess: (selectedItem) => {
    const { playerGame, fullItems, difficulty } = get()
    if (playerGame.correctAnswer || playerGame.gaveUp) return

    const correctItem = playerGame.triviaItem
    const isCorrectAnswer = correctItem.id === selectedItem.id

    const fullGuessedItem = fullItems.find(
      (item) => item.id === selectedItem.id
    )

    const hintStrategy = DIFFICULTY_MODES[difficulty].hintStrategy

    let hintResult: {
      feedback: string | null
      revealedHints: Partial<Record<string, boolean>>
      hintInfo: any[] | null
    } = { feedback: null, revealedHints: {}, hintInfo: null }

    if (
      !isCorrectAnswer &&
      fullGuessedItem &&
      hintStrategy === "IMPLICIT_FEEDBACK"
    ) {
      hintResult = generateImplicitHint(
        fullGuessedItem,
        correctItem,
        playerGame.hintsUsed
      )
    } else if (!isCorrectAnswer) {
      hintResult.feedback = "Not quite! Try again."
    }

    analyticsService.trackGuessMade(
      playerGame.guesses.length + 1,
      isCorrectAnswer,
      Number(selectedItem.id),
      selectedItem.title
    )

    const canMakeGuess = playerGame.guesses.length < playerGame.guessesMax

    set(
      produce((state: GameState) => {
        if (canMakeGuess) {
          const newGuess: Guess = {
            itemId: selectedItem.id,
            hintInfo: hintResult.hintInfo,
          }
          state.playerGame.guesses.push(newGuess)
          state.playerGame.correctAnswer = isCorrectAnswer

          if (Object.keys(hintResult.revealedHints).length > 0) {
            state.playerGame.hintsUsed = {
              ...state.playerGame.hintsUsed,
              ...hintResult.revealedHints,
            }
          }
          state.lastGuessResult = {
            itemId: selectedItem.id,
            correct: isCorrectAnswer,
            feedback: hintResult.feedback,
            hintInfo: hintResult.hintInfo,
          }
        }
      })
    )

    if (isCorrectAnswer) set({ showConfetti: true })

    get()
      ._processGameOver()
      .catch((error) => {
        console.error("Failed to process game over after guess:", error)
        set({ flashMessage: "Could not save progress. Check connection." })
      })
  },

  useHint: (hintType: string) => {
    const { playerGame, playerStats, difficulty } = get()
    const isUserSpendStrategy =
      DIFFICULTY_MODES[difficulty].hintStrategy === "USER_SPEND"

    if (
      !isUserSpendStrategy ||
      playerGame.hintsUsed?.[hintType] ||
      (playerStats?.hintsAvailable ?? 0) <= 0
    ) {
      return
    }

    analyticsService.trackHintUsed(
      hintType,
      playerGame.guesses.length,
      playerStats.hintsAvailable - 1
    )

    set(
      produce((state: GameState) => {
        state.playerGame.hintsUsed = {
          ...state.playerGame.hintsUsed,
          [hintType]: true,
        }
        if (state.playerStats) {
          state.playerStats.hintsAvailable = Math.max(
            0,
            state.playerStats.hintsAvailable - 1
          )
          state.playerStats.hintsUsedCount =
            (state.playerStats.hintsUsedCount || 0) + 1
        }
      })
    )
  },

  giveUp: () => {
    const { playerGame } = get()
    analyticsService.trackGameGiveUp(
      playerGame.guesses.length,
      Object.keys(playerGame.hintsUsed || {}).length
    )
    set(
      produce((state: GameState) => {
        state.playerGame.gaveUp = true
      })
    )
    get()
      ._processGameOver()
      .catch((error) => {
        console.error("Failed to process game over after giving up:", error)
        set({ flashMessage: "Could not save progress. Check connection." })
      })
  },

  _processGameOver: async () => {
    const { playerGame, playerStats, gameMode } = get()
    const isGameOver =
      playerGame.correctAnswer ||
      playerGame.gaveUp ||
      playerGame.guesses.length >= playerGame.guessesMax

    if (!isGameOver || playerGame.statsProcessed) return
    set({ isInteractionsDisabled: true })

    setTimeout(() => {
      set({ gameStatus: "revealing" })
    }, 1200)

    const calculatedScore = calculateScore(playerGame)

    const updatedStats = produce(playerStats, (draft: PlayerStats) => {
      draft.games = (draft.games || 0) + 1
      draft.allTimeScore = (draft.allTimeScore || 0) + calculatedScore
      if (playerGame.correctAnswer) {
        draft.currentStreak = (draft.currentStreak || 0) + 1
        draft.maxStreak = Math.max(draft.currentStreak, draft.maxStreak || 0)
        const guessCount = playerGame.guesses.length
        if (guessCount > 0 && guessCount <= draft.wins.length) {
          draft.wins[guessCount - 1] = (draft.wins[guessCount - 1] || 0) + 1
        }
      } else {
        draft.currentStreak = 0
      }
    })

    const historyEntry: GameHistoryEntry = {
      dateId: generateDateId(playerGame.startDate),
      itemId: playerGame.triviaItem.id,
      itemTitle: playerGame.triviaItem.title,
      posterPath: playerGame.triviaItem.posterPath,
      wasCorrect: playerGame.correctAnswer,
      gaveUp: playerGame.gaveUp,
      guessCount: playerGame.guesses.length,
      guessesMax: playerGame.guessesMax,
      difficulty: playerGame.difficulty,
      score: calculatedScore,
      gameMode: gameMode,
    }

    set(
      produce((state: GameState) => {
        state.playerGame.statsProcessed = true
      })
    )

    try {
      await gameService.savePlayerProgress(
        get().playerGame,
        updatedStats,
        historyEntry
      )
      set({ playerStats: updatedStats })
    } catch (e: any) {
      set({ error: `Failed to save progress: ${e.message}` })
      throw e
    }
  },

  completeRevealSequence: () => {
    set({ gameStatus: "gameOver" })
    setTimeout(() => {
      set({ showModal: true })
    }, 500)
  },

  setShowModal: (show) => set({ showModal: show }),
  handleConfettiStop: () => set({ showConfetti: false }),
}))

================
File: src/styles/global.ts
================
import { Dimensions, PixelRatio, Platform } from "react-native"
import { lightColors, ThemeColors } from "./themes"

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get("window")

const baseWidth = 375
const baseHeight = 812

const isSmallScreen = () => SCREEN_WIDTH < 375
const isMediumScreen = () => SCREEN_WIDTH >= 375 && SCREEN_WIDTH < 768
const isLargeScreen = () => SCREEN_WIDTH >= 768

const scale = (size: number) => {
  const scaleWidth = SCREEN_WIDTH / baseWidth
  const scaleHeight = SCREEN_HEIGHT / baseHeight
  const scaleFactor = Math.min(scaleWidth, scaleHeight)
  return PixelRatio.roundToNearestPixel(size * scaleFactor)
}

const responsiveFontSize = (size: number) => {
  let scaleFactor = 1

  if (isSmallScreen()) {
    scaleFactor = (SCREEN_WIDTH / baseWidth) * 0.9
  } else if (isMediumScreen()) {
    scaleFactor = 1.0
  } else {
    scaleFactor = 1.1
  }

  return Math.min(
    PixelRatio.roundToNearestPixel(size * scaleFactor),
    size * 1.2
  )
}

export const responsive = {
  scale,
  responsiveFontSize,
  isSmallDevice: SCREEN_WIDTH < 375,
  isTablet: SCREEN_WIDTH >= 768,
  screenWidth: SCREEN_WIDTH,
  screenHeight: SCREEN_HEIGHT,
  platform: Platform.OS,
  isSmallScreen,
  isMediumScreen,
  isLargeScreen,
}

export const getTypography = (colors: typeof lightColors) => ({
  heading1: {
    fontFamily: "Arvo-Bold",
    fontSize: responsive.responsiveFontSize(28),
    lineHeight: responsive.responsiveFontSize(34),
    color: colors.textPrimary,
  },
  heading2: {
    fontFamily: "Arvo-Bold",
    fontSize: responsive.responsiveFontSize(22),
    lineHeight: responsive.responsiveFontSize(28),
    color: colors.textPrimary,
  },
  bodyText: {
    fontFamily: "Arvo-Regular",
    fontSize: responsive.responsiveFontSize(16),
    lineHeight: responsive.responsiveFontSize(22),
    color: colors.textSecondary,
  },
  button: {
    fontFamily: "Arvo-Bold",
    fontSize: responsive.responsiveFontSize(16),
    color: colors.background,
  },
  caption: {
    fontFamily: "Arvo-Regular",
    fontSize: responsive.responsiveFontSize(12),
    lineHeight: responsive.responsiveFontSize(16),
    color: colors.textSecondary,
  },
})

export const spacing = {
  extraSmall: scale(4),
  small: scale(8),
  medium: scale(16),
  large: scale(24),
  extraLarge: scale(32),
}

export const shadows = {
  light: Platform.select({
    ios: {
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.23,
      shadowRadius: 2.62,
    },
    android: { elevation: 4 },
    web: { boxShadow: "0 2px 4px rgba(0,0,0,0.1)" },
  }),
  medium: Platform.select({
    ios: {
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.3,
      shadowRadius: 4.65,
    },
    android: { elevation: 8 },
    web: { boxShadow: "0 4px 8px rgba(0,0,0,0.15)" },
  }),
}

export const getButtonStyles = (colors: ThemeColors) => ({
  base: {
    borderRadius: responsive.scale(8),
    paddingVertical: spacing.small,
    paddingHorizontal: spacing.medium,
    justifyContent: "center" as const,
    alignItems: "center" as const,
    ...shadows.light,
  },
  text: {
    fontFamily: "Arvo-Bold",
    fontSize: responsive.responsiveFontSize(16),
    textAlign: "center" as const,
  },
  pressed: {
    transform: [{ translateY: 2 }],
    opacity: 0.8,
  },
  disabled: {
    opacity: 0.6,
  },
})

================
File: src/styles/themes.ts
================
export const lightColors = {
  background: "#FFFFFF",
  backgroundLight: "#F5F5F5",
  surface: "#E0E0E0",
  border: "#BDBDBD",
  primary: "#FFC107",
  secondary: "#212121",
  tertiary: "#E0A800",
  success: "#4CAF50",
  error: "#D32F2F",
  warning: "#FFA000",
  textPrimary: "#212121",
  textSecondary: "#757575",
  textDisabled: "#BDBDBD",
  quinary: "#29D7D7",
}

export const darkColors = {
  background: "#121212",
  backgroundLight: "#1E1E1E",
  surface: "#2A2A2A",
  border: "#404040",
  primary: "#FFC107",
  secondary: "#FFFFFF",
  tertiary: "#E0A800",
  success: "#4CAF50",
  error: "#D32F2F",
  warning: "#FFA000",
  textPrimary: "#F5F5F5",
  textSecondary: "#A0A0A0",
  textDisabled: "#616161",
  quinary: "#29D7D7",
}

export type ThemeColors = typeof lightColors

================
File: src/styles/utils.ts
================
import { StyleSheet } from "react-native"
import { spacing } from "./global"

/**
 * Utility Stylesheet (Atomic/Tailwind-inspired)
 * Provides a set of common, reusable styles for layout and spacing to reduce
 * the need for creating trivial named styles in component-specific stylesheets.
 *
 * Naming convention:
 * - `p` (padding), `m` (margin)
 * - `t, b, l, r` (top, bottom, left, right)
 * - `x` (horizontal), `y` (vertical)
 * - `Xs, Sm, Md, Lg, Xl` (extraSmall, small, medium, large, extraLarge sizes from spacing tokens)
 * - `0` (zero)
 *
 * Example: `mtMd` = margin-top: medium (spacing.medium)
 */
export const u = StyleSheet.create({
  /**
   * Display & Sizing
   */
  flex: { flex: 1 },
  wFull: { width: "100%" },
  hFull: { height: "100%" },

  /**
   * Flexbox
   */
  flexRow: { flexDirection: "row" },
  flexCol: { flexDirection: "column" },
  flexWrap: { flexWrap: "wrap" },
  flexGrow: { flexGrow: 1 },
  flexShrink: { flexShrink: 1 },

  // Justify Content
  justifyStart: { justifyContent: "flex-start" },
  justifyCenter: { justifyContent: "center" },
  justifyEnd: { justifyContent: "flex-end" },
  justifyBetween: { justifyContent: "space-between" },
  justifyAround: { justifyContent: "space-around" },

  // Align Items
  alignStart: { alignItems: "flex-start" },
  alignCenter: { alignItems: "center" },
  alignEnd: { alignItems: "flex-end" },
  alignStretch: { alignItems: "stretch" },

  /**
   * Spacing - Margin
   */
  m0: { margin: 0 },
  mXs: { margin: spacing.extraSmall },
  mSm: { margin: spacing.small },
  mMd: { margin: spacing.medium },
  mLg: { margin: spacing.large },
  mXl: { margin: spacing.extraLarge },

  mx0: { marginHorizontal: 0 },
  mxXs: { marginHorizontal: spacing.extraSmall },
  mxSm: { marginHorizontal: spacing.small },
  mxMd: { marginHorizontal: spacing.medium },
  mxLg: { marginHorizontal: spacing.large },
  mxXl: { marginHorizontal: spacing.extraLarge },

  my0: { marginVertical: 0 },
  myXs: { marginVertical: spacing.extraSmall },
  mySm: { marginVertical: spacing.small },
  myMd: { marginVertical: spacing.medium },
  myLg: { marginVertical: spacing.large },
  myXl: { marginVertical: spacing.extraLarge },

  mtSm: { marginTop: spacing.small },
  mtMd: { marginTop: spacing.medium },
  mbSm: { marginBottom: spacing.small },
  mbMd: { marginBottom: spacing.medium },
  mlSm: { marginLeft: spacing.small },
  mrSm: { marginRight: spacing.small },

  /**
   * Spacing - Padding
   */
  p0: { padding: 0 },
  pXs: { padding: spacing.extraSmall },
  pSm: { padding: spacing.small },
  pMd: { padding: spacing.medium },
  pLg: { padding: spacing.large },
  pXl: { padding: spacing.extraLarge },

  px0: { paddingHorizontal: 0 },
  pxXs: { paddingHorizontal: spacing.extraSmall },
  pxSm: { paddingHorizontal: spacing.small },
  pxMd: { paddingHorizontal: spacing.medium },
  pxLg: { paddingHorizontal: spacing.large },
  pxXl: { paddingHorizontal: spacing.extraLarge },

  py0: { paddingVertical: 0 },
  pyXs: { paddingVertical: spacing.extraSmall },
  pySm: { paddingVertical: spacing.small },
  pyMd: { paddingVertical: spacing.medium },
  pyLg: { paddingVertical: spacing.large },
  pyXl: { paddingVertical: spacing.extraLarge },

  ptSm: { paddingTop: spacing.small },
  ptMd: { paddingTop: spacing.medium },
  pbSm: { paddingBottom: spacing.small },
  pbMd: { paddingBottom: spacing.medium },

  /**
   * Typography
   */
  textCenter: { textAlign: "center" },
  textRight: { textAlign: "right" },
  textLeft: { textAlign: "left" },
  fontBold: { fontFamily: "Arvo-Bold" },
  fontItalic: { fontFamily: "Arvo-Italic" },

  /**
   * Borders
   */
  border: { borderWidth: 1 },
  borderT: { borderTopWidth: 1 },
  borderB: { borderBottomWidth: 1 },

  /**
   * Position
   */
  absolute: { position: "absolute" },
  relative: { position: "relative" },

  /**
   * Overflow
   */
  overflowHidden: { overflow: "hidden" },
})

================
File: src/utils/firestore/converters/gameHistoryEntry.ts
================
import { GameHistoryEntry } from "../../../models/gameHistory"
import { Timestamp } from "firebase/firestore"
import { DEFAULT_DIFFICULTY } from "../../../config/difficulty"

export const gameHistoryEntryConverter = {
  toFirestore: (entry: GameHistoryEntry) => {
    return {
      dateId: entry.dateId,
      itemId: entry.itemId,
      itemTitle: entry.itemTitle,
      posterPath: entry.posterPath,
      wasCorrect: entry.wasCorrect,
      gaveUp: entry.gaveUp,
      guessCount: entry.guessCount,
      guessesMax: entry.guessesMax,
      difficulty: entry.difficulty,
      score: entry.score,
      gameMode: entry.gameMode || "movies",
      createdAt: Timestamp.now(),
    }
  },
  fromFirestore: (snapshot: any, options: any): GameHistoryEntry => {
    const data = snapshot.data(options)
    return {
      dateId: data.dateId,
      itemId: data.itemId || data.movieId,
      itemTitle: data.itemTitle || data.movieTitle,
      posterPath: data.posterPath,
      wasCorrect: data.wasCorrect,
      gaveUp: data.gaveUp,
      guessCount: data.guessCount,
      guessesMax: data.guessesMax,
      difficulty: data.difficulty || DEFAULT_DIFFICULTY,
      score: data.score || 0,
      gameMode: data.gameMode || "movies",
    }
  },
}

================
File: src/utils/firestore/converters/player.ts
================
import Player from "../../../models/player"
import { QueryDocumentSnapshot, SnapshotOptions } from "firebase/firestore"

export const playerConverter = {
  toFirestore: (player: Player) => {
    let p: Player = {
      id: player.id,
      name: player.name,
    }
    return p
  },
  fromFirestore: (
    snapshot: QueryDocumentSnapshot,
    options: SnapshotOptions
  ): Player => {
    const data = snapshot.data(options)
    let p: Player = {
      id: data.id,
      name: data.name,
    }
    return p
  },
}

================
File: src/utils/firestore/converters/playerGame.ts
================
import { PlayerGame } from "../../../models/game"
import { defaultPlayerGame } from "../../../models/default"
import { DEFAULT_DIFFICULTY } from "../../../config/difficulty"
import { Timestamp } from "firebase/firestore"

export const playerGameConverter = {
  toFirestore: (playerGame: PlayerGame) => {
    return {
      id: playerGame.id,
      playerID: playerGame.playerID,
      triviaItem: playerGame.triviaItem,
      guessesMax: playerGame.guessesMax,
      difficulty: playerGame.difficulty || DEFAULT_DIFFICULTY,
      guesses: playerGame.guesses,
      correctAnswer: playerGame.correctAnswer,
      gaveUp: playerGame.gaveUp,
      startDate: playerGame.startDate,
      endDate: playerGame.endDate,
      hintsUsed: playerGame.hintsUsed || {},
      statsProcessed: playerGame.statsProcessed || false,
    }
  },

  fromFirestore: (snapshot: any, options: any): PlayerGame => {
    const data = snapshot.data(options)

    const safeToDate = (field: any): Date => {
      if (field instanceof Timestamp) {
        return field.toDate()
      }
      if (typeof field === "string") {
        return new Date(field)
      }
      return field
    }

    const gameData: Partial<PlayerGame> = {
      ...data,
      difficulty: data.difficulty || DEFAULT_DIFFICULTY,
      startDate: safeToDate(data.startDate),
      endDate: safeToDate(data.endDate),
    }

    return {
      ...defaultPlayerGame,
      ...gameData,
    } as PlayerGame
  },
}

================
File: src/utils/firestore/converters/playerStats.ts
================
import PlayerStats from "../../../models/playerStats"
import { QueryDocumentSnapshot, SnapshotOptions } from "firebase/firestore"

export const playerStatsConverter = {
  toFirestore: (playerStats: PlayerStats) => {
    let ps: PlayerStats = {
      id: playerStats.id,
      currentStreak: playerStats.currentStreak,
      games: playerStats.games,
      maxStreak: playerStats.maxStreak,
      wins: playerStats.wins,
      hintsAvailable: playerStats.hintsAvailable,
      hintsUsedCount: playerStats.hintsUsedCount,
      lastStreakMessageDate: playerStats.lastStreakMessageDate ?? undefined,
      allTimeScore: playerStats.allTimeScore || 0,
    }
    return ps
  },
  fromFirestore: (
    snapshot: QueryDocumentSnapshot,
    options: SnapshotOptions
  ): PlayerStats => {
    const data = snapshot.data(options)
    let ps: PlayerStats = {
      id: data.id,
      currentStreak: data.currentStreak,
      games: data.games,
      maxStreak: data.maxStreak,
      wins: data.wins,
      hintsAvailable: data.hintsAvailable || 3,
      hintsUsedCount: data.hintsUsedCount || 0,
      lastStreakMessageDate: data.lastStreakMessageDate ?? undefined,
      allTimeScore: data.allTimeScore || 0,
    }
    return ps
  },
}

================
File: src/utils/hooks/useExternalLink.ts
================
// src/utils/hooks/useExternalLink.ts

import { useCallback } from "react"
import { Alert } from "react-native"
import * as Linking from "expo-linking"

/**
 * A reusable hook to handle opening any external URL.
 * It encapsulates link availability checks and error handling.
 */
export function useExternalLink() {
  const openLink = useCallback(async (url: string | null | undefined) => {
    if (!url) {
      Alert.alert("Link Unavailable", "No link was found for this item.")
      return
    }

    try {
      const supported = await Linking.canOpenURL(url)
      if (supported) {
        await Linking.openURL(url)
      } else {
        Alert.alert("Unsupported Link", `Unable to open this link: ${url}`)
      }
    } catch (error: any) {
      console.error("Failed to open external link:", error)
      Alert.alert("Link Error", `Could not open the link: ${error.message}`)
    }
  }, [])

  return { openLink }
}

================
File: src/utils/hooks/useGoogleAuth.ts
================
import { useState, useCallback, useMemo, useEffect } from "react"
import {
  GoogleAuthProvider,
  getAuth,
  signInWithCredential,
  signOut,
  User,
} from "firebase/auth"
import * as Google from "expo-auth-session/providers/google"
import Constants from "expo-constants"
import { analyticsService } from "../analyticsService"

export function useGoogleAuth(onAuthStateChange: (user: User | null) => void) {
  const [isLoading, setIsLoading] = useState(false)
  const [authError, setAuthError] = useState<string | null>(null)

  const authConfig = useMemo(
    () => ({
      androidClientId: Constants.expoConfig?.extra?.androidClientId,
      expoClientId: Constants.expoConfig?.extra?.expoClientId,
      iosClientId: Constants.expoConfig?.extra?.iosClientId,
      webClientId: Constants.expoConfig?.extra?.webClientId,
    }),
    []
  )

  const [request, response, promptAsync] = Google.useIdTokenAuthRequest(
    authConfig,
    {}
  )

  useEffect(() => {
    const handleGoogleResponse = async () => {
      if (response?.type === "success") {
        const { id_token } = response.params
        const auth = getAuth()
        const credential = GoogleAuthProvider.credential(id_token)
        try {
          const result = await signInWithCredential(auth, credential)
          setAuthError(null)
          analyticsService.trackGoogleSignInSuccess(result.user.uid)
        } catch (e: any) {
          setAuthError(`Firebase sign-in error: ${e.message}`)
          analyticsService.trackGoogleSignInFailure(e.message)
        }
      } else if (response?.type === "error") {
        const errorMessage = `Google sign-in error: ${response.error?.message}`
        setAuthError(errorMessage)
        analyticsService.trackGoogleSignInFailure(errorMessage)
      }
      setIsLoading(false)
    }

    if (response) {
      handleGoogleResponse()
    }
  }, [response])

  const handleSignIn = useCallback(async () => {
    // CHECK BOTH SOURCES FOR E2E FLAG
    // 1. Constants (from app.config.js)
    // 2. Direct process.env (standard Expo behavior)
    const isE2E =
      Constants.expoConfig?.extra?.isE2E === true ||
      process.env.EXPO_PUBLIC_IS_E2E === "true"

    console.log("[Auth] Sign In attempted. E2E Mode Detected:", isE2E)

    if (isE2E) {
      console.log("[Auth] SKIPPING GOOGLE PROMPT. Using Mock.")
      onAuthStateChange({
        uid: "e2e-test-user",
        displayName: "E2E User",
        email: "e2e@example.com",
        isAnonymous: false,
        emailVerified: true,
        phoneNumber: null,
        photoURL: null,
        providerId: "google.com",
        metadata: {},
        providerData: [],
        refreshToken: "mock-token",
        tenantId: null,
        delete: async () => {},
        getIdToken: async () => "mock-token",
        getIdTokenResult: async () => ({} as any),
        reload: async () => {},
        toJSON: () => ({}),
      } as unknown as User)
      return
    }

    setIsLoading(true)
    setAuthError(null)
    analyticsService.trackGoogleSignInStart()
    try {
      await promptAsync()
    } catch (e: any) {
      console.error("Google prompt error:", e)
      setIsLoading(false)
    }
  }, [promptAsync, onAuthStateChange])

  const handleSignOut = useCallback(async () => {
    setIsLoading(true)
    setAuthError(null)
    try {
      analyticsService.trackSignOut()
      await signOut(getAuth())
    } catch (e: any) {
      setAuthError(`Sign-out error: ${e.message}`)
    } finally {
      setIsLoading(false)
    }
  }, [])

  return { isLoading, authError, handleSignIn, handleSignOut }
}

================
File: src/utils/hooks/useGuessAnimation.ts
================
import { useEffect } from "react"
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSequence,
  withDelay,
  interpolate,
  Easing,
} from "react-native-reanimated"
import { Theme } from "./useStyles"
import { HintInfo } from "../../models/game"

type GuessResult = {
  itemId: number | string
  correct: boolean
  feedback?: string | null
  hintInfo?: HintInfo[] | null
} | null

interface UseGuessAnimationProps {
  isCorrect: boolean
  isLastGuess: boolean
  lastGuessResult: GuessResult
  theme: Theme
}

/**
 * A custom hook to manage the complex animation sequences for a guess row.
 * It encapsulates all `react-native-reanimated` logic, cleaning up the component.
 *
 * @param {UseGuessAnimationProps} props - The props required to determine the animation logic.
 * @returns An object containing the memoized animated styles for the component to use.
 */
export const useGuessAnimation = ({
  isCorrect,
  isLastGuess,
  lastGuessResult,
  theme,
}: UseGuessAnimationProps) => {
  const { colors } = theme

  // --- Shared Values for Animations ---
  const rotate = useSharedValue(0)
  const shakeX = useSharedValue(0)
  const backgroundColor = useSharedValue(theme.colors.surface)
  const feedbackAnim = useSharedValue(0)

  // --- Animation Trigger Effect ---
  useEffect(() => {
    // Reveal animation for every guess row
    rotate.value = withTiming(1, { duration: 600 })

    // Only run the success/failure animations for the most recent guess
    if (isLastGuess && lastGuessResult) {
      if (isCorrect) {
        // Success animation: Brief success color flash
        backgroundColor.value = withSequence(
          withDelay(600, withTiming(colors.success, { duration: 400 })),
          withDelay(1000, withTiming(colors.surface, { duration: 500 }))
        )
      } else {
        // Failure animation sequence:
        // 1. Show feedback overlay
        feedbackAnim.value = withSequence(
          withDelay(700, withTiming(1, { duration: 300 })),
          withDelay(1800, withTiming(0, { duration: 300, easing: Easing.ease }))
        )
        // 2. After feedback, shake the tile and flash error color
        shakeX.value = withSequence(
          withDelay(2800, withTiming(-15, { duration: 60 })),
          withTiming(15, { duration: 120 }),
          withTiming(-15, { duration: 120 }),
          withTiming(0, { duration: 60 })
        )
        backgroundColor.value = withSequence(
          withDelay(2700, withTiming(colors.error, { duration: 150 })),
          withTiming(colors.surface, { duration: 800 })
        )
      }
    }
  }, [
    isLastGuess,
    lastGuessResult,
    isCorrect,
    colors,
    backgroundColor,
    rotate,
    shakeX,
    feedbackAnim,
  ])

  // --- Animated Style Definitions ---
  const animatedTileStyle = useAnimatedStyle(() => {
    const rotateY = interpolate(rotate.value, [0, 1], [180, 360])
    return {
      backgroundColor: backgroundColor.value,
      transform: [
        { perspective: 1000 },
        { rotateY: `${rotateY}deg` },
        { translateX: shakeX.value },
      ],
    }
  })

  const animatedContentStyle = useAnimatedStyle(() => ({
    opacity: rotate.value,
  }))

  const animatedFeedbackStyle = useAnimatedStyle(() => ({
    opacity: feedbackAnim.value,
    transform: [
      {
        scale: interpolate(feedbackAnim.value, [0, 1], [0.8, 1]),
      },
    ],
  }))

  return {
    animatedTileStyle,
    animatedContentStyle,
    animatedFeedbackStyle,
  }
}

================
File: src/utils/hooks/useHintLogic.ts
================
import { useState, useCallback, useEffect, useMemo, useRef } from "react"
import { LayoutAnimation, Platform, UIManager } from "react-native"
import { useGameStore } from "../../state/gameStore"
import { hapticsService } from "../hapticsService"
import { analyticsService } from "../analyticsService"
import { useShallow } from "zustand/react/shallow"
import { DIFFICULTY_MODES } from "../../config/difficulty"
import { Hint } from "../../models/trivia"

if (
  Platform.OS === "android" &&
  UIManager.setLayoutAnimationEnabledExperimental
) {
  UIManager.setLayoutAnimationEnabledExperimental(true)
}

type HintStatus = "available" | "used" | "disabled"

export function useHintLogic() {
  const {
    playerGame,
    isInteractionsDisabled,
    playerStats,
    difficulty,
    useHint,
  } = useGameStore(
    useShallow((state) => ({
      playerGame: state.playerGame,
      isInteractionsDisabled: state.isInteractionsDisabled,
      playerStats: state.playerStats,
      difficulty: state.difficulty,
      useHint: state.useHint,
    }))
  )

  const [showHintOptions, setShowHintOptions] = useState(false)
  const [displayedHintText, setDisplayedHintText] = useState<string | null>(
    null
  )
  const [highlightedHint, setHighlightedHint] = useState<string | null>(null)
  const prevHintsUsedRef = useRef<Partial<Record<string, boolean>>>()

  const hintsAvailable = playerStats?.hintsAvailable ?? 0
  const allHints: Hint[] = playerGame.triviaItem?.hints || []

  const currentHintStrategy = DIFFICULTY_MODES[difficulty].hintStrategy

  const hintStatuses = useMemo(() => {
    const statuses: Record<string, HintStatus> = {}
    const usedHints = playerGame.hintsUsed || {}

    for (const hint of allHints) {
      const type = hint.type
      if (usedHints[type]) {
        statuses[type] = "used"
      } else if (
        currentHintStrategy === "NONE_DISABLED" ||
        currentHintStrategy === "EXTREME_CHALLENGE" ||
        currentHintStrategy === "ALL_REVEALED" ||
        isInteractionsDisabled ||
        (currentHintStrategy === "USER_SPEND" && hintsAvailable <= 0)
      ) {
        statuses[type] = "disabled"
      } else {
        statuses[type] = "available"
      }
    }
    return statuses
  }, [
    playerGame.hintsUsed,
    isInteractionsDisabled,
    hintsAvailable,
    currentHintStrategy,
    allHints,
  ])

  useEffect(() => {
    const currentHints = playerGame.hintsUsed || {}
    const previousHints = prevHintsUsedRef.current || {}

    if (currentHintStrategy !== "IMPLICIT_FEEDBACK") {
      prevHintsUsedRef.current = currentHints
      return
    }

    const newHint = (Object.keys(currentHints) as string[]).find(
      (key) => currentHints[key] && !previousHints[key]
    )

    if (newHint) {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut)
      setShowHintOptions(true)
      setHighlightedHint(newHint)

      const timer = setTimeout(() => setHighlightedHint(null), 2500)
      return () => clearTimeout(timer)
    }

    prevHintsUsedRef.current = currentHints
  }, [playerGame.hintsUsed, currentHintStrategy])

  const getHintText = useCallback(
    (hintType: string): string => {
      if (!playerGame?.triviaItem) return "Hint unavailable"

      const hint = playerGame.triviaItem.hints.find((h) => h.type === hintType)
      if (!hint) return "Hint unavailable"

      // Handle special formatting for different hint types
      if (
        hint.type === "actors" &&
        Array.isArray(hint.value) &&
        hint.value.length > 0
      ) {
        return hint.value[0]?.name || "Actor unavailable"
      }

      return hint.value?.toString() || `${hint.label} unavailable`
    },
    [playerGame.triviaItem]
  )

  const handleHintSelection = useCallback(
    (hintType: string) => {
      if (currentHintStrategy !== "USER_SPEND") return

      hapticsService.medium()

      const status = hintStatuses[hintType]
      setShowHintOptions(false)
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut)
      setDisplayedHintText(getHintText(hintType))

      if (status === "available") {
        useHint(hintType)
      }
    },
    [hintStatuses, currentHintStrategy, getHintText, useHint]
  )

  useEffect(() => {
    if (currentHintStrategy !== "USER_SPEND") {
      setDisplayedHintText(null)
    }
  }, [playerGame.guesses.length, currentHintStrategy])

  const handleToggleHintOptions = useCallback(() => {
    if (currentHintStrategy !== "USER_SPEND") return

    hapticsService.light()

    if (
      hintsAvailable <= 0 &&
      !Object.values(playerGame.hintsUsed || {}).some(Boolean)
    ) {
      return
    }

    if (!showHintOptions) {
      analyticsService.trackHintOptionsToggled()
      setDisplayedHintText(null)
    }
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut)
    setShowHintOptions((prevShow) => !prevShow)
  }, [
    showHintOptions,
    hintsAvailable,
    playerGame.hintsUsed,
    currentHintStrategy,
  ])

  const hintLabelText = useMemo(() => {
    if (isInteractionsDisabled) return "Game Over"

    switch (currentHintStrategy) {
      case "ALL_REVEALED":
        return "All Clues Revealed"
      case "USER_SPEND": {
        const usedHintsCount = Object.values(playerGame.hintsUsed || {}).filter(
          (v) => v
        ).length
        const effectiveHints = Math.max(0, hintsAvailable)

        if (effectiveHints <= 0 && usedHintsCount === 0) {
          return ""
        }
        return `Need a Hint? (${effectiveHints} available)`
      }
      case "IMPLICIT_FEEDBACK":
        return "Hints are revealed by successful guesses!"
      case "NONE_DISABLED":
      case "EXTREME_CHALLENGE":
        return ""
      default:
        return ""
    }
  }, [
    hintsAvailable,
    isInteractionsDisabled,
    playerGame.hintsUsed,
    currentHintStrategy,
  ])

  const isToggleDisabled =
    isInteractionsDisabled || currentHintStrategy !== "USER_SPEND"

  return {
    showHintOptions,
    displayedHintText,
    hintLabelText,
    isToggleDisabled,
    hintStatuses,
    highlightedHint,
    allHints: allHints,
    getHintText,
    handleToggleHintOptions,
    handleHintSelection,
  }
}

================
File: src/utils/hooks/useSkeletonAnimation.ts
================
import { useEffect } from "react"
import {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  Easing,
} from "react-native-reanimated"

export const useSkeletonAnimation = (
  initialValue = 1,
  finalValue = 0.6,
  duration = 800
) => {
  const opacity = useSharedValue(initialValue)

  useEffect(() => {
    opacity.value = withRepeat(
      withTiming(finalValue, {
        duration: duration,
        easing: Easing.inOut(Easing.ease),
      }),
      -1,
      true
    )
  }, [opacity, initialValue, finalValue, duration])

  const animatedStyle = useAnimatedStyle(() => {
    return {
      opacity: opacity.value,
    }
  })

  return animatedStyle
}

================
File: src/utils/hooks/useStyles.ts
================
import { useMemo } from "react"
import { StyleSheet } from "react-native"
import { useTheme } from "../../contexts/themeContext"
import {
  spacing,
  getTypography,
  shadows,
  responsive,
} from "../../styles/global"

/**
 * Consolidates all design system tokens into a single object for use in style factories.
 * This is the heart of the themed styling system.
 */
export const useThemeTokens = () => {
  const { colors, colorScheme } = useTheme()
  return {
    colors,
    spacing,
    typography: getTypography(colors),
    shadows,
    responsive,
    colorScheme,
  }
}

/**
 * The complete theme object type, containing all design tokens.
 */
export type Theme = ReturnType<typeof useThemeTokens>

/**
 * Type for a function that takes the theme object and returns a StyleSheet.
 */
type StyleFactory<T> = (theme: Theme) => T

/**
 * A custom hook to create themed and memoized stylesheets.
 * This hook replaces the old pattern of `useMemo(() => getStyles(colors), [colors])`
 * and provides the full theme object to the style factory.
 *
 * @param styleFactory A function that receives the full theme object and returns a StyleSheet.
 * @returns A memoized StyleSheet object that updates when the theme changes.
 */
export const useStyles = <T extends StyleSheet.NamedStyles<T>>(
  styleFactory: StyleFactory<T>
): T => {
  const theme = useThemeTokens()

  // useMemo ensures that StyleSheet.create is only called when the theme or factory function changes.
  return useMemo(
    () => StyleSheet.create(styleFactory(theme)),
    [theme, styleFactory]
  )
}

================
File: src/utils/analyticsService.ts
================
import {
  logEvent as firebaseLogEvent,
  setUserId,
  setUserProperties,
  Analytics,
} from "firebase/analytics"
import { analytics } from "../config/firebase"

// A type-safe wrapper for logging events
const logEvent = async (eventName: string, params?: { [key: string]: any }) => {
  // Ensure analytics is initialized before logging
  if (!analytics) {
    return
  }

  try {
    if (__DEV__) {
      // Sanitize params for logging to avoid potential issues in dev console
      const sanitizedParams = params ? JSON.parse(JSON.stringify(params)) : ""
      console.log(`[ANALYTICS] Event: ${eventName}`, sanitizedParams)
    }
    // Use the initialized analytics instance
    await firebaseLogEvent(analytics as Analytics, eventName, params)
  } catch (error) {
    console.error(`[ANALYTICS] Error logging event ${eventName}:`, error)
  }
}

export const analyticsService = {
  // --- User Identification ---
  identifyUser: (userId: string, properties?: { [key: string]: any }) => {
    if (!analytics) return
    setUserId(analytics as Analytics, userId)
    if (properties) {
      setUserProperties(analytics as Analytics, properties)
    }
  },

  // --- Onboarding ---
  trackOnboardingStarted: () => logEvent("onboarding_started"),
  trackOnboardingCompleted: () => logEvent("onboarding_completed"),

  // --- Game Lifecycle ---
  trackGameStart: (movieId: number, movieTitle: string) =>
    logEvent("game_start", { movie_id: movieId, movie_title: movieTitle }),
  trackGameWin: (guesses: number, hintsUsed: number) =>
    logEvent("game_win", {
      guesses_taken: guesses,
      hints_used_count: hintsUsed,
    }),
  trackGameLose: (hintsUsed: number) =>
    logEvent("game_lose", { hints_used_count: hintsUsed }),
  trackGameGiveUp: (guessesMade: number, hintsUsed: number) =>
    logEvent("game_give_up", {
      guesses_made: guessesMade,
      hints_used_count: hintsUsed,
    }),

  // --- User Actions ---
  trackGuessMade: (
    guessNumber: number,
    isCorrect: boolean,
    guessedMovieId: number,
    guessedMovieTitle: string
  ) =>
    logEvent("guess_made", {
      guess_number: guessNumber,
      is_correct: isCorrect,
      guessed_movie_id: guessedMovieId,
      guessed_movie_title: guessedMovieTitle,
    }),
  trackHintUsed: (
    hintType: string,
    guessNumber: number,
    hintsRemaining: number
  ) =>
    logEvent("hint_used", {
      hint_type: hintType,
      guess_number_before_hint: guessNumber,
      hints_remaining: hintsRemaining,
    }),
  trackHintOptionsToggled: () => logEvent("hint_options_toggled"),
  trackShareResults: (outcome: "win" | "lose" | "give_up") =>
    logEvent("share_results_tapped", { game_outcome: outcome }),
  trackImdbLinkTapped: (movieTitle: string) =>
    logEvent("imdb_link_tapped", { movie_title: movieTitle }),
  trackActorLinkTapped: (actorName: string) =>
    logEvent("actor_link_tapped", { actor_name: actorName }),

  // --- Auth ---
  trackGoogleSignInStart: () => logEvent("google_signin_start"),
  trackGoogleSignInSuccess: (userId: string) => {
    logEvent("login", { method: "google" })
    logEvent("google_signin_success")
    analyticsService.identifyUser(userId, { sign_in_method: "google" })
  },
  trackGoogleSignInFailure: (error: string) =>
    logEvent("google_signin_failure", {
      error_message: error.substring(0, 100),
    }),
  trackAnonymousSignIn: (userId: string) => {
    logEvent("login", { method: "anonymous" })
    analyticsService.identifyUser(userId, { sign_in_method: "anonymous" })
  },
  trackSignOut: () => logEvent("sign_out"),

  // --- App Health ---
  trackNetworkStatusChange: (isConnected: boolean) =>
    logEvent("network_status_change", { is_connected: isConnected }),
  trackErrorBoundary: (errorMessage: string) =>
    logEvent("error_boundary_triggered", {
      error_message: errorMessage.substring(0, 100),
    }),
}

================
File: src/utils/guessFeedbackUtils.ts
================
import { TriviaItem, Hint } from "../models/trivia"

interface ImplicitHintResult {
  feedback: string | null
  revealedHints: Partial<Record<string, boolean>>
  hintInfo: Hint[] | null
}

const getHintValue = (type: string, item: TriviaItem): any => {
  return item.hints.find((h) => h.type === type)?.value
}

export function generateImplicitHint(
  guessedItem: TriviaItem,
  correctItem: TriviaItem,
  usedHints: Partial<Record<string, boolean>> = {}
): ImplicitHintResult {
  const result: ImplicitHintResult = {
    feedback: null,
    revealedHints: {},
    hintInfo: [],
  }

  if (!guessedItem || !correctItem) {
    return {
      feedback: "An unexpected error occurred with the trivia data.",
      revealedHints: {},
      hintInfo: null,
    }
  }

  const hintsFound: Hint[] = []
  let newHintRevealed = false
  let firstNewMatchMessage: string | null = null

  for (const correctHint of correctItem.hints) {
    const guessedHintValue = getHintValue(correctHint.type, guessedItem)
    if (guessedHintValue === null || guessedHintValue === undefined) continue

    let isMatch = false

    if (Array.isArray(correctHint.value)) {
      const correctIds = new Set(
        (correctHint.value || []).map((item: any) => item.id)
      )
      const guessedIds = new Set(
        (guessedHintValue || []).map((item: any) => item.id)
      )
      if (correctIds.size > 0 && guessedIds.size > 0) {
        for (const id of correctIds) {
          if (guessedIds.has(id)) {
            isMatch = true
            break
          }
        }
      }
    } else if (typeof correctHint.value === "object" && correctHint.value?.id) {
      isMatch = guessedHintValue?.id === correctHint.value.id
    } else {
      isMatch = guessedHintValue === correctHint.value
    }

    if (isMatch) {
      const fullCorrectHint = correctItem.hints.find(
        (h) => h.type === correctHint.type
      )
      if (fullCorrectHint) {
        hintsFound.push(fullCorrectHint)
      }

      if (!usedHints[correctHint.type]) {
        result.revealedHints[correctHint.type] = true
        newHintRevealed = true
        if (!firstNewMatchMessage) {
          firstNewMatchMessage = `You're on the right track with the ${correctHint.label}! (Hint Revealed)`
        }
      }
    }
  }

  result.hintInfo = hintsFound.length > 0 ? hintsFound : null

  if (newHintRevealed) {
    result.feedback = firstNewMatchMessage
  } else if (hintsFound.length > 0) {
    result.feedback = "You're getting warmer! Keep guessing."
  } else {
    result.feedback = "Not quite! Try again."
  }

  return result
}

================
File: src/utils/hapticsService.ts
================
import { Platform } from "react-native"
import * as Haptics from "expo-haptics"

// Wrapper for type-safe haptic feedback; silent on web.
const trigger = (feedbackType: any) => {
  if (Platform.OS !== "web") Haptics.impactAsync(feedbackType)
}
const notify = (notificationType: any) => {
  if (Platform.OS !== "web") Haptics.notificationAsync(notificationType)
}

export const hapticsService = {
  // Light tap for minor interactions
  light: () => trigger(Haptics.ImpactFeedbackStyle.Light),
  // Medium tap for core actions like guess submit or hint reveal
  medium: () => trigger(Haptics.ImpactFeedbackStyle.Medium),
  // Heavy tap for win or loss
  heavy: () => trigger(Haptics.ImpactFeedbackStyle.Heavy),
  // Use notify for major status updates (win/lose)
  success: () => notify(Haptics.NotificationFeedbackType.Success),
  warning: () => notify(Haptics.NotificationFeedbackType.Warning),
  error: () => notify(Haptics.NotificationFeedbackType.Error),
}

================
File: src/utils/scoreUtils.ts
================
import { PlayerGame } from "../models/game"
import { DIFFICULTY_MODES } from "../config/difficulty"

const MAX_SCORE = 1000
const HINT_PENALTY = 50

export function calculateScore(playerGame: PlayerGame): number {
  if (!playerGame.correctAnswer) {
    return 0
  }

  const { difficulty, guesses, guessesMax, hintsUsed } = playerGame
  const guessesUsed = guesses.length

  const difficultyMode = DIFFICULTY_MODES[difficulty]
  if (!difficultyMode) {
    console.error(
      `Invalid difficulty: ${difficulty} found in score calculation.`
    )
    return 0
  }

  // 1. Determine the maximum possible score for this difficulty (a 1-guess win).
  const maxScoreForDifficulty = MAX_SCORE * difficultyMode.scoreMultiplier

  // 2. Determine the pool of points available for performance.
  const performancePointsPool =
    maxScoreForDifficulty * difficultyMode.scoreRangePercentage

  // 3. The base score is the minimum you get for winning (i.e., on the last guess).
  const baseWinPoints = maxScoreForDifficulty - performancePointsPool

  // 4. Calculate a performance factor (0.0 for last guess, 1.0 for first guess).
  // Avoid division by zero if guessesMax is 1.
  const performanceFactor =
    guessesMax > 1 ? (guessesMax - guessesUsed) / (guessesMax - 1) : 1
  const earnedPerformancePoints = performancePointsPool * performanceFactor

  // 5. Calculate hint penalties (only applicable in Easy mode).
  let hintPenaltyTotal = 0
  if (difficulty === "LEVEL_2" && hintsUsed) {
    const manualHintsCount = Object.values(hintsUsed).filter(Boolean).length
    hintPenaltyTotal = manualHintsCount * HINT_PENALTY
  }

  // 6. Final score is the base for winning + performance bonus - penalties.
  const finalScore = Math.max(
    0,
    Math.round(baseWinPoints + earnedPerformancePoints - hintPenaltyTotal)
  )

  return finalScore
}

================
File: src/utils/shareUtils.ts
================
import { Share } from "react-native"
import { PlayerGame } from "../models/game"
import { analyticsService } from "./analyticsService"
import { hapticsService } from "./hapticsService"
import { calculateScore } from "./scoreUtils"
import { GAME_MODE_CONFIG } from "../config/difficulty"
import { useGameStore } from "../state/gameStore"

export const generateShareMessage = (playerGame: PlayerGame): string => {
  const appUrl = "https://talkie-trivia.com"
  const gameDate =
    playerGame.startDate instanceof Date
      ? playerGame.startDate
      : new Date(playerGame.startDate)

  // Get the current game mode to generate a context-aware message.
  const gameMode = useGameStore.getState().gameMode
  const config = GAME_MODE_CONFIG[gameMode]

  const dateString = gameDate.toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  })
  const title = `${config.shareResultTitle}\n ${dateString}`

  let resultLine = ""
  let grid = ""
  const guessCount = playerGame.guesses.length

  if (playerGame.correctAnswer) {
    resultLine = ` Guessed in ${guessCount}/${playerGame.guessesMax} tries!`
    grid = "".repeat(guessCount - 1) + ""
  } else if (playerGame.gaveUp) {
    resultLine = ` Gave up after ${guessCount} guess${
      guessCount === 1 ? "" : "es"
    }.`
    grid = "".repeat(guessCount) + ""
  } else {
    resultLine = ` Didn't guess the item!`
    grid = "".repeat(playerGame.guessesMax).trim()
  }

  const score = calculateScore(playerGame)
  const scoreLine = `Score:  ${score}`

  return `${title}\n${resultLine}\n\n${grid}\n${scoreLine}\n\nPlay at ${appUrl}`
}

export const shareGameResult = async (playerGame: PlayerGame) => {
  hapticsService.medium()
  const outcome = playerGame.correctAnswer
    ? "win"
    : playerGame.gaveUp
    ? "give_up"
    : "lose"
  analyticsService.trackShareResults(outcome)

  const message = generateShareMessage(playerGame)

  try {
    await Share.share(
      {
        message,
        title: "Talkie Trivia Results",
      },
      {
        dialogTitle: "Share your Talkie Trivia results!",
      }
    )
  } catch (error: any) {
    if (
      error.name === "AbortError" ||
      error.message.includes("Share Canceled")
    ) {
      console.log("Share action was canceled by the user.")
      return
    }
    throw error
  }
}

================
File: src/utils/stringUtils.ts
================
/**
 * Normalizes a string by converting accented characters to their base equivalent
 * (e.g., '' becomes 'e', '' becomes 'u').
 * Used primarily for making searches case and diacritic-insensitive.
 * @param str The string to normalize.
 * @returns The normalized string.
 */
export const normalizeSearchString = (str: string): string => {
  if (!str) return ""
  // Uses NFD (Normalization Form D) to decompose characters into base and diacritics,
  // then uses a regex to remove the diacritics (Unicode range P)
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "")
}

================
File: utils/basicMovies/basicMovies.go
================
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strings"
)

type BasicMovie struct {
	ID          int    `json:"id"`
	Title       string `json:"title"`
	ReleaseDate string `json:"release_date"`
	PosterPath  string `json:"poster_path"`
}

type DetailedMovie struct {
	Adult               bool        `json:"adult"`
	BackdropPath        string      `json:"backdrop_path"`
	BelongsToCollection interface{} `json:"belongs_to_collection"`
	Budget              int         `json:"budget"`
	Genres              []struct {
		ID   int    `json:"id"`
		Name string `json:"name"`
	} `json:"genres"`
	Homepage            string  `json:"homepage"`
	ID                  int     `json:"id"`
	ImdbID              string  `json:"imdb_id"`
	OriginalLanguage    string  `json:"original_language"`
	OriginalTitle       string  `json:"original_title"`
	Overview            string  `json:"overview"`
	Popularity          float64 `json:"popularity"`
	PosterPath          string  `json:"poster_path"`
	ProductionCompanies []struct {
		ID            int    `json:"id"`
		LogoPath      string `json:"logo_path"`
		Name          string `json:"name"`
		OriginCountry string `json:"origin_country"`
	} `json:"production_companies"`
	ProductionCountries []struct {
		Iso31661 string `json:"iso_3166_1"`
		Name     string `json:"name"`
	} `json:"production_countries"`
	ReleaseDate     string `json:"release_date"`
	Revenue         int    `json:"revenue"`
	Runtime         int    `json:"runtime"`
	SpokenLanguages []struct {
		EnglishName string `json:"english_name"`
		Iso6391     string `json:"iso_639_1"`
		Name        string `json:"name"`
	} `json:"spoken_languages"`
	Status      string  `json:"status"`
	Tagline     string  `json:"tagline"`
	Title       string  `json:"title"`
	Video       bool    `json:"video"`
	VoteAverage float64 `json:"vote_average"`
	VoteCount   int     `json:"vote_count"`
}

func main() {
	jsonFile, err := os.Open("../../data/movies.json")
	if err != nil {
		fmt.Println(err)
	}
	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)

	var movies []DetailedMovie
	json.Unmarshal([]byte(byteValue), &movies)

	basicMovies := []BasicMovie{}
	for _, movie := range movies {
		if movie.Runtime > 70 &&
			movie.Popularity > 7 &&
			movie.VoteCount > 100 {
			stringYearArr := strings.Split(movie.ReleaseDate, "-")
			year := stringYearArr[0]
			id := movie.ID
			title := movie.Title

			for _, m2 := range movies {
				if m2.Title == title && m2.ID != id {
					title = title + " (" + year + ")"
				}
			}

			m := BasicMovie{
				ID:          id,
				Title:       title,
				ReleaseDate: movie.ReleaseDate,
				PosterPath:  movie.PosterPath,
			}
			basicMovies = append(basicMovies, m)
		}

	}

	sort.Slice(basicMovies, func(i, j int) bool {
		return basicMovies[i].Title < basicMovies[j].Title
	})

	bm, err := json.MarshalIndent(basicMovies, "", "  ")
	if err != nil {
		log.Fatal(err)
	}

	f, err := os.Create("basicMovies.json")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	_, err = f.WriteString(string(bm))
	if err != nil {
		log.Fatal(err)
	}
}

================
File: utils/basicMovies/go.mod
================
module basicMovies

go 1.23.1

================
File: utils/credits/credits.go
================
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
)

type TMDBCreditsResponse struct {
	ID   int `json:"id"`
	Cast []struct {
		Adult              bool    `json:"adult"`
		Gender             int     `json:"gender"`
		ID                 int     `json:"id"`
		KnownForDepartment string  `json:"known_for_department"`
		Name               string  `json:"name"`
		OriginalName       string  `json:"original_name"`
		Popularity         float64 `json:"popularity"`
		ProfilePath        string  `json:"profile_path"`
		CastID             int     `json:"cast_id"`
		Character          string  `json:"character"`
		CreditID           string  `json:"credit_id"`
		Order              int     `json:"order"`
	} `json:"cast"`
	Crew []struct {
		Adult              bool    `json:"adult"`
		Gender             int     `json:"gender"`
		ID                 int     `json:"id"`
		KnownForDepartment string  `json:"known_for_department"`
		Name               string  `json:"name"`
		OriginalName       string  `json:"original_name"`
		Popularity         float64 `json:"popularity"`
		ProfilePath        string  `json:"profile_path"`
		CreditID           string  `json:"credit_id"`
		Department         string  `json:"department"`
		Job                string  `json:"job"`
	} `json:"crew"`
}

type Actor struct {
	ID          int          `json:"id"`
	MovieCount  int          `json:"movie_count"`
	MovieOrders []MovieOrder `json:"movie_orders"`
	Name        string       `json:"name"`
	Popularity  float64      `json:"popularity"`
	ProfilePath string       `json:"profile_path"`
}

type Director struct {
	ID          int     `json:"id"`
	MovieCount  int     `json:"movie_count"`
	Name        string  `json:"name"`
	Popularity  float64 `json:"popularity"`
	ProfilePath string  `json:"profile_path"`
}

type MovieActor struct {
	ID          int     `json:"id"`
	Order       int     `json:"order"`
	Name        string  `json:"name"`
	Popularity  float64 `json:"popularity"`
	ProfilePath string  `json:"profile_path"`
}

type MovieDirector struct {
	ID          int     `json:"id"`
	Name        string  `json:"name"`
	Popularity  float64 `json:"popularity"`
	ProfilePath string  `json:"profile_path"`
}

type MovieOrder struct {
	ID    int `json:"id"`
	Order int `json:"order"`
}

func main() {
	jsonFile, err := os.Open("../../data/credits.json")
	if err != nil {
		fmt.Println(err)
	}
	defer jsonFile.Close()

	byteValue, _ := io.ReadAll(jsonFile)

	var movies []TMDBCreditsResponse
	json.Unmarshal([]byte(byteValue), &movies)

	actors := make(map[int]Actor)
	directors := make(map[int]Director)
	movieActors := make(map[int][]MovieActor)
	movieDirectors := make(map[int]MovieDirector)
	for _, movie := range movies {
		for _, cast := range movie.Cast {
			movieOrder := MovieOrder{
				ID:    movie.ID,
				Order: cast.Order,
			}
			actor, exist := actors[cast.ID]
			if exist {
				actor.MovieOrders = append(actor.MovieOrders, movieOrder)
				actor.MovieCount = len(actor.MovieOrders)
				actors[cast.ID] = actor
			} else {
				actors[cast.ID] = Actor{
					ID:          cast.ID,
					MovieCount:  1,
					MovieOrders: []MovieOrder{movieOrder},
					Name:        cast.Name,
					Popularity:  cast.Popularity,
					ProfilePath: cast.ProfilePath,
				}
			}
		}
		for _, crew := range movie.Crew {
			if crew.Job != "Director" {
				continue
			}
			director, exist := directors[crew.ID]
			if exist {
				director.MovieCount++
				directors[crew.ID] = director
			} else {
				directors[crew.ID] = Director{
					ID:          crew.ID,
					MovieCount:  1,
					Name:        crew.Name,
					Popularity:  crew.Popularity,
					ProfilePath: crew.ProfilePath,
				}
			}
		}
	}

	for _, movie := range movies {
		for _, cast := range movie.Cast {
			movieActor := MovieActor{
				ID:          cast.ID,
				Name:        cast.Name,
				Order:       cast.Order,
				Popularity:  cast.Popularity,
				ProfilePath: cast.ProfilePath,
			}
			ma, exist := movieActors[movie.ID]
			if exist {
				ma = append(ma, movieActor)
				movieActors[movie.ID] = ma
			} else {
				movieActors[movie.ID] = []MovieActor{movieActor}
			}
		}
		for _, crew := range movie.Crew {
			if crew.Job != "Director" {
				continue
			}
			movieDirectors[movie.ID] = MovieDirector{
				ID:          crew.ID,
				Name:        crew.Name,
				Popularity:  crew.Popularity,
				ProfilePath: crew.ProfilePath,
			}
		}
	}

	popularActors := make(map[int]Actor)
	for _, a := range actors {
		if a.Popularity > 9.0 || a.MovieCount > 9 {
			popularActors[a.ID] = a
			continue
		}
		for _, m := range a.MovieOrders {
			if m.Order == 0 {
				popularActors[a.ID] = a
				continue
			}
		}
	}

	popularDirectors := make(map[int]Director)
	for _, d := range directors {
		if d.Popularity > 9.0 || d.MovieCount > 9 {
			popularDirectors[d.ID] = d
			continue
		}
	}

	actorMostMovies := Actor{}
	for _, pa := range popularActors {
		if pa.MovieCount > actorMostMovies.MovieCount {
			actorMostMovies = pa
		}
	}

	pd, err := json.MarshalIndent(popularDirectors, "", "  ")
	if err != nil {
		log.Fatal(err)
	}

	f, err := os.Create("popularDirectors.json")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	_, err = f.WriteString(string(pd))
	if err != nil {
		log.Fatal(err)
	}

	pa, err := json.MarshalIndent(popularActors, "", "  ")
	if err != nil {
		log.Fatal(err)
	}

	f, err = os.Create("popularActors.json")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	_, err = f.WriteString(string(pa))
	if err != nil {
		log.Fatal(err)
	}

	md, err := json.MarshalIndent(movieDirectors, "", "  ")
	if err != nil {
		log.Fatal(err)
	}

	f, err = os.Create("movieDirectors.json")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	_, err = f.WriteString(string(md))
	if err != nil {
		log.Fatal(err)
	}

	ma, err := json.MarshalIndent(movieActors, "", "  ")
	if err != nil {
		log.Fatal(err)
	}

	f, err = os.Create("movieActors.json")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	_, err = f.WriteString(string(ma))
	if err != nil {
		log.Fatal(err)
	}
}

================
File: utils/credits/go.mod
================
module credits

go 1.23.1

================
File: utils/data-pipeline/go.mod
================
module data-pipeline

go 1.23.1

================
File: utils/data-pipeline/main.go
================
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"
)

const (
	tmdbBaseURL     = "https://api.themoviedb.org/3"
	pagesToFetch    = 500
	outputDir       = "../../src/data"
	secretsFilePath = "../secrets.json"
)

type TMDBDiscoverResponse struct {
	Results []struct {
		ID int `json:"id"`
	} `json:"results"`
}

type TMDBDetailsResponse struct {
	ID          int     `json:"id"`
	ImdbID      string  `json:"imdb_id"`
	Title       string  `json:"title"`
	Overview    string  `json:"overview"`
	Tagline     string  `json:"tagline"`
	PosterPath  string  `json:"poster_path"`
	ReleaseDate string  `json:"release_date"`
	Popularity  float64 `json:"popularity"`
	VoteAverage float64 `json:"vote_average"`
	VoteCount   int     `json:"vote_count"`
	Runtime     int     `json:"runtime"`
	Genres      []Genre `json:"genres"`
}

type TMDBCreditsResponse struct {
	Cast []struct {
		ID          int     `json:"id"`
		Name        string  `json:"name"`
		Popularity  float64 `json:"popularity"`
		ProfilePath string  `json:"profile_path"`
		Order       int     `json:"order"`
	} `json:"cast"`
	Crew []struct {
		ID          int     `json:"id"`
		Name        string  `json:"name"`
		Popularity  float64 `json:"popularity"`
		ProfilePath string  `json:"profile_path"`
		Job         string  `json:"job"`
	} `json:"crew"`
}

type Movie struct {
	Actors           []MovieActor  `json:"actors"`
	Director         MovieDirector `json:"director"`
	Genres           []Genre       `json:"genres"`
	ID               int           `json:"id"`
	ImdbID           string        `json:"imdb_id"`
	OriginalOverview string        `json:"original_overview"`
	Overview         string        `json:"overview"`
	Popularity       float64       `json:"popularity"`
	PosterPath       string        `json:"poster_path"`
	ReleaseDate      string        `json:"release_date"`
	Tagline          string        `json:"tagline"`
	Title            string        `json:"title"`
	VoteAverage      float64       `json:"vote_average"`
	VoteCount        int           `json:"vote_count"`
}

type BasicMovie struct {
	ID          int    `json:"id"`
	Title       string `json:"title"`
	ReleaseDate string `json:"release_date"`
	PosterPath  string `json:"poster_path"`
}

type Genre struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

type MovieActor struct {
	ID          int     `json:"id"`
	Order       int     `json:"order"`
	Name        string  `json:"name"`
	Popularity  float64 `json:"popularity"`
	ProfilePath string  `json:"profile_path"`
}

type MovieDirector struct {
	ID          int     `json:"id"`
	Name        string  `json:"name"`
	Popularity  float64 `json:"popularity"`
	ProfilePath string  `json:"profile_path"`
}

var stopWords = map[string]bool{
	"the": true, "a": true, "an": true, "of": true, "in": true, "and": true, "or": true,
	"&": true, "to": true, "is": true, "on": true, "for": true, "with": true, "s": true,
	"from": true, "by": true, "at": true, "part": true, "i": true, "ii": true, "iii": true,
}

func sanitizeOverview(title, overview string, topCast []MovieActor) string {
	removeDiacritics := func(s string) string {
		s = strings.ReplaceAll(s, "", "e")
		s = strings.ReplaceAll(s, "", "E")
		s = strings.ReplaceAll(s, "", "a")
		s = strings.ReplaceAll(s, "", "A")
		return s
	}

	sensitiveWords := make(map[string]bool)

	titleWords := regexp.MustCompile(`[a-zA-Z0-9']+`).FindAllString(strings.ToLower(removeDiacritics(title)), -1)
	for _, word := range titleWords {
		if !stopWords[word] && len(word) > 2 {
			sensitiveWords[word] = true
		}
	}

	if len(topCast) > 0 {
		mainActor := topCast[0]
		nameParts := strings.Fields(mainActor.Name)
		for _, part := range nameParts {
			lowerPart := strings.ToLower(part)
			if !stopWords[lowerPart] && len(lowerPart) > 2 {
				normalizedPart := removeDiacritics(lowerPart)
				sensitiveWords[normalizedPart] = true
				if normalizedPart != lowerPart {
					sensitiveWords[lowerPart] = true
				}
			}
		}
	}

	if len(sensitiveWords) == 0 {
		return overview
	}

	sanitizedOverview := overview
	placeholder := "[Protagonist]"

	for word := range sensitiveWords {
		regexToReplace := regexp.MustCompile(`(?i)\b` + regexp.QuoteMeta(word) + `\b`)
		sanitizedOverview = regexToReplace.ReplaceAllString(sanitizedOverview, placeholder)
	}

	fullOriginalTitleRegex := regexp.MustCompile(`(?i)\b` + regexp.QuoteMeta(title) + `\b`)
	sanitizedOverview = fullOriginalTitleRegex.ReplaceAllString(sanitizedOverview, placeholder)

	return sanitizedOverview
}

func getTMDBKey() (string, error) {
	type Config struct {
		TMDBKey string `json:"TMDBKey"`
	}
	configFile, err := os.Open(secretsFilePath)
	if err != nil {
		return "", fmt.Errorf("could not open secrets file at %s: %w", secretsFilePath, err)
	}
	defer configFile.Close()

	secretsBytes, err := io.ReadAll(configFile)
	if err != nil {
		return "", fmt.Errorf("could not read secrets file: %w", err)
	}

	var config Config
	if err := json.Unmarshal(secretsBytes, &config); err != nil {
		return "", fmt.Errorf("could not parse secrets file: %w", err)
	}

	if config.TMDBKey == "" {
		return "", fmt.Errorf("TMDBKey is missing from secrets.json")
	}
	return config.TMDBKey, nil
}

func fetchFromAPI(client *http.Client, endpoint string, apiKey string, params map[string]string) ([]byte, error) {
	baseURL, err := url.Parse(tmdbBaseURL + endpoint)
	if err != nil {
		return nil, err
	}

	q := baseURL.Query()
	q.Set("api_key", apiKey)
	for key, val := range params {
		q.Set(key, val)
	}
	baseURL.RawQuery = q.Encode()

	resp, err := client.Get(baseURL.String())
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API request failed with status: %s", resp.Status)
	}

	return io.ReadAll(resp.Body)
}

func writeJSONFile(filePath string, data interface{}) error {
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(data)
}

func main() {
	log.Println("Starting data generation pipeline...")

	apiKey, err := getTMDBKey()
	if err != nil {
		log.Fatalf("Error getting API key: %v", err)
	}

	client := &http.Client{Timeout: 10 * time.Second}
	var finalMovies []Movie
	var finalBasicMovies []BasicMovie
	seenIDs := make(map[int]bool)

	log.Println("Fetching movie IDs from TMDB discover endpoint...")
	for page := 1; page <= pagesToFetch; page++ {
		log.Printf("Fetching page %d of %d...", page, pagesToFetch)
		discoverParams := map[string]string{
			"page":             strconv.Itoa(page),
			"include_adult":    "false",
			"include_video":    "false",
			"language":         "en-US",
			"sort_by":          "popularity.desc",
			"with_runtime.gte": "75",
			"vote_count.gte":   "400",
		}

		body, err := fetchFromAPI(client, "/discover/movie", apiKey, discoverParams)
		if err != nil {
			log.Printf("Warning: Failed to fetch page %d: %v", page, err)
			continue
		}

		var discoverResp TMDBDiscoverResponse
		if err := json.Unmarshal(body, &discoverResp); err != nil {
			log.Printf("Warning: Failed to parse discover response for page %d: %v", page, err)
			continue
		}

		for _, movieStub := range discoverResp.Results {
			movieID := movieStub.ID
			if seenIDs[movieID] {
				continue
			}
			seenIDs[movieID] = true

			log.Printf("Processing movie ID: %d", movieID)

			detailsBody, err := fetchFromAPI(client, fmt.Sprintf("/movie/%d", movieID), apiKey, nil)
			if err != nil {
				log.Printf("Warning: Failed to fetch details for movie %d: %v", movieID, err)
				continue
			}
			var details TMDBDetailsResponse
			if err := json.Unmarshal(detailsBody, &details); err != nil {
				log.Printf("Warning: Failed to unmarshal details for movie %d: %v", movieID, err)
				continue
			}

			creditsBody, err := fetchFromAPI(client, fmt.Sprintf("/movie/%d/credits", movieID), apiKey, nil)
			if err != nil {
				log.Printf("Warning: Failed to fetch credits for movie %d: %v", movieID, err)
				continue
			}
			var credits TMDBCreditsResponse
			if err := json.Unmarshal(creditsBody, &credits); err != nil {
				log.Printf("Warning: Failed to unmarshal credits for movie %d: %v", movieID, err)
				continue
			}

			if len(details.Overview) >= 400 || len(details.Overview) <= 60 ||
				details.Runtime <= 75 || details.Popularity <= 10 || details.VoteAverage <= 4.9 || details.VoteCount <= 400 {
				continue
			}

			var director MovieDirector
			for _, crew := range credits.Crew {
				if crew.Job == "Director" {
					director = MovieDirector{
						ID:          crew.ID,
						Name:        crew.Name,
						Popularity:  crew.Popularity,
						ProfilePath: crew.ProfilePath,
					}
					break
				}
			}

			var actors []MovieActor
			sort.Slice(credits.Cast, func(i, j int) bool {
				return credits.Cast[i].Order < credits.Cast[j].Order
			})

			for _, castMember := range credits.Cast {
				if castMember.Order < 5 {
					actors = append(actors, MovieActor{
						ID:          castMember.ID,
						Order:       castMember.Order,
						Name:        castMember.Name,
						Popularity:  castMember.Popularity,
						ProfilePath: castMember.ProfilePath,
					})
				}
			}

			sanitizedOverview := sanitizeOverview(details.Title, details.Overview, actors)

			movie := Movie{
				Actors:           actors,
				Director:         director,
				Genres:           details.Genres,
				ID:               details.ID,
				ImdbID:           details.ImdbID,
				OriginalOverview: details.Overview,
				Overview:         sanitizedOverview,
				Popularity:       details.Popularity,
				PosterPath:       details.PosterPath,
				ReleaseDate:      details.ReleaseDate,
				Tagline:          details.Tagline,
				Title:            details.Title,
				VoteAverage:      details.VoteAverage,
				VoteCount:        details.VoteCount,
			}
			finalMovies = append(finalMovies, movie)

			basicMovie := BasicMovie{
				ID:          details.ID,
				Title:       details.Title,
				ReleaseDate: details.ReleaseDate,
				PosterPath:  details.PosterPath,
			}
			finalBasicMovies = append(finalBasicMovies, basicMovie)

			time.Sleep(100 * time.Millisecond)
		}
	}

	log.Printf("Fetched and processed %d valid movies.", len(finalMovies))

	log.Println("De-duplicating titles and sorting basic movies list...")
	titleCounts := make(map[string]int)
	for _, m := range finalBasicMovies {
		titleCounts[m.Title]++
	}

	for i, m := range finalBasicMovies {
		if titleCounts[m.Title] > 1 {
			year := strings.Split(m.ReleaseDate, "-")[0]
			finalBasicMovies[i].Title = fmt.Sprintf("%s (%s)", m.Title, year)
		}
	}

	sort.Slice(finalBasicMovies, func(i, j int) bool {
		return finalBasicMovies[i].Title < finalBasicMovies[j].Title
	})

	log.Printf("Writing output files to %s...", outputDir)
	if err := os.MkdirAll(outputDir, os.ModePerm); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	popularMoviesPath := filepath.Join(outputDir, "popularMovies.json")
	if err := writeJSONFile(popularMoviesPath, finalMovies); err != nil {
		log.Fatalf("Failed to write popularMovies.json: %v", err)
	}
	log.Printf("Successfully wrote %s", popularMoviesPath)

	basicMoviesPath := filepath.Join(outputDir, "basicMovies.json")
	if err := writeJSONFile(basicMoviesPath, finalBasicMovies); err != nil {
		log.Fatalf("Failed to write basicMovies.json: %v", err)
	}
	log.Printf("Successfully wrote %s", basicMoviesPath)

	log.Println("Pipeline completed successfully!")
}

================
File: utils/fetchMovies/fetchMovies.go
================
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"time"
)

type PopularMovie struct {
	Adult            bool    `json:"adult"`
	BackdropPath     string  `json:"backdrop_path"`
	GenreIds         []int   `json:"genre_ids"`
	ID               int     `json:"id"`
	OriginalLanguage string  `json:"original_language"`
	OriginalTitle    string  `json:"original_title"`
	Overview         string  `json:"overview"`
	Popularity       float64 `json:"popularity"`
	PosterPath       string  `json:"poster_path"`
	ReleaseDate      string  `json:"release_date"`
	Title            string  `json:"title"`
	Video            bool    `json:"video"`
	VoteAverage      float64 `json:"vote_average"`
	VoteCount        int     `json:"vote_count"`
}

type Config struct {
	TMDBKey string `json:"TMDBKey"`
}

type TMDBDetailsResponse struct {
	Adult               bool        `json:"adult"`
	BackdropPath        string      `json:"backdrop_path"`
	BelongsToCollection interface{} `json:"belongs_to_collection"`
	Budget              int         `json:"budget"`
	Genres              []struct {
		ID   int    `json:"id"`
		Name string `json:"name"`
	} `json:"genres"`
	Homepage            string  `json:"homepage"`
	ID                  int     `json:"id"`
	ImdbID              string  `json:"imdb_id"`
	OriginalLanguage    string  `json:"original_language"`
	OriginalTitle       string  `json:"original_title"`
	Overview            string  `json:"overview"`
	Popularity          float64 `json:"popularity"`
	PosterPath          string  `json:"poster_path"`
	ProductionCompanies []struct {
		ID            int    `json:"id"`
		LogoPath      string `json:"logo_path"`
		Name          string `json:"name"`
		OriginCountry string `json:"origin_country"`
	} `json:"production_companies"`
	ProductionCountries []struct {
		Iso31661 string `json:"iso_3166_1"`
		Name     string `json:"name"`
	} `json:"production_countries"`
	ReleaseDate     string `json:"release_date"`
	Revenue         int    `json:"revenue"`
	Runtime         int    `json:"runtime"`
	SpokenLanguages []struct {
		EnglishName string `json:"english_name"`
		Iso6391     string `json:"iso_639_1"`
		Name        string `json:"name"`
	} `json:"spoken_languages"`
	Status      string  `json:"status"`
	Tagline     string  `json:"tagline"`
	Title       string  `json:"title"`
	Video       bool    `json:"video"`
	VoteAverage float64 `json:"vote_average"`
	VoteCount   int     `json:"vote_count"`
}

func TMDBKey() string {
	configFile, err := os.Open("../secrets.json")
	if err != nil {
		fmt.Println(err)
	}
	defer configFile.Close()

	secretsBytes, _ := io.ReadAll(configFile)
	var config Config
	json.Unmarshal(secretsBytes, &config)
	return config.TMDBKey
}

func URLS() []string {
	fileName := "../fetchPopularMovies/popular_movies_raw.json"
	moviesFile, err := os.Open(fileName)
	if err != nil {
		fmt.Println(err)
	}
	defer moviesFile.Close()

	byteValue, _ := io.ReadAll(moviesFile)
	var movies []PopularMovie
	json.Unmarshal(byteValue, &movies)

	urls := make([]string, len(movies))

	for _, movie := range movies {
		if movie.OriginalLanguage != "en" {
			continue
		}
		path := "/3/movie/" + strconv.Itoa(movie.ID)
		url := url.URL{
			Scheme: "https",
			Host:   "api.themoviedb.org",
			Path:   path,
		}
		q := url.Query()
		q.Set("api_key", TMDBKey())
		url.RawQuery = q.Encode()
		urls = append(urls, url.String())
	}
	return urls
}

func WriteToFile(file *os.File, data string) {
	dataToWrite := data + "\n"
	_, err := file.WriteString(dataToWrite)
	if err != nil {
		fmt.Printf(err.Error())
	}
}

func main() {
	fileName := "movies.txt"
	urls := URLS()
	f, err := os.Create(fileName)
	if err != nil {
		fmt.Printf(err.Error())
	}
	defer f.Close()

	for _, url := range urls {
		if url == "" {
			continue
		}
		resp, err := http.Get(url)
		if err != nil {
			fmt.Printf(err.Error())
		}
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			fmt.Printf(err.Error())
		}

		data := (*json.RawMessage)(&body)
		var validResponse TMDBDetailsResponse
		err = json.Unmarshal(*data, &validResponse)
		if err != nil {
			fmt.Printf(err.Error())
		}

		if validResponse.OriginalTitle > "" {
			WriteToFile(f, string(body))
		}
		time.Sleep(100 * time.Millisecond)
	}
}

================
File: utils/fetchMovies/go.mod
================
module fetchMovies

go 1.23.1

================
File: utils/fetchMoviesCredits/fetchMoviesCredits.go
================
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"time"
)

type PopularMovie struct {
	Adult         bool    `json:"adult"`
	ID            int     `json:"id"`
	OriginalTitle string  `json:"original_title"`
	Popularity    float64 `json:"popularity"`
	Video         bool    `json:"video"`
}

type Config struct {
	TMDBKey string `json:"TMDBKey"`
}

type TMDBCreditsResponse struct {
	ID   int `json:"id"`
	Cast []struct {
		Adult              bool    `json:"adult"`
		Gender             int     `json:"gender"`
		ID                 int     `json:"id"`
		KnownForDepartment string  `json:"known_for_department"`
		Name               string  `json:"name"`
		OriginalName       string  `json:"original_name"`
		Popularity         float64 `json:"popularity"`
		ProfilePath        string  `json:"profile_path"`
		CastID             int     `json:"cast_id"`
		Character          string  `json:"character"`
		CreditID           string  `json:"credit_id"`
		Order              int     `json:"order"`
	} `json:"cast"`
	Crew []struct {
		Adult              bool    `json:"adult"`
		Gender             int     `json:"gender"`
		ID                 int     `json:"id"`
		KnownForDepartment string  `json:"known_for_department"`
		Name               string  `json:"name"`
		OriginalName       string  `json:"original_name"`
		Popularity         float64 `json:"popularity"`
		ProfilePath        string  `json:"profile_path"`
		CreditID           string  `json:"credit_id"`
		Department         string  `json:"department"`
		Job                string  `json:"job"`
	} `json:"crew"`
}

func TMDBKey() string {
	configFile, err := os.Open("../secrets.json")
	if err != nil {
		fmt.Println(err)
	}
	defer configFile.Close()

	secretsBytes, _ := io.ReadAll(configFile)
	var config Config
	json.Unmarshal(secretsBytes, &config)
	return config.TMDBKey
}

func URLS() []string {
	moviesFile, err := os.Open("../../data/movies.json")
	if err != nil {
		fmt.Println(err)
	}
	defer moviesFile.Close()

	byteValue, _ := io.ReadAll(moviesFile)
	var movies []PopularMovie
	json.Unmarshal(byteValue, &movies)

	urls := make([]string, len(movies))

	for _, movie := range movies {
		path := "/3/movie/" + strconv.Itoa(movie.ID) + "/credits"
		url := url.URL{
			Scheme: "https",
			Host:   "api.themoviedb.org",
			Path:   path,
		}
		q := url.Query()
		q.Set("api_key", TMDBKey())
		url.RawQuery = q.Encode()
		urls = append(urls, url.String())
	}
	return urls
}

func WriteToFile(file *os.File, data string) {
	dataToWrite := data + "\n"
	_, err := file.WriteString(dataToWrite)
	if err != nil {
		fmt.Println(err.Error())
	}
}

func main() {
	fileName := "credits.txt"
	urls := URLS()
	f, err := os.Create(fileName)
	if err != nil {
		fmt.Println(err.Error())
	}
	defer f.Close()

	for _, url := range urls {
		if url == "" {
			continue
		}
		resp, err := http.Get(url)
		if err != nil {
			fmt.Println(err.Error())
		}
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			fmt.Println(err.Error())
		}

		data := (*json.RawMessage)(&body)
		var validResponse TMDBCreditsResponse
		err = json.Unmarshal(*data, &validResponse)
		if err != nil {
			fmt.Println(err.Error())
		}

		if validResponse.ID > 0 {
			WriteToFile(f, string(body))
		}

		time.Sleep(100 * time.Millisecond)
	}
}

================
File: utils/fetchMoviesCredits/go.mod
================
module fetchMoviesCredits

go 1.23.1

================
File: utils/fetchPopularMovies/fetchPopularMovies.go
================
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"time"
)

type Movie struct {
	Adult            bool    `json:"adult"`
	BackdropPath     string  `json:"backdrop_path"`
	GenreIds         []int   `json:"genre_ids"`
	ID               int     `json:"id"`
	OriginalLanguage string  `json:"original_language"`
	OriginalTitle    string  `json:"original_title"`
	Overview         string  `json:"overview"`
	Popularity       float64 `json:"popularity"`
	PosterPath       string  `json:"poster_path"`
	ReleaseDate      string  `json:"release_date"`
	Title            string  `json:"title"`
	Video            bool    `json:"video"`
	VoteAverage      float64 `json:"vote_average"`
	VoteCount        int     `json:"vote_count"`
}

type Config struct {
	TMDBKey string `json:"TMDBKey"`
}

type TMDBMoviesReponse struct {
	Page         int     `json:"page"`
	Results      []Movie `json:"results"`
	TotalPages   int     `json:"total_pages"`
	TotalResults int     `json:"total_results"`
}

func TMDBKey() string {
	configFile, err := os.Open("../secrets.json")
	if err != nil {
		fmt.Println(err)
	}
	defer configFile.Close()

	secretsBytes, _ := io.ReadAll(configFile)
	var config Config
	json.Unmarshal(secretsBytes, &config)
	return config.TMDBKey
}

func URLS(pages int) []string {
	urls := make([]string, pages)

	for page := 1; page < pages; page++ {
		path := "/3/discover/movie"
		url := url.URL{
			Scheme: "https",
			Host:   "api.themoviedb.org",
			Path:   path,
		}
		q := url.Query()
		q.Set("page", strconv.Itoa(page))
		q.Set("include_adult", "false")
		q.Set("include_video", "false")
		q.Set("language", "en-US")
		q.Set("sort_by", "popularity.desc")
		q.Set("api_key", TMDBKey())
		url.RawQuery = q.Encode()
		urls = append(urls, url.String())
	}
	return urls
}

func WriteToFile(file *os.File, data string) {
	dataToWrite := data + "\n"
	_, err := file.WriteString(dataToWrite)
	if err != nil {
		fmt.Printf(err.Error())
	}
}

func main() {
	fileName := "popular_movies_raw.json"
	max_pages := 500
	urls := URLS(max_pages)
	f, err := os.Create(fileName)
	if err != nil {
		fmt.Printf(err.Error())
	}
	defer f.Close()

	results := []Movie{}

	for _, url := range urls {
		if url == "" {
			continue
		}
		resp, err := http.Get(url)
		if err != nil {
			fmt.Printf(err.Error())
		}
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			fmt.Printf(err.Error())
		}

		data := (*json.RawMessage)(&body)
		var validResponse TMDBMoviesReponse
		err = json.Unmarshal(*data, &validResponse)
		if err != nil {
			fmt.Printf(err.Error())
		}

		results = append(results, validResponse.Results...)
		time.Sleep(100 * time.Millisecond)
	}

	jsonResults, _ := json.Marshal(results)
	WriteToFile(f, string(jsonResults))
}

================
File: utils/fetchPopularMovies/go.mod
================
module fetchPopularMovies

go 1.23.1

================
File: utils/firebase-functions/DailyMovie.js
================
const { onSchedule } = require("firebase-functions/v2/scheduler");
const { logger } = require("firebase-functions");
const { initializeApp } = require("firebase-admin/app");
const { getFirestore } = require("firebase-admin/firestore");

initializeApp();

exports.setDailyMovie = onSchedule("every day 00:00", async (event) => {
    logger.info("Running daily movie selection cron job.");

    try {
        const db = getFirestore();
        const moviesSnapshot = await db.collection("movies").get();

        if (moviesSnapshot.empty) {
            logger.error("No movies found in the 'movies' collection. Cannot set daily movie.");
            return;
        }

        const movies = moviesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const today = new Date();
        const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);
        const movieIndex = dayOfYear % movies.length;
        const selectedMovie = movies[movieIndex];

        const dateId = today.toISOString().split('T')[0];

        await db.collection('dailyGames').doc(dateId).set({
            date: today,
            movieId: parseInt(selectedMovie.id, 10),
        });

        logger.info(`Successfully set daily movie for ${dateId} to movie ID: ${selectedMovie.id}`);
    } catch (error) {
        logger.error("Failed to set daily movie:", error);
    }
});

================
File: utils/movies/go.mod
================
module movies

go 1.23.1

================
File: utils/movies/movies.go
================
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
)

type DetailedMovie struct {
	Adult               bool        `json:"adult"`
	BackdropPath        string      `json:"backdrop_path"`
	BelongsToCollection interface{} `json:"belongs_to_collection"`
	Budget              int         `json:"budget"`
	Genres              []Genre     `json:"genres"`
	Homepage            string      `json:"homepage"`
	ID                  int         `json:"id"`
	ImdbID              string      `json:"imdb_id"`
	OriginalLanguage    string      `json:"original_language"`
	OriginalTitle       string      `json:"original_title"`
	Overview            string      `json:"overview"`
	Popularity          float64     `json:"popularity"`
	PosterPath          string      `json:"poster_path"`
	ProductionCompanies []struct {
		ID            int    `json:"id"`
		LogoPath      string `json:"logo_path"`
		Name          string `json:"name"`
		OriginCountry string `json:"origin_country"`
	} `json:"production_companies"`
	ProductionCountries []struct {
		Iso31661 string `json:"iso_3166_1"`
		Name     string `json:"name"`
	} `json:"production_countries"`
	ReleaseDate     string `json:"release_date"`
	Revenue         int    `json:"revenue"`
	Runtime         int    `json:"runtime"`
	SpokenLanguages []struct {
		EnglishName string `json:"english_name"`
		Iso6391     string `json:"iso_639_1"`
		Name        string `json:"name"`
	} `json:"spoken_languages"`
	Status      string  `json:"status"`
	Tagline     string  `json:"tagline"`
	Title       string  `json:"title"`
	Video       bool    `json:"video"`
	VoteAverage float64 `json:"vote_average"`
	VoteCount   int     `json:"vote_count"`
}

type Genre struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

type Movie struct {
	Actors      []MovieActor  `json:"actors"`
	Director    MovieDirector `json:"director"`
	Genres      []Genre       `json:"genres"`
	ImdbID      string        `json:"imdb_id"`
	ID          int           `json:"id"`
	Overview    string        `json:"overview"`
	Popularity  float64       `json:"popularity"`
	PosterPath  string        `json:"poster_path"`
	ReleaseDate string        `json:"release_date"`
	Tagline     string        `json:"tagline"`
	Title       string        `json:"title"`
	VoteAverage float64       `json:"vote_average"`
	VoteCount   int           `json:"vote_count"`
}

type MovieActor struct {
	ID          int     `json:"id"`
	Order       int     `json:"order"`
	Name        string  `json:"name"`
	Popularity  float64 `json:"popularity"`
	ProfilePath string  `json:"profile_path"`
}

type MovieDirector struct {
	ID          int     `json:"id"`
	Name        string  `json:"name"`
	Popularity  float64 `json:"popularity"`
	ProfilePath string  `json:"profile_path"`
}

func main() {
	actorFile, err := os.Open("../../data/movieActors.json")
	if err != nil {
		fmt.Println(err)
	}
	defer actorFile.Close()

	actorByteValue, _ := io.ReadAll(actorFile)

	var actors map[int][]MovieActor
	json.Unmarshal([]byte(actorByteValue), &actors)

	directorFile, err := os.Open("../../data/movieDirectors.json")
	if err != nil {
		fmt.Println(err)
	}
	defer actorFile.Close()

	directorByteValue, _ := io.ReadAll(directorFile)

	var directors map[int]MovieDirector
	json.Unmarshal([]byte(directorByteValue), &directors)

	jsonFile, err := os.Open("../../data/movies.json")
	if err != nil {
		fmt.Println(err)
	}
	defer jsonFile.Close()

	byteValue, _ := io.ReadAll(jsonFile)

	var movies []DetailedMovie
	json.Unmarshal([]byte(byteValue), &movies)

	popularMovies := []Movie{}
	for _, movie := range movies {
		if len(movie.Overview) < 400 &&
			len(movie.Overview) > 60 &&
			movie.Runtime > 75 &&
			movie.Popularity > 10 &&
			movie.VoteAverage > 4.9 &&
			movie.VoteCount > 400 {
			genres := []Genre{}
			for _, genre := range movie.Genres {
				genres = append(genres, genre)
			}
			m := Movie{
				Actors:      actors[movie.ID],
				Director:    directors[movie.ID],
				Genres:      genres,
				ImdbID:      movie.ImdbID,
				ID:          movie.ID,
				Overview:    movie.Overview,
				Popularity:  movie.Popularity,
				PosterPath:  movie.PosterPath,
				ReleaseDate: movie.ReleaseDate,
				Tagline:     movie.Tagline,
				Title:       movie.Title,
				VoteAverage: movie.VoteAverage,
				VoteCount:   movie.VoteCount,
			}
			popularMovies = append(popularMovies, m)
		}

	}

	pm, err := json.MarshalIndent(popularMovies, "", "  ")
	if err != nil {
		log.Fatal(err)
	}

	f, err := os.Create("popularMovies.json")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	_, err = f.WriteString(string(pm))
	if err != nil {
		log.Fatal(err)
	}
}

================
File: utils/populate-firestore/go.mod
================
module populate-firestore

go 1.23.1

require (
	cloud.google.com/go/firestore v1.15.0
	google.golang.org/api v0.169.0
)

require (
	cloud.google.com/go v0.112.1 // indirect
	cloud.google.com/go/compute v1.24.0 // indirect
	cloud.google.com/go/compute/metadata v0.2.3 // indirect
	cloud.google.com/go/longrunning v0.5.5 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/go-logr/logr v1.4.1 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
	github.com/golang/protobuf v1.5.3 // indirect
	github.com/google/s2a-go v0.1.7 // indirect
	github.com/googleapis/enterprise-certificate-proxy v0.3.2 // indirect
	github.com/googleapis/gax-go/v2 v2.12.2 // indirect
	go.opencensus.io v0.24.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 // indirect
	go.opentelemetry.io/otel v1.24.0 // indirect
	go.opentelemetry.io/otel/metric v1.24.0 // indirect
	go.opentelemetry.io/otel/trace v1.24.0 // indirect
	golang.org/x/crypto v0.19.0 // indirect
	golang.org/x/net v0.21.0 // indirect
	golang.org/x/oauth2 v0.17.0 // indirect
	golang.org/x/sync v0.6.0 // indirect
	golang.org/x/sys v0.17.0 // indirect
	golang.org/x/text v0.14.0 // indirect
	golang.org/x/time v0.5.0 // indirect
	google.golang.org/appengine v1.6.8 // indirect
	google.golang.org/genproto v0.0.0-20240213162025-012b6fc9bca9 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20240304161311-37d4d3c04a78 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240304161311-37d4d3c04a78 // indirect
	google.golang.org/grpc v1.62.0 // indirect
	google.golang.org/protobuf v1.32.0 // indirect
)

================
File: utils/populate-firestore/go.sum
================
cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.112.1 h1:uJSeirPke5UNZHIb4SxfZklVSiWWVqW4oXlETwZziwM=
cloud.google.com/go v0.112.1/go.mod h1:+Vbu+Y1UU+I1rjmzeMOb/8RfkKJK2Gyxi1X6jJCZLo4=
cloud.google.com/go/compute v1.24.0 h1:phWcR2eWzRJaL/kOiJwfFsPs4BaKq1j6vnpZrc1YlVg=
cloud.google.com/go/compute v1.24.0/go.mod h1:kw1/T+h/+tK2LJK0wiPPx1intgdAM3j/g3hFDlscY40=
cloud.google.com/go/compute/metadata v0.2.3 h1:mg4jlk7mCAj6xXp9UJ4fjI9VUI5rubuGBW5aJ7UnBMY=
cloud.google.com/go/compute/metadata v0.2.3/go.mod h1:VAV5nSsACxMJvgaAuX6Pk2AawlZn8kiOGuCv6gTkwuA=
cloud.google.com/go/firestore v1.15.0 h1:/k8ppuWOtNuDHt2tsRV42yI21uaGnKDEQnRFeBpbFF8=
cloud.google.com/go/firestore v1.15.0/go.mod h1:GWOxFXcv8GZUtYpWHw/w6IuYNux/BtmeVTMmjrm4yhk=
cloud.google.com/go/longrunning v0.5.5 h1:GOE6pZFdSrTb4KAiKnXsJBtlE6mEyaW44oKyMILWnOg=
cloud.google.com/go/longrunning v0.5.5/go.mod h1:WV2LAxD8/rg5Z1cNW6FJ/ZpX4E4VnDnoTk0yawPBB7s=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/logr v1.4.1 h1:pKouT5E8xu9zeFC39JXRDukb6JFQPXM5p5I91188VAQ=
github.com/go-logr/logr v1.4.1/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
github.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=
github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
github.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=
github.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=
github.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
github.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=
github.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.3/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/s2a-go v0.1.7 h1:60BLSyTrOV4/haCDW4zb1guZItoSq8foHCXrAnjBo/o=
github.com/google/s2a-go v0.1.7/go.mod h1:50CgR4k1jNlWBu4UfS4AcfhVe1r6pdZPygJ3R8F0Qdw=
github.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/googleapis/enterprise-certificate-proxy v0.3.2 h1:Vie5ybvEvT75RniqhfFxPRy3Bf7vr3h0cechB90XaQs=
github.com/googleapis/enterprise-certificate-proxy v0.3.2/go.mod h1:VLSiSSBs/ksPL8kq3OBOQ6WRI2QnaFynd1DCjZ62+V0=
github.com/googleapis/gax-go/v2 v2.12.2 h1:mhN09QQW1jEWeMF74zGR81R30z4VJzjZsfkUhuHF+DA=
github.com/googleapis/gax-go/v2 v2.12.2/go.mod h1:61M8vcyyXR2kqKFxKrfA22jaA8JGF7Dc8App1U3H6jc=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=
github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
go.opencensus.io v0.24.0 h1:y73uSU6J157QMP2kn2r30vwW1A2W2WFwSCGnAVxeaD0=
go.opencensus.io v0.24.0/go.mod h1:vNK8G9p7aAivkbmorf4v+7Hgx+Zs0yY+0fOtgBfjQKo=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0 h1:4Pp6oUg3+e/6M4C0A/3kJ2VYa++dsWVTtGgLVj5xtHg=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0/go.mod h1:Mjt1i1INqiaoZOMGR1RIUJN+i3ChKoFRqzrRQhlkbs0=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 h1:jq9TW8u3so/bN+JPT166wjOI6/vQPF6Xe7nMNIltagk=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0/go.mod h1:p8pYQP+m5XfbZm9fxtSKAbM6oIllS7s2AfxrChvc7iw=
go.opentelemetry.io/otel v1.24.0 h1:0LAOdjNmQeSTzGBzduGe/rU4tZhMwL5rWgtp9Ku5Jfo=
go.opentelemetry.io/otel v1.24.0/go.mod h1:W7b9Ozg4nkF5tWI5zsXkaKKDjdVjpD4oAt9Qi/MArHo=
go.opentelemetry.io/otel/metric v1.24.0 h1:6EhoGWWK28x1fbpA4tYTOWBkPefTDQnb8WSGXlc88kI=
go.opentelemetry.io/otel/metric v1.24.0/go.mod h1:VYhLe1rFfxuTXLgj4CBiyz+9WYBA8pNGJgDcSFRKBco=
go.opentelemetry.io/otel/sdk v1.22.0 h1:6coWHw9xw7EfClIC/+O31R8IY3/+EiRFHevmHafB2Gw=
go.opentelemetry.io/otel/sdk v1.22.0/go.mod h1:iu7luyVGYovrRpe2fmj3CVKouQNdTOkxtLzPvPz1DOc=
go.opentelemetry.io/otel/trace v1.24.0 h1:CsKnnL4dUAr/0llH9FKuc698G04IrpWV0MQA/Y1YELI=
go.opentelemetry.io/otel/trace v1.24.0/go.mod h1:HPc3Xr/cOApsBI154IU0OI0HJexz+aw5uPdbs3UCjNU=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.19.0 h1:ENy+Az/9Y1vSrlrvBSyna3PITt4tiZLf7sgCjZBX7Wo=
golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=
golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.21.0 h1:AQyQV4dYCvJ7vGmJyKki9+PBdyvhkSd8EIx/qb0AYv4=
golang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/oauth2 v0.17.0 h1:6m3ZPmLEFdVxKKWnKq4VqZ60gutO35zm+zrAHVmHyDQ=
golang.org/x/oauth2 v0.17.0/go.mod h1:OzPDGQiuQMguemayvdylqddI7qcD9lnSDb+1FiwQ5HA=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.6.0 h1:5BMeUDZ7vkXGfEr1x9B4bRcTH4lpkTkpdh0T/J+qjbQ=
golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.17.0 h1:25cE3gD+tdBA7lp7QfhuV+rJiE9YXTcS3VG1SqssI/Y=
golang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=
golang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=
golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=
golang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/api v0.169.0 h1:QwWPy71FgMWqJN/l6jVlFHUa29a7dcUy02I8o799nPY=
google.golang.org/api v0.169.0/go.mod h1:gpNOiMA2tZ4mf5R9Iwf4rK/Dcz0fbdIgWYWVoxmsyLg=
google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/appengine v1.6.8 h1:IhEN5q69dyKagZPYMSdIjS2HqprW324FRQZJcGqPAsM=
google.golang.org/appengine v1.6.8/go.mod h1:1jJ3jBArFh5pcgW8gCtRJnepW8FzD1V44FJffLiz/Ds=
google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
google.golang.org/genproto v0.0.0-20240213162025-012b6fc9bca9 h1:9+tzLLstTlPTRyJTh+ah5wIMsBW5c4tQwGTN3thOW9Y=
google.golang.org/genproto v0.0.0-20240213162025-012b6fc9bca9/go.mod h1:mqHbVIp48Muh7Ywss/AD6I5kNVKZMmAa/QEW58Gxp2s=
google.golang.org/genproto/googleapis/api v0.0.0-20240304161311-37d4d3c04a78 h1:SzXBGiWM1LNVYLCRP3e0/Gsze804l4jGoJ5lYysEO5I=
google.golang.org/genproto/googleapis/api v0.0.0-20240304161311-37d4d3c04a78/go.mod h1:O1cOfN1Cy6QEYr7VxtjOyP5AdAuR0aJ/MYZaaof623Y=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240304161311-37d4d3c04a78 h1:Xs9lu+tLXxLIfuci70nG4cpwaRC+mRQPUL7LoIeDJC4=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240304161311-37d4d3c04a78/go.mod h1:UCOku4NytXMJuLQE5VuqA5lX3PcHCBo8pxNyvkf4xBs=
google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
google.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.33.2/go.mod h1:JMHMWHQWaTccqQQlmk3MJZS+GWXOdAesneDmEnv2fbc=
google.golang.org/grpc v1.62.0 h1:HQKZ/fa1bXkX1oFOvSjmZEUL8wLSaZTjCcLAlmZRtdk=
google.golang.org/grpc v1.62.0/go.mod h1:IWTG0VlJLCh1SkC58F7np9ka9mx/WNkjl4PGJaiq+QE=
google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.32.0 h1:pPC6BG5ex8PDFnkbrGU3EixyhKcQ2aDuBS36lqK/C7I=
google.golang.org/protobuf v1.32.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=

================
File: utils/populate-firestore/main.go
================
package main

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"cloud.google.com/go/firestore"
	"google.golang.org/api/option"
)

type Movie struct {
	Actors           interface{} `json:"actors"`
	Director         interface{} `json:"director"`
	Genres           interface{} `json:"genres"`
	ID               int         `json:"id"`
	ImdbID           string      `json:"imdb_id"`
	OriginalOverview string      `json:"original_overview"`
	Overview         string      `json:"overview"`
	Popularity       float64     `json:"popularity"`
	PosterPath       string      `json:"poster_path"`
	ReleaseDate      string      `json:"release_date"`
	Tagline          string      `json:"tagline"`
	Title            string      `json:"title"`
	VoteAverage      float64     `json:"vote_average"`
	VoteCount        int         `json:"vote_count"`
}

const (
	serviceAccountKeyPath = "../serviceAccountKey.json"
	moviesJSONPath        = "../../src/data/popularMovies.json"
	projectID             = "talkie-trivia"
)

func main() {
	log.Println("Starting Firestore population script...")

	// 1. Set up Firestore client
	ctx := context.Background()
	sa := option.WithCredentialsFile(serviceAccountKeyPath)
	client, err := firestore.NewClient(ctx, projectID, sa)
	if err != nil {
		log.Fatalf("Failed to create Firestore client: %v", err)
	}
	defer client.Close()

	log.Printf("Successfully connected to Firestore project: %s", projectID)

	// 2. Read the movies JSON file
	absPath, _ := filepath.Abs(moviesJSONPath)
	jsonFile, err := os.Open(absPath)
	if err != nil {
		log.Fatalf("Failed to open movies JSON file at %s: %v", absPath, err)
	}
	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)
	var movies []Movie
	json.Unmarshal(byteValue, &movies)

	log.Printf("Read %d movies from %s", len(movies), moviesJSONPath)

	// 3. Upload movies to Firestore
	batch := client.Batch()
	moviesCollection := client.Collection("movies")
	commitCounter := 0

	for i, movie := range movies {
		// Use the movie's ID as the document ID for easy lookup
		docID := strconv.Itoa(movie.ID)
		docRef := moviesCollection.Doc(docID)
		batch.Set(docRef, movie)

		// Firestore batches are limited to 500 operations.
		if (i+1)%400 == 0 || i == len(movies)-1 {
			log.Printf("Committing batch %d...", commitCounter+1)
			_, err := batch.Commit(ctx)
			if err != nil {
				log.Fatalf("Failed to commit batch: %v", err)
			}
			log.Printf("Successfully committed batch %d.", commitCounter+1)

			// Start a new batch
			batch = client.Batch()
			commitCounter++
			time.Sleep(1 * time.Second)
		}
	}

	log.Println("All movies have been successfully uploaded to Firestore!")
}

================
File: utils/schedule-games/go.mod
================
module schedule-games

go 1.23.1

require (
	cloud.google.com/go/firestore v1.18.0
	google.golang.org/api v0.241.0
)

require (
	cloud.google.com/go v0.120.0 // indirect
	cloud.google.com/go/auth v0.16.2 // indirect
	cloud.google.com/go/auth/oauth2adapt v0.2.8 // indirect
	cloud.google.com/go/compute/metadata v0.7.0 // indirect
	cloud.google.com/go/longrunning v0.6.7 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/google/s2a-go v0.1.9 // indirect
	github.com/googleapis/enterprise-certificate-proxy v0.3.6 // indirect
	github.com/googleapis/gax-go/v2 v2.14.2 // indirect
	go.opentelemetry.io/auto/sdk v1.1.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.61.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.61.0 // indirect
	go.opentelemetry.io/otel v1.36.0 // indirect
	go.opentelemetry.io/otel/metric v1.36.0 // indirect
	go.opentelemetry.io/otel/trace v1.36.0 // indirect
	golang.org/x/crypto v0.39.0 // indirect
	golang.org/x/net v0.41.0 // indirect
	golang.org/x/oauth2 v0.30.0 // indirect
	golang.org/x/sync v0.15.0 // indirect
	golang.org/x/sys v0.33.0 // indirect
	golang.org/x/text v0.26.0 // indirect
	golang.org/x/time v0.12.0 // indirect
	google.golang.org/genproto v0.0.0-20250505200425-f936aa4a68b2 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20250505200425-f936aa4a68b2 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20250603155806-513f23925822 // indirect
	google.golang.org/grpc v1.73.0 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
)

================
File: utils/schedule-games/go.sum
================
cloud.google.com/go v0.120.0 h1:wc6bgG9DHyKqF5/vQvX1CiZrtHnxJjBlKUyF9nP6meA=
cloud.google.com/go v0.120.0/go.mod h1:/beW32s8/pGRuj4IILWQNd4uuebeT4dkOhKmkfit64Q=
cloud.google.com/go/auth v0.16.2 h1:QvBAGFPLrDeoiNjyfVunhQ10HKNYuOwZ5noee0M5df4=
cloud.google.com/go/auth v0.16.2/go.mod h1:sRBas2Y1fB1vZTdurouM0AzuYQBMZinrUYL8EufhtEA=
cloud.google.com/go/auth/oauth2adapt v0.2.8 h1:keo8NaayQZ6wimpNSmW5OPc283g65QNIiLpZnkHRbnc=
cloud.google.com/go/auth/oauth2adapt v0.2.8/go.mod h1:XQ9y31RkqZCcwJWNSx2Xvric3RrU88hAYYbjDWYDL+c=
cloud.google.com/go/compute/metadata v0.7.0 h1:PBWF+iiAerVNe8UCHxdOt6eHLVc3ydFeOCw78U8ytSU=
cloud.google.com/go/compute/metadata v0.7.0/go.mod h1:j5MvL9PprKL39t166CoB1uVHfQMs4tFQZZcKwksXUjo=
cloud.google.com/go/firestore v1.18.0 h1:cuydCaLS7Vl2SatAeivXyhbhDEIR8BDmtn4egDhIn2s=
cloud.google.com/go/firestore v1.18.0/go.mod h1:5ye0v48PhseZBdcl0qbl3uttu7FIEwEYVaWm0UIEOEU=
cloud.google.com/go/longrunning v0.6.7 h1:IGtfDWHhQCgCjwQjV9iiLnUta9LBCo8R9QmAFsS/PrE=
cloud.google.com/go/longrunning v0.6.7/go.mod h1:EAFV3IZAKmM56TyiE6VAP3VoTzhZzySwI/YI1s/nRsY=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=
github.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=
github.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=
github.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=
github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=
github.com/google/s2a-go v0.1.9 h1:LGD7gtMgezd8a/Xak7mEWL0PjoTQFvpRudN895yqKW0=
github.com/google/s2a-go v0.1.9/go.mod h1:YA0Ei2ZQL3acow2O62kdp9UlnvMmU7kA6Eutn0dXayM=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/googleapis/enterprise-certificate-proxy v0.3.6 h1:GW/XbdyBFQ8Qe+YAmFU9uHLo7OnF5tL52HFAgMmyrf4=
github.com/googleapis/enterprise-certificate-proxy v0.3.6/go.mod h1:MkHOF77EYAE7qfSuSS9PU6g4Nt4e11cnsDUowfwewLA=
github.com/googleapis/gax-go/v2 v2.14.2 h1:eBLnkZ9635krYIPD+ag1USrOAI0Nr0QYF3+/3GqO0k0=
github.com/googleapis/gax-go/v2 v2.14.2/go.mod h1:ON64QhlJkhVtSqp4v1uaK92VyZ2gmvDQsweuyLV+8+w=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
go.opentelemetry.io/auto/sdk v1.1.0 h1:cH53jehLUN6UFLY71z+NDOiNJqDdPRaXzTel0sJySYA=
go.opentelemetry.io/auto/sdk v1.1.0/go.mod h1:3wSPjt5PWp2RhlCcmmOial7AvC4DQqZb7a7wCow3W8A=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.61.0 h1:q4XOmH/0opmeuJtPsbFNivyl7bCt7yRBbeEm2sC/XtQ=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.61.0/go.mod h1:snMWehoOh2wsEwnvvwtDyFCxVeDAODenXHtn5vzrKjo=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.61.0 h1:F7Jx+6hwnZ41NSFTO5q4LYDtJRXBf2PD0rNBkeB/lus=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.61.0/go.mod h1:UHB22Z8QsdRDrnAtX4PntOl36ajSxcdUMt1sF7Y6E7Q=
go.opentelemetry.io/otel v1.36.0 h1:UumtzIklRBY6cI/lllNZlALOF5nNIzJVb16APdvgTXg=
go.opentelemetry.io/otel v1.36.0/go.mod h1:/TcFMXYjyRNh8khOAO9ybYkqaDBb/70aVwkNML4pP8E=
go.opentelemetry.io/otel/metric v1.36.0 h1:MoWPKVhQvJ+eeXWHFBOPoBOi20jh6Iq2CcCREuTYufE=
go.opentelemetry.io/otel/metric v1.36.0/go.mod h1:zC7Ks+yeyJt4xig9DEw9kuUFe5C3zLbVjV2PzT6qzbs=
go.opentelemetry.io/otel/sdk v1.36.0 h1:b6SYIuLRs88ztox4EyrvRti80uXIFy+Sqzoh9kFULbs=
go.opentelemetry.io/otel/sdk v1.36.0/go.mod h1:+lC+mTgD+MUWfjJubi2vvXWcVxyr9rmlshZni72pXeY=
go.opentelemetry.io/otel/sdk/metric v1.36.0 h1:r0ntwwGosWGaa0CrSt8cuNuTcccMXERFwHX4dThiPis=
go.opentelemetry.io/otel/sdk/metric v1.36.0/go.mod h1:qTNOhFDfKRwX0yXOqJYegL5WRaW376QbB7P4Pb0qva4=
go.opentelemetry.io/otel/trace v1.36.0 h1:ahxWNuqZjpdiFAyrIoQ4GIiAIhxAunQR6MUoKrsNd4w=
go.opentelemetry.io/otel/trace v1.36.0/go.mod h1:gQ+OnDZzrybY4k4seLzPAWNwVBBVlF2szhehOBB/tGA=
golang.org/x/crypto v0.39.0 h1:SHs+kF4LP+f+p14esP5jAoDpHU8Gu/v9lFRK6IT5imM=
golang.org/x/crypto v0.39.0/go.mod h1:L+Xg3Wf6HoL4Bn4238Z6ft6KfEpN0tJGo53AAPC632U=
golang.org/x/net v0.41.0 h1:vBTly1HeNPEn3wtREYfy4GZ/NECgw2Cnl+nK6Nz3uvw=
golang.org/x/net v0.41.0/go.mod h1:B/K4NNqkfmg07DQYrbwvSluqCJOOXwUjeb/5lOisjbA=
golang.org/x/oauth2 v0.30.0 h1:dnDm7JmhM45NNpd8FDDeLhK6FwqbOf4MLCM9zb1BOHI=
golang.org/x/oauth2 v0.30.0/go.mod h1:B++QgG3ZKulg6sRPGD/mqlHQs5rB3Ml9erfeDY7xKlU=
golang.org/x/sync v0.15.0 h1:KWH3jNZsfyT6xfAfKiz6MRNmd46ByHDYaZ7KSkCtdW8=
golang.org/x/sync v0.15.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
golang.org/x/sys v0.33.0 h1:q3i8TbbEz+JRD9ywIRlyRAQbM0qF7hu24q3teo2hbuw=
golang.org/x/sys v0.33.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/text v0.26.0 h1:P42AVeLghgTYr4+xUnTRKDMqpar+PtX7KWuNQL21L8M=
golang.org/x/text v0.26.0/go.mod h1:QK15LZJUUQVJxhz7wXgxSy/CJaTFjd0G+YLonydOVQA=
golang.org/x/time v0.12.0 h1:ScB/8o8olJvc+CQPWrK3fPZNfh7qgwCrY0zJmoEQLSE=
golang.org/x/time v0.12.0/go.mod h1:CDIdPxbZBQxdj6cxyCIdrNogrJKMJ7pr37NYpMcMDSg=
google.golang.org/api v0.241.0 h1:QKwqWQlkc6O895LchPEDUSYr22Xp3NCxpQRiWTB6avE=
google.golang.org/api v0.241.0/go.mod h1:cOVEm2TpdAGHL2z+UwyS+kmlGr3bVWQQ6sYEqkKje50=
google.golang.org/genproto v0.0.0-20250505200425-f936aa4a68b2 h1:1tXaIXCracvtsRxSBsYDiSBN0cuJvM7QYW+MrpIRY78=
google.golang.org/genproto v0.0.0-20250505200425-f936aa4a68b2/go.mod h1:49MsLSx0oWMOZqcpB3uL8ZOkAh1+TndpJ8ONoCBWiZk=
google.golang.org/genproto/googleapis/api v0.0.0-20250505200425-f936aa4a68b2 h1:vPV0tzlsK6EzEDHNNH5sa7Hs9bd7iXR7B1tSiPepkV0=
google.golang.org/genproto/googleapis/api v0.0.0-20250505200425-f936aa4a68b2/go.mod h1:pKLAc5OolXC3ViWGI62vvC0n10CpwAtRcTNCFwTKBEw=
google.golang.org/genproto/googleapis/rpc v0.0.0-20250603155806-513f23925822 h1:fc6jSaCT0vBduLYZHYrBBNY4dsWuvgyff9noRNDdBeE=
google.golang.org/genproto/googleapis/rpc v0.0.0-20250603155806-513f23925822/go.mod h1:qQ0YXyHHx3XkvlzUtpXDkS29lDSafHMZBAZDc03LQ3A=
google.golang.org/grpc v1.73.0 h1:VIWSmpI2MegBtTuFt5/JWy2oXxtjJ/e89Z70ImfD2ok=
google.golang.org/grpc v1.73.0/go.mod h1:50sbHOUqWoCQGI8V2HQLJM0B+LMlIUjNSZmow7EVBQc=
google.golang.org/protobuf v1.36.6 h1:z1NpPI8ku2WgiWnf+t9wTPsn6eP1L7ksHUlkfLvd9xY=
google.golang.org/protobuf v1.36.6/go.mod h1:jduwjTPXsFjZGTmRluh+L6NjiWu7pchiJ2/5YcXBHnY=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=

================
File: utils/schedule-games/main.go
================
package main

import (
	"context"
	"log"
	"math/rand"
	"strconv"
	"time"

	"cloud.google.com/go/firestore"
	"google.golang.org/api/iterator"
	"google.golang.org/api/option"
)

// Configuration Constants
const (
	serviceAccountKeyPath = "../serviceAccountKey.json"
	projectID             = "talkie-trivia"
	daysToSchedule        = 365 // Target: 1 year (6-12 months requested)
	batchSize             = 400 // Firestore transaction limit is 500
)

// DailyGame represents the structure of a document in the 'dailyGames' collection.
type DailyGame struct {
	MovieID int       `firestore:"movieId"`
	Date    time.Time `firestore:"date"`
}

func main() {
	log.Println("Starting daily games scheduling script...")

	// 1. Setup Firestore client with service account credentials
	ctx := context.Background()
	sa := option.WithCredentialsFile(serviceAccountKeyPath)
	client, err := firestore.NewClient(ctx, projectID, sa)
	if err != nil {
		log.Fatalf("Failed to create Firestore client: %v", err)
	}
	defer client.Close()

	log.Printf("Successfully connected to Firestore project: %s", projectID)

	// 2. Fetch all movie IDs from the 'movies' collection.
	log.Println("Fetching all movie IDs from Firestore...")
	moviesIter := client.Collection("movies").Select("id").Documents(ctx)
	var movieIDs []int
	for {
		doc, err := moviesIter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			log.Fatalf("Failed to iterate movie documents: %v", err)
		}
		// The ID is stored as a string in the document path, convert it back to int.
		movieID, _ := strconv.Atoi(doc.Ref.ID)
		if movieID > 0 {
			movieIDs = append(movieIDs, movieID)
		}
	}
	if len(movieIDs) == 0 {
		log.Fatal("No movies found in 'movies' collection. Run the data pipeline script first.")
	}
	log.Printf("Found %d unique movie IDs for scheduling.", len(movieIDs))

	// 3. Determine the starting date for new schedules.
	now := time.Now()
	// Normalize 'today' to midnight for consistent date calculations
	today := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())

	startDate := today

	// Find the date of the last scheduled game
	lastGameQuery := client.Collection("dailyGames").OrderBy("date", firestore.Desc).Limit(1)
	docs, err := lastGameQuery.Documents(ctx).GetAll()

	if err == nil && len(docs) > 0 {
		lastGameData := docs[0].Data()
		if lastGameTimestamp, ok := lastGameData["date"].(time.Time); ok {
			// Start the new schedule one day after the latest existing schedule
			lastScheduledDate := time.Date(lastGameTimestamp.Year(), lastGameTimestamp.Month(), lastGameTimestamp.Day(), 0, 0, 0, 0, lastGameTimestamp.Location())

			if lastScheduledDate.After(today) || lastScheduledDate.Equal(today) {
				startDate = lastScheduledDate.AddDate(0, 0, 1)
			}
			log.Printf("Last scheduled game found on: %s. New scheduling starts from: %s", lastScheduledDate.Format("2006-01-02"), startDate.Format("2006-01-02"))
		}
	} else if err != nil {
		log.Printf("Warning: Could not query for last game date (%v). Scheduling starts from today: %s", err, startDate.Format("2006-01-02"))
	} else {
		log.Printf("No existing daily games found. Scheduling starts from today: %s", startDate.Format("2006-01-02"))
	}

	// 4. Shuffle the movie IDs to ensure non-repeating random selection over the schedule window.
	// We use the full Nano timestamp as a seed for non-deterministic randomization across runs.
	source := rand.NewSource(time.Now().UnixNano())
	r := rand.New(source)
	r.Shuffle(len(movieIDs), func(i, j int) {
		movieIDs[i], movieIDs[j] = movieIDs[j], movieIDs[i]
	})

	// 5. Create and commit batches of new daily games.
	log.Printf("Scheduling games for the next %d days...", daysToSchedule)

	batch := client.Batch()
	dailyGamesCollection := client.Collection("dailyGames")
	movieIndex := 0

	for i := 0; i < daysToSchedule; i++ {
		gameDate := startDate.AddDate(0, 0, i)
		dateID := gameDate.Format("2006-01-02")

		// Cycle through the shuffled movie IDs
		if movieIndex >= len(movieIDs) {
			// Reshuffle for the next cycle to avoid predictable sequences
			r.Shuffle(len(movieIDs), func(i, j int) {
				movieIDs[i], movieIDs[j] = movieIDs[j], movieIDs[i]
			})
			movieIndex = 0
		}

		selectedMovieID := movieIDs[movieIndex]
		movieIndex++

		docRef := dailyGamesCollection.Doc(dateID)

		gameData := DailyGame{
			MovieID: selectedMovieID,
			Date:    gameDate,
		}

		// The document data structure is now type-safe via the struct.
		batch.Set(docRef, gameData)

		// Commit batch periodically to stay within transaction limits.
		if (i+1)%batchSize == 0 || i == daysToSchedule-1 {
			commitCount := i + 1
			log.Printf("Committing batch %d: scheduling up to %s...", commitCount/batchSize+1, dateID)

			_, err := batch.Commit(ctx)
			if err != nil {
				log.Fatalf("Batch commit failed for date %s: %v", dateID, err)
			}

			// Start a new batch after successful commit, unless done
			if i < daysToSchedule-1 {
				batch = client.Batch()
			}
		}
	}

	log.Println("All daily games have been successfully scheduled!")
}

================
File: utils/secrets.example.json
================
{
    "TMDBKey": "key from TMDB API"
}

================
File: .gitignore
================
node_modules/
.expo/
dist/
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/

# macOS
.DS_Store

# config
.env
data/credits.json
utils/secrets.json
utils/serviceAccountKey.json
eas.json
GoogleService-Info.plist
google-services.json

# third-party
repomix-output.xml

================
File: app.config.js
================
require("dotenv").config();

const myValue = "talkie-trivia";

module.exports = ({ config }) => ({
  ...config,
  scheme: "talkie-trivia",
  expo: {
    name: myValue,
    slug: "talkie-trivia",
    scheme: "talkie-trivia",
    version: process.env.MY_CUSTOM_PROJECT_VERSION || "1.0.0",
    orientation: "portrait",
    icon: "./assets/icon.png",
    userInterfaceStyle: "automatic",
    newArchEnabled: true,
    splash: {
      image: "./assets/splash.png",
      resizeMode: "contain",
      backgroundColor: "#ffffff",
      dark: {
        image: "./assets/splash.png",
        resizeMode: "contain",
        backgroundColor: "#121212",
      },
    },
    updates: {
      fallbackToCacheTimeout: 0
    },
    assetBundlePatterns: ["**/*"],
    plugins: [
      "@react-native-google-signin/google-signin",
      "expo-font",
      "expo-router",
      "expo-secure-store",
      [
        "expo-build-properties",
        {
          "ios": {
            "useFrameworks": "static",
            "podfileProperties": {
              "use_modular_headers!": "true"
            },
            "newArchEnabled": true
          },
          "android": {
            "newArchEnabled": true
          }
        }
      ]
    ],
    ios: {
      bundleIdentifier: "com.unrealities.talkietrivia",
      googleServicesFile: "./GoogleService-Info.plist",
      supportsTablet: true,
      userInterfaceStyle: "automatic"
    },
    android: {
      googleServicesFile: "./google-services.json",
      adaptiveIcon: {
        foregroundImage: "./assets/adaptive-icon.png",
        backgroundColor: "#FFFFFF"
      },
      package: "com.unrealities.talkietrivia",
      userInterfaceStyle: "automatic"
    },
    web: {
      favicon: "./assets/favicon.png"
    },
    extra: {
      "router": {
        "origin": false,
        "root": "src/app"
      },
      isE2E: process.env.IS_E2E === "true" || process.env.EXPO_PUBLIC_IS_E2E === "true",
      firebaseApiKey: process.env.FIREBASE_APIKEY,
      firebaseAppId: process.env.FIREBASE_APPID,
      firebaseMeasurementId: process.env.FIREBASE_MEASUREMENTID,
      firebaseMessagingSenderId: process.env.FIREBASE_MESSAGING_SENDERID,
      firebaseProjectId: process.env.FIREBASE_PROJECTID,
      themoviedbKey: process.env.THEMOVIEDB_APIKEY,
      expoClientId: process.env.CLIENTID_EXPO,
      iosClientId: process.env.CLIENTID_IOS,
      webClientId: process.env.CLIENTID_WEB,
      androidClientId: process.env.CLIENTID_ANDROID
    },
  },
});

================
File: babel.config.js
================
module.exports = function (api) {
    api.cache(true);
    return {
        presets: ["babel-preset-expo", "@babel/preset-typescript"],
        plugins: [
            [
                "@babel/plugin-transform-runtime",
                {
                    regenerator: true,
                },
            ],
            'react-native-reanimated/plugin',
        ],
    };
};

================
File: firestore.rules
================
rules_version = '2';

service cloud.firestore {
  match / databases / { database } / documents {

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function hasValidPlayerFields() {
      // A player can only create a document with their name and id.
      // Name must be a string, not empty, and reasonably short.
      return request.resource.data.keys().hasAll(['id', 'name'])
        && request.resource.data.size() == 2
        && request.resource.data.id == request.auth.uid
        && request.resource.data.name is string
          && request.resource.data.name.size() > 0
          && request.resource.data.name.size() < 50;
    }

    function isCreatingPlayerGame() {
      let data = request.resource.data;
      // On creation, the game must start in a default state.
      return data.playerID == request.auth.uid
        && data.guesses.size() == 0
        && data.correctAnswer == false
        && data.gaveUp == false
        && data.statsProcessed == false
        && data.guessesMax >= 3 && data.guessesMax <= 5
        && data.startDate == request.time;
    }

    function isUpdatingPlayerGame() {
      let incoming = request.resource.data;
      let existing = resource.data;

      // Fields that should never change after creation
      let isImmutableDataUnchanged = incoming.id == existing.id
        && incoming.playerID == existing.playerID
        && incoming.movie.id == existing.movie.id
        && incoming.startDate == existing.startDate;

      // A user can only add exactly one guess at a time.
      let isGuessListValid = incoming.guesses.size() == existing.guesses.size() + 1
        && incoming.guesses[existing.guesses.size()] is number;

      // You can't undo a win or a give-up decision.
      let isStateTransitionValid = (existing.correctAnswer == false || incoming.correctAnswer == true)
        && (existing.gaveUp == false || incoming.gaveUp == true);

      // The game should not be modifiable once it's over.
      let isGameAlreadyOver = existing.correctAnswer == true || existing.gaveUp == true || existing.guesses.size() >= existing.guessesMax;

      return isImmutableDataUnchanged
        && isStateTransitionValid
        && !isGameAlreadyOver
        && (isGuessListValid || incoming.gaveUp == true); // An update is either a guess or giving up.
    }

    function hasValidGameHistoryFields() {
      let data = request.resource.data;
      return data.keys().hasAll([
        'dateId', 'movieId', 'movieTitle', 'posterPath',
        'wasCorrect', 'gaveUp', 'guessCount', 'guessesMax', 'createdAt'
      ])
        && data.dateId is string
          && data.movieId is number
            && data.movieTitle is string
              && data.posterPath is string
                && data.wasCorrect is bool
                  && data.gaveUp is bool
                    && data.guessCount is number
                      && data.guessesMax is number
                        && data.createdAt == request.time;
    }

    // --- Collection Rules ---

    // Movies data is publically readable, but write access is locked down.
    match / movies / { movieId } {
  allow read: if true;
  allow write: if false; // Only allow writes from admin/backend scripts
    }

    // Daily games are readable by authenticated users, but not writable by clients.
    match / dailyGames / { dateId } {
  allow read: if request.auth != null;
  allow write: if false; // Only allow writes from a trusted server/function
    }

    // Player documents. A user can only access their own.
    match / players / { userId } {
  allow get, delete: if isOwner(userId);
  allow create: if isOwner(userId) && hasValidPlayerFields();
  // Allow a user to update only their name.
  allow update: if isOwner(userId)
        && request.resource.data.name != resource.data.name
        && request.resource.data.keys().hasOnly(['id', 'name']);

      // Sub-collection for a player's game history.
      // This write should only be performed by a trusted backend function when a game is processed.
      match / gameHistory / { dateId } {
    allow read: if isOwner(userId);
    // For maximum security, change to `allow write: if false;` and use a Cloud Function.
    // For now, we validate the client-written data shape.
    allow write: if isOwner(userId) && hasValidGameHistoryFields();
      }
    }

    // Player statistics. Read-only for clients. Must be updated by the backend.
    match / playerStats / { userId } {
  allow get: if isOwner(userId);
  // Deny all client-side writes to prevent cheating (e.g., manually setting streaks).
  // Stats should be calculated and updated by a Cloud Function after a game is completed.
  allow write: if false;
    }

    // A player's game state for a specific day. This is where clients write their progress.
    match / playerGames / { gameId } {
  // The gameId must be in the format `userId-date`
  allow read: if isOwner(gameId.split('-')[0]);
  allow create: if isOwner(gameId.split('-')[0]) && isCreatingPlayerGame();
  allow update: if isOwner(gameId.split('-')[0]) && isUpdatingPlayerGame();
    }

  }
}

================
File: index.tsx
================
import "expo-router/entry"

================
File: jest.config.js
================
module.exports = {
  preset: 'jest-expo',
  transformIgnorePatterns: [
    "node_modules/(?!(jest-)?react-native|@react-native|expo(nent)?|@expo(nent)?/.*|@unimodules/.*|unimodules|sentry-expo|native-base|react-native-svg|@react-navigation/.*|expo-modules-core|immer|zustand/.*)"
  ],
  setupFiles: ["./jestSetup.js"],
  setupFilesAfterEnv: ["@testing-library/jest-native/extend-expect"],
  moduleNameMapper: {
    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$': '<rootDir>/__mocks__/fileMock.js'
  },
  collectCoverage: true,
  collectCoverageFrom: [
    "src/**/*.{js,jsx,ts,tsx}",
    "!src/**/*.d.ts",
    "!src/styles/**/*",
    "!src/models/**/*",
    "!src/config/**/*",
    "!src/**/index.{js,ts,tsx}"
  ],
  coveragePathIgnorePatterns: [
    "/node_modules/",
    "/__tests__/",
    "/__mocks__/"
  ],
  coverageReporters: ["text", "lcov", "html"], // 'text' for console, 'html' for visual report
  // Optional: Enforce minimum thresholds (Fail CI if coverage drops below these %)
  /* 
  coverageThreshold: {
    global: {
      branches: 50,
      functions: 50,
      lines: 50,
      statements: 50
    }
  } 
  */
};

================
File: jestSetup.js
================
import { jest } from '@jest/globals';
import 'react-native-gesture-handler/jestSetup';

// --- GLOBAL MOCKS ---

// Reanimated setup
global.ReanimatedDataMock = {
  now: () => 0,
};

// --- CONSOLE SUPPRESSION ---
const originalConsoleError = console.error;
const originalConsoleLog = console.log;
const originalConsoleWarn = console.warn;

const logMessagesToSuppress = [
  "Firebase Analytics not supported",
  "[ANALYTICS - Skipped]",
  "You are calling concat on a terminating link",
  "Update to",
  "Warning: An update to",
  "AuthContext: Error during auth state change handling",
  "VideoGameService is not yet implemented",
  "Failed to open external link",
  "Error during sharing process",
  "Share action was canceled by the user"
];

const shouldSuppress = (args) => {
  const msg = args[0];
  return typeof msg === 'string' && logMessagesToSuppress.some(suppressedMsg => msg.includes(suppressedMsg));
};

console.error = (...args) => {
  if (shouldSuppress(args)) return;
  originalConsoleError(...args);
};

console.log = (...args) => {
  if (shouldSuppress(args)) return;
  originalConsoleLog(...args);
};

console.warn = (...args) => {
  if (shouldSuppress(args)) return;
  originalConsoleWarn(...args);
};

// --- MOCK REACT NATIVE ---
jest.mock('react-native', () => {
  const RN = jest.requireActual('react-native');

  // Mock Dimensions
  RN.Dimensions.get = jest.fn().mockReturnValue({ width: 375, height: 812, scale: 2, fontScale: 1 });
  RN.Dimensions.addEventListener = jest.fn();
  RN.Dimensions.removeEventListener = jest.fn();

  // Mock PixelRatio
  RN.PixelRatio.get = jest.fn(() => 2);
  RN.PixelRatio.getFontScale = jest.fn(() => 1);
  RN.PixelRatio.getPixelSizeForLayoutSize = jest.fn(size => size * 2);
  RN.PixelRatio.roundToNearestPixel = jest.fn(size => size);

  // Mock Animated
  RN.Animated.timing = (value, config) => ({
    start: (callback) => {
      value.setValue(config.toValue);
      callback && callback({ finished: true });
    },
  });

  return RN;
});

// --- EXPO MOCKS ---
jest.mock('expo-font', () => ({
  isLoaded: jest.fn().mockReturnValue(true),
  loadAsync: jest.fn().mockResolvedValue(true),
  useFonts: jest.fn().mockReturnValue([true, null]),
}));

jest.mock('expo-constants', () => ({
  ...jest.requireActual('expo-constants'),
  expoConfig: {
    extra: {
      firebaseApiKey: "mock-key",
      firebaseProjectId: "mock-project",
    },
  },
  deviceYearClass: 2023,
}));

jest.mock('expo-haptics', () => ({
  impactAsync: jest.fn(),
  notificationAsync: jest.fn(),
  ImpactFeedbackStyle: { Light: 'light', Medium: 'medium', Heavy: 'heavy' },
  NotificationFeedbackType: { Success: 'success', Warning: 'warning', Error: 'error' },
}));

jest.mock('expo-linking', () => ({
  createURL: jest.fn(),
  canOpenURL: jest.fn(() => Promise.resolve(true)),
  openURL: jest.fn(() => Promise.resolve(true)),
}));

// Mock Expo Image
jest.mock("expo-image", () => {
  const React = require("react");
  const { View } = require("react-native");
  const MockImage = React.forwardRef(({ source, ...props }, ref) => {
    // Handle both URI objects and local asset numbers (which equal 1 in Jest)
    const uri = source?.uri ? source.uri : undefined;
    return (
      <View
        ref={ref}
        testID="mock-expo-image"
        source={source}
        data-source={uri}
        {...props}
      />
    );
  });
  MockImage.displayName = "MockImage";
  return { Image: MockImage };
});

// Mock Vector Icons
jest.mock("@expo/vector-icons", () => {
  const React = require("react");
  const { Text } = require("react-native");
  const MockIcon = ({ name, testID, ...props }) => (
    <Text testID={testID || `mock-icon-${name}`} {...props}>
      {name}
    </Text>
  );
  return {
    FontAwesome: MockIcon,
    Ionicons: MockIcon,
    MaterialIcons: MockIcon,
    FontAwesome5: MockIcon,
  };
});

// --- ROUTER & STORAGE ---
jest.mock("expo-router", () => ({
  useRouter: () => ({
    push: jest.fn(),
    replace: jest.fn(),
    back: jest.fn(),
  }),
  useLocalSearchParams: jest.fn(() => ({})),
  Tabs: Object.assign((props) => props.children, {
    Screen: () => null
  }),
  Slot: ({ children }) => children,
}));

jest.mock('@react-native-async-storage/async-storage', () =>
  require('@react-native-async-storage/async-storage/jest/async-storage-mock')
);

// --- FIREBASE MOCKS ---
jest.mock("firebase/auth", () => ({
  getAuth: jest.fn(() => ({})),
  onAuthStateChanged: jest.fn(() => jest.fn()),
  signInAnonymously: jest.fn(),
  signInWithCredential: jest.fn(),
  signOut: jest.fn(),
  GoogleAuthProvider: { credential: jest.fn() },
}));

jest.mock("firebase/firestore", () => {
  class MockTimestamp {
    constructor(seconds, nanoseconds) {
      this.seconds = seconds || 0;
      this.nanoseconds = nanoseconds || 0;
    }
    toDate() { return new Date(this.seconds * 1000); }
    static now() { return new MockTimestamp(Date.now() / 1000, 0); }
    static fromDate(date) { return new MockTimestamp(date.getTime() / 1000, 0); }
  }
  return {
    getFirestore: jest.fn(),
    doc: jest.fn(() => ({ withConverter: jest.fn() })),
    collection: jest.fn(() => ({ withConverter: jest.fn() })),
    getDoc: jest.fn(),
    setDoc: jest.fn(),
    getDocs: jest.fn(),
    writeBatch: jest.fn(() => ({ commit: jest.fn(), set: jest.fn() })),
    query: jest.fn(),
    where: jest.fn(),
    orderBy: jest.fn(),
    limit: jest.fn(),
    Timestamp: MockTimestamp,
  };
});

jest.mock("firebase/app", () => ({
  initializeApp: jest.fn(),
  getApps: jest.fn(() => []),
  getApp: jest.fn(),
}));

jest.mock("firebase/performance", () => ({
  getPerformance: jest.fn(),
}));

jest.mock("firebase/analytics", () => ({
  getAnalytics: jest.fn(),
  isSupported: jest.fn().mockResolvedValue(false),
  logEvent: jest.fn(),
  setUserId: jest.fn(),
  setUserProperties: jest.fn(),
}));

// --- GLOBAL ---
global.ReanimatedDataMock = { now: () => 0 };
global.__DEV__ = true;

================
File: LICENSE
================
MIT License

Copyright (c) 2022 Tom Szymanski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "talkie-trivia",
  "version": "1.0.0",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/unrealities/talkie-trivia.git"
  },
  "license": "MIT",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "eject": "expo eject",
    "test": "jest --watchAll",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage --watchAll=false"
  },
  "dependencies": {
    "@expo-google-fonts/arvo": "^0.2.3",
    "@expo/vector-icons": "~14.0.4",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-native-google-signin/google-signin": "^11.0.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@shopify/flash-list": "1.7.3",
    "@shopify/react-native-skia": "1.5.0",
    "@testing-library/react-native": "^13.2.0",
    "babel-plugin-module-resolver": "^5.0.2",
    "browserify-fs": "^1.0.0",
    "comlink": "^4.4.2",
    "crypto-browserify": "^3.12.1",
    "dotenv": "^16.4.7",
    "expo": "~52.0.47",
    "expo-application": "~6.0.2",
    "expo-auth-session": "~6.0.3",
    "expo-build-properties": "~0.13.3",
    "expo-constants": "~17.0.7",
    "expo-file-system": "~18.0.12",
    "expo-firebase-analytics": "^8.0.0",
    "expo-font": "~13.0.4",
    "expo-haptics": "~14.0.1",
    "expo-image": "~2.0.7",
    "expo-linear-gradient": "~14.0.2",
    "expo-linking": "~7.0.5",
    "expo-network": "~7.0.5",
    "expo-random": "^14.0.1",
    "expo-router": "~4.0.21",
    "expo-secure-store": "~14.0.1",
    "expo-splash-screen": "~0.29.24",
    "expo-status-bar": "~2.0.1",
    "expo-updates": "~0.27.4",
    "expo-web-browser": "~14.0.2",
    "fast-fuzzy": "^1.12.0",
    "firebase": "^10.12.3",
    "firebase-admin": "^12.2.0",
    "fs": "^0.0.1-security",
    "immer": "^10.1.1",
    "jest-expo": "~52.0.6",
    "lodash": "^4.17.21",
    "react": "^18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.9",
    "react-native-chart-kit": "^6.12.0",
    "react-native-confetti-cannon": "^1.5.2",
    "react-native-config": "^1.5.5",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "15.8.0",
    "react-native-uuid": "^2.0.1",
    "react-native-vector-icons": "^10.3.0",
    "react-native-web": "~0.19.13",
    "resize-observer-polyfill": "^1.5.1",
    "undefined": "@expo/vector-icons/Ionicons",
    "victory": "^37.3.6",
    "victory-native": "^41.17.4",
    "vm": "^0.1.0",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@babel/preset-typescript": "^7.26.0",
    "@react-native/babel-preset": "^0.78.0",
    "@testing-library/jest-native": "^5.4.3",
    "@types/jest": "^29.5.14",
    "@types/react": "~18.3.12",
    "babel-jest": "^29.7.0",
    "jest": "^29.7.0",
    "typescript": "^5.3.3"
  }
}

================
File: README.md
================
# Talkie Trivia 

Talkie Trivia is an engaging daily trivia game built with **React Native** and **Expo**. The goal is simple yet challenging: guess the movie based on a progressively revealing plot summary.

Players can earn points, maintain streaks, use hints (like Director, Actors, and Genre), and compete on different difficulty levels. The app leverages a robust backend using **Firebase** for authentication and data storage, with a custom data pipeline written in **Go**.

##  Features

* **Daily Challenges:** A new movie to guess every day, synced globally.
* **Progressive Clues:** Plot summaries are revealed word-by-word or chunk-by-chunk.
* **Multiple Difficulty Levels:**
  * **Basic:** All meta-hints (Cast, Year, etc.) are revealed at the start.
  * **Easy:** Use hint points to reveal specific meta-data.
  * **Medium (Default):** "Implicit Feedback" - incorrect guesses reveal matching categories (e.g., guessing a movie with the same director reveals the director).
  * **Hard:** No hints allowed.
  * **Extreme:** Fewer guesses allowed, slower reveals.
* **Smart Search:** Fuzzy search to easily find and select movie titles.
* **Player Statistics:** Tracks current streaks, max streaks, win distribution, and all-time scores.
* **Game History:** Review past games and results.
* **Authentication:** Anonymous login and Google Sign-In support to save progress across devices.
* **Theming:** Full support for Light, Dark, and System themes.
* **Animations:** Smooth UI transitions using `react-native-reanimated`.

##  Tech Stack

### Frontend

* **Framework:** React Native (Expo Managed Workflow)
* **Language:** TypeScript
* **State Management:** Zustand (w/ Immer)
* **Navigation:** Expo Router (File-based routing)
* **Styling:** Custom hook-based theming system (`useStyles`)
* **Animations:** React Native Reanimated
* **Lists:** Shopify FlashList

### Backend & Data

* **Database:** Google Firestore
* **Auth:** Firebase Authentication
* **Analytics:** Firebase Analytics
* **Data Pipeline:** Go (Golang) scripts for fetching/processing TMDB data
* **Scheduling:** Google Cloud Functions / Go scripts

### Testing

* **Unit/Integration:** Jest & React Native Testing Library
* **End-to-End:** Maestro

[![codecov](https://codecov.io/github/unrealities/talkie-trivia/graph/badge.svg?token=GFK4VS5NWS)](https://codecov.io/github/unrealities/talkie-trivia)

##  Getting Started

### Prerequisites

* Node.js (LTS v18 or newer - Recommended v22)
* npm or yarn
* Expo CLI
* Go (optional, only for running data pipelines)

### Installation

1. **Clone the repository:**

    ```bash
    git clone https://github.com/unrealities/talkie-trivia.git
    cd talkie-trivia
    ```

2. **Install dependencies:**

    ```bash
    npm install
    ```

3. **Environment Configuration:**

    Create a `.env` file in the root directory. You will need credentials for Firebase, TMDB, and Google OAuth.

    ```env
    # Firebase Config
    FIREBASE_APIKEY=your_api_key
    FIREBASE_APPID=your_app_id
    FIREBASE_MEASUREMENTID=your_measurement_id
    FIREBASE_MESSAGING_SENDERID=your_sender_id
    FIREBASE_PROJECTID=your_project_id

    # Google Auth Client IDs
    CLIENTID_EXPO=your_expo_client_id
    CLIENTID_IOS=your_ios_client_id
    CLIENTID_ANDROID=your_android_client_id
    CLIENTID_WEB=your_web_client_id

    # Data Source
    THEMOVIEDB_APIKEY=your_tmdb_api_key
    ```

4. **Run the App:**

    ```bash
    npm start
    ```

    Use the Expo Go app on your device or an emulator to scan the QR code.

##  Testing

The project uses a two-tiered testing strategy: **Jest** for unit/integration logic and **Maestro** for full end-to-end user flows.

### Unit Tests (Jest)

These run automatically on every Pull Request via GitHub Actions.

* **Run all tests:**

    ```bash
    npm test
    ```

* **Run tests in watch mode (during development):**

    ```bash
    npm run test:watch
    ```

* **Generate Coverage Report:**

    ```bash
    npm run test:coverage
    ```

    *This generates an HTML report in `coverage/lcov-report/index.html`.*

### End-to-End Tests (Maestro)

Maestro tests run against a built version of your app (on Simulator/Emulator). They are located in `.maestro/flows/`.

1. **Install Maestro:**

    ```bash
    curl -Ls "https://get.maestro.mobile.dev" | bash
    ```

2. **Start your app:**
    Ensure your iOS Simulator or Android Emulator is running with the app installed and the development server started (`npm start`).

3. **Run a specific flow:**

    ```bash
    maestro test .maestro/flows/happy-path-win.yaml
    ```

4. **Run all flows:**

    ```bash
    maestro test .maestro/flows/
    ```

5. **Interactive Debugging (Maestro Studio):**
    If a test is failing, use Maestro Studio to inspect the UI hierarchy and find element IDs.

    ```bash
    maestro studio
    ```

##  Project Structure

src/
 app/ # Expo Router screens and layout
 components/ # Reusable UI components
  game/ # Gameplay specific components (Board, Input)
  gameOver/ # Results screen components
  ui/ # Generic atoms (Button, Card, Typography)
 config/ # Constants, difficulty settings, Firebase init
 contexts/ # React Contexts (Auth, Theme, Network)
 data/ # Local JSON fallbacks (basicMovies.json)
 models/ # TypeScript interfaces/types
 services/ # API and Firebase service layers
 state/ # Zustand global store
 styles/ # Global theme tokens and utility styles
 utils/ # Helper functions, hooks, and analytics

##  Data Pipeline (Go)

The `utils/` folder contains Go modules used to populate and schedule the game data.

1. **Data Generation:**
    Navigate to `utils/data-pipeline` to fetch data from TMDB and process it into `popularMovies.json`.

    ```bash
    cd utils/data-pipeline
    go run main.go
    ```

2. **Populate Firestore:**
    Uploads the processed JSON to the `movies` collection.

    ```bash
    cd utils/populate-firestore
    go run main.go
    ```

3. **Schedule Games:**
    Randomizes movies and assigns them to specific dates in the `dailyGames` collection.

    ```bash
    cd utils/schedule-games
    go run main.go
    ```

*Note: You will need a `serviceAccountKey.json` in the `utils/` folder to allow the Go scripts to write to Firestore.*

##  Contributing

Contributions are welcome! Please read the code of conduct and follow the standard pull request process:

1. Fork the repository.
2. Create a feature branch (`git checkout -b feature/amazing-feature`).
3. Commit your changes.
4. Push to the branch.
5. Open a Pull Request.

##  License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

##  Credits

* Movie data provided by [The Movie Database (TMDB)](https://www.themoviedb.org/).
* Built with [Expo](https://expo.dev/).

================
File: repomix.config.json
================
{
  "ignore": {
    "customPatterns": [
      "data/**",
      "utils/fetchPopularMovies/popular_movies_raw.json",
      "utils/basicMovies/basicMovies.json",
      "android/**",
      "ios/**"
    ]
  }
}

================
File: tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "esModuleInterop": true,
    "isolatedModules": true,
    "jsx": "react-native",
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*", "__tests__/**/*", "src/app/profile.tsx", "index.tsx"],
  "exclude": ["node_modules"]
}
